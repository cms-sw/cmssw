#!/usr/bin/env PYTHONUNBUFFERED=1 python
"""CMS Package Management script. Feedback and Help: mojedasa@cern.ch

This script must be able to run in Python 2.4.

Note: All commands that checkout/export tags try to make a 'src' folder
      if it does not exist. Then they checkout inside that folder.

Syntax:
    cmspm <command> [parameters]


Commands:
    co        Checkouts/exports tags read from stdin.

    corel     Checkouts/exports a full release using the tags
              from Tag Collector (i.e. works with non-tagged releases).

    frombase  1. Runs 'scram p CMSSW <project>'.
              2. Checkouts the diff tags between <release> and <baserelease>.
              3. Runs 'checkdeps'.
              4. Checkouts the packages from the 'checkdeps' output.
              5. Optionally, removes the CVS folders.
              The packages are checked-out one by one.
              The diff tags are fetched from Tag Collector.

    query     Query the tags of a release from Tag Collector.

    tag       Tags a release in CVS (using rtag).
              The packages are tagged one by one.
              The tags are fetched from Tag Collector.


Checkout (co) Command:
  Syntax:
    cmspm co [options]

  Options:
    -e   --export           Use CVS export instead of CVS checkout
                            (export does not download CVS folders
                            and is much faster).

    -n   --dry-run          Do not do anything, just print.

    -j   --n-threads        Number of threads used (default: 10, max: 99).


Checkout Release (corel) Command:
  Syntax:
    cmspm corel <release> [options]

  Options:
    -e   --export           Use CVS export instead of CVS checkout
                            (export does not download CVS folders
                            and is much faster).

    -o   --dumptags <file>  Dump the release's tags to a file.

    -n   --dry-run          Do not do anything, just print.

    -j   --n-threads        Number of threads used (default: 10, max: 99).


Frombase (frombase) Command:
  Syntax:
    cmspm frombase <release> <baserelease> <project> [options]

  Options:
    -e   --export           Remove the CVS folders after checkdeps has run
                            (i.e. the final results will look like using
                            the -e option in the 'corel' command).

    -o   --dumptags <file>  Dump the release's tags to a file.

    -j   --n-threads        Number of threads used (default: 10, max: 99).


Query (query) Command:
  Syntax:
    cmspm query <release>


Tag (tag) Command:
  Syntax:
    cmspm tag <release> [options]

  Options:
    -n   --dry-run          Do not do anything, just print.

    -j   --n-threads        Number of threads used (default: 10, max: 99).


Examples:
    cmspm co       < tags.txt
    cmspm corel    CMSSW_4_2_9_HLT1 -e -o tags.txt
    cmspm frombase CMSSW_4_2_9_HLT1_hltpatch1 CMSSW_4_2_9_HLT1 CMSSW_4_2_9_HLT1
    cmspm query    CMSSW_4_2_9_HLT1
    cmspm tag      CMSSW_4_2_9_HLT1
"""

__author__ = "Miguel Ojeda"
__copyright__ = "Copyright 2011, CERN CMS"
__credits__ = ["Miguel Ojeda"]
__license__ = "Unknown"
__maintainer__ = "Miguel Ojeda"
__email__ = "mojedasa@cern.ch"
__status__ = "Staging"

import time
import os
import sys
import shutil
import fnmatch
import httplib
import optparse
import subprocess
import threading
import Queue

from os import getenv

try:
  from subprocess import CalledProcessError
except ImportError:
  # Python 2.4 doesn't implement CalledProcessError
  class CalledProcessError(Exception):
    """This exception is raised when a process run by check_call() returns
       a non-zero exit status. The exit status will be stored in the
       returncode attribute."""
    def __init__(self, returncode, cmd):
      self.returncode = returncode
      self.cmd = cmd
    def __str__(self):
      return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

_maxtaglen = len('V01-01-01-01')

# Simple class similar to Pool in Python 2.6, but for threads and supporting
# only the useful map() method.
# Note: it is not a true pool as the threads are not kept between map() calls,
# i.e. they are not created in __init__().
class ThreadPool(object):
  def __init__(self, n_threads):
    self.n_threads = n_threads

  def map(self, function, arguments, common_arguments = ()):
    threads = []
    queue = Queue.Queue()
    for a in arguments:
      queue.put(a)

    for i in range(self.n_threads):
      t = threading.Thread(target = self._target, args = (i, function, queue, common_arguments, ))
      threads.append(t)
      t.start()

    for t in threads:
      t.join()

  def _target(self, tid, function, queue, common_arguments):
    while True:
      try:
        if function(tid, queue.get_nowait(), *common_arguments):
          return
      except Queue.Empty:
        return

# A recursive globbing helper (from cmsBuild).
def recursive_glob(treeroot, pattern):
  results = []
  for base, dirs, files in os.walk(treeroot):
    goodfiles = fnmatch.filter(files, pattern) + fnmatch.filter(dirs, pattern)
    results.extend(os.path.join(base, f) for f in goodfiles)
  return results

def die(msg):
  print msg
  sys.exit(1)

def deleteCVSFolders(treeroot):
  map(shutil.rmtree, recursive_glob(treeroot, 'CVS'))

def parseJSONTag(tag):
  if tag == 'null':
    return None
  return tag.strip('"')

def parseJSONTags(tags):
  tags = tags[1:-1]
  real_tags = []
  while True:
    start = tags.find('[')
    if start == -1:
      break
    end = tags.find(']')
    if end == -1:
      raise Exception('Error while parsing tags: Found the start of a tag ("[") but not the end ("]")')
    row = tags[start+1:end].split(', ')
    real_tag = [row[0].strip('"')]
    for tag in row[1:]:
      real_tag.append(parseJSONTag(tag))
    real_tags.append(real_tag)
    tags = tags[end+1:]

  return real_tags

def getReleasesTags(releases, diff):
  if diff:
    diff = 'true'
  else:
    diff = 'false'
  # This works in both Python 2.4 and Python 2.6 with the same code
  # With urllib you need different code (i.e. no getcode()).
  conn = httplib.HTTPSConnection("cmstags.cern.ch")
  conn.request("GET", '/tc/py_getReleasesTags?releases=["' + '","'.join(releases) + '"]&diff=' + diff)
  tags = conn.getresponse()
  conn.close()
  if tags.status != 200:
    raise Exception(tags.read())
  return parseJSONTags(tags.read())

# Get return a dictionary with package => tag for the 
# specified @a tagset
def getTagSetTags(tagsets):
  extratags = {}
  for tagset in tagsets:
    conn = httplib.HTTPSConnection("cmstags.cern.ch")
    conn.request("GET", '/tc/py_getTagsetTags?tagset=' + tagset)
    response = conn.getresponse()
    conn.close()
    if response.status != 200:
      raise Exception(response.read())
    extratags.update(dict(parseJSONTags(response.read())))
  return extratags

def formatTag(tag, maxlen = _maxtaglen):
  return tag + ' ' * (maxlen - len(tag))

class TagsDumper:
  def __init__(self, filename):
    try:
      self._dumptags_fd = None
      if filename:
        self._dumptags_fd = open(filename, 'w')
    except OSError:
      die("Cannot open file %s for writing" % opts.dumptags)
  
  def dump(self, tags):
    if self._dumptags_fd:
      for tag in tags:
        self._dumptags_fd.write(tag[0] + " " + tag[1] + "\n")
      self._dumptags_fd.close()

def popen(args, merge_stderr = True, shell = False):
  stderr = None
  if merge_stderr:
    stderr = subprocess.STDOUT
  p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=stderr, close_fds=True, shell=shell)
  r = p.communicate()[0]
  if p.returncode != 0:
    raise CalledProcessError(p.returncode, ' '.join(args))
  return r

def queryCVS(args, cvsroot, tries=5):
  if tries<1: tries=1
  while tries>0:
    tries -= 1
    try:
      return popen(['cvs', '-Q', '-d', cvsroot] + args)
    except Exception, ex:
      if tries==0: raise ex
    time.sleep(5)

def exportCVS(tag, args, cvsroot):
  return queryCVS(['export', '-r', tag] + args, cvsroot)

def checkoutCVS(tag, args, cvsroot):
  return queryCVS(['co', '-r', tag] + args, cvsroot)

def rtagCVS(tag, args, cvsroot):
  return queryCVS(['rtag', '-r', tag] + args, cvsroot)

def mergeTags(tags):
  new_tags = {}
  for (package, tag) in tags:
    if tag not in new_tags:
      new_tags[tag] = []
    new_tags[tag].append(package)
  return new_tags

def checkoutTag(tid, tag, lock, export, dryrun, cvsroot, errors):
  (tag, packages) = tag
  action = 'Checking out'
  if export:
    action = 'Exporting'
  try:
    lock.acquire()
    if len(errors) != 0:
      print "[Thread %2i] Stopping because something else failed." % tid
      return True
    print "[Thread %2i]" % tid, action + ":", formatTag(tag), ' '.join(packages)
  finally:
    lock.release()

  if dryrun:
    return

  try:
    if export:
      exportCVS(tag, packages, cvsroot)
    else:
      checkoutCVS(tag, packages, cvsroot)
  except:        
    try:
      lock.acquire()
      print "[Thread %2i]" % tid, action, "failed:", formatTag(tag), ' '.join(packages)
      errors.append(True)
      return True
    finally:
      lock.release()

def checkoutSubsystem(tid, tags, lock, export, dryrun, cvsroot, errors):
  tags = mergeTags(tags)
  failed = []
  for tag in tags:
    if checkoutTag(tid, (tag, tags[tag]), lock, export, dryrun, cvsroot, errors):
      return True

def checkNThreads(nthreads):
  if nthreads < 1:
    raise Exception("Error: The number of threads should be at least 1.")
  if nthreads > 99:
    raise Exception("Error: The number of threads should not be more than 99, in order to prevent loading the CVS server too much.")

# This function checkouts a list of tags using the best 'algorithm' to checkout them:
#   When checkout out, merge tags per subsystem and checkout the subsystems in parallel.
#   When exporting, merge all tags and export them in parallel.
def checkoutTags(tags, nthreads, export, dryrun, cvsroot):
  checkNThreads(nthreads)
  lock = threading.Lock()
  errors = []
  pool = ThreadPool(nthreads)

  if export:
    tags = mergeTags(tags)
    pool.map(checkoutTag, tags.items(), (lock, export, dryrun, cvsroot, errors))
  else:
    # When checking out, we can't run cvs in parallel for the same subsystem.
    # Otherwise, cvs would randomly access the CVS/* files.
    subsystems = {}
    for tag in tags:
      subsystem = tag[0].split('/')[0]
      if subsystem not in subsystems:
        subsystems[subsystem] = []
      subsystems[subsystem].append(tag)
    pool.map(checkoutSubsystem, subsystems.values(), (lock, export, dryrun, cvsroot, errors))

  if len(errors) != 0:
    die('Error: A checkout/export failed.')

def rtag(tid, tag, lock, release, dryrun, errors, cvsroot):
  (tag, packages) = tag

  try:
    lock.acquire()
    if len(errors) != 0:
      print "[Thread %2i] Stopping because something else failed." % tid
      return True
    print "[Thread %2i]" % tid, "Tagging:", formatTag(tag), release, ' '.join(packages)
  finally:
    lock.release()

  if dryrun:
    return

  try:
    rtagCVS(tag, [release] + packages, cvsroot)
  except:
    try:
      lock.acquire()
      print "[Thread %2i]" % tid, "Tagging failed:", formatTag(tag), release, ' '.join(packages)
      errors.append(True)
      return True
    finally:
      lock.release()

def cmd_co(args):
  parser = optparse.OptionParser(usage="cmspm co [options]")
  parser.add_option("-e", "--export", action="store_true", dest="export", default=False)
  parser.add_option("-n", "--dry-run", action="store_true", dest="dryrun", default=False)
  parser.add_option("-j", "--n-threads", action="store", type="int", dest="nthreads", default=10)
  parser.add_option("-d", "--cvsroot", dest="cvsroot", default=getenv("CVSROOT"))
  (opts, args) = parser.parse_args(args)

  if len(args) != 0:
    raise Exception("Error: No arguments expected.")
  
  folder = 'src'
  if not opts.dryrun:
    try:
      os.mkdir(folder)
    except OSError, e:
      pass
    os.chdir(folder)

  tags = {}
  for line in sys.stdin.readlines():
    line = line.split()
    if len(line) == 0:
      continue
    if len(line) != 2:
      raise Exception("Error: The input must be one (package, tag) pair per line.")
    (package, tag) = line
    if package in tags and tag != tags[package]:
      raise Exception("Error: The input contains a duplicate package with a different tag.")
    tags[package] = tag

  checkoutTags(tags.items(), opts.nthreads, opts.export, opts.dryrun, opts.cvsroot)

def cmd_corel(args):
  parser = optparse.OptionParser(usage="cmspm corel <release> [options]")
  parser.add_option("-e", "--export", action="store_true", dest="export", default=False)
  parser.add_option("-o", "--dump-tags", action="store", type="string", dest="dumptags", default=None)
  parser.add_option("-n", "--dry-run", action="store_true", dest="dryrun", default=False)
  parser.add_option("-j", "--n-threads", action="store", type="int", dest="nthreads", default=10)
  parser.add_option("-t", "--additional-tagsets", metavar="TAGSET1[+TAGSET2[+...]]", action="store", type="string", dest="additionalTagSetsSpec", default="")
  parser.add_option("-d", "--cvsroot", dest="cvsroot", default=getenv("CVSROOT"))
  (opts, args) = parser.parse_args(args)

  if len(args) != 1:
    raise Exception("Error: Expected <release>.")
  
  release = args[0]

  # Create destination directory, if needed.
  folder = 'src'
  if not opts.dryrun:
    try:
      os.mkdir(folder)
    except OSError, e:
      pass

  # Open the file before doing anything else to catch errors earlier
  dumper = TagsDumper(opts.dumptags)
  tags = getReleasesTags([release], False)

  # If additional tagsets are specified, we replace them int the final list of tags                                                                                                                                                                                                       
  # and in the tags to be checked out.
  additionalTagSets = [x for x in opts.additionalTagSetsSpec.split("+") if x]
  extraTagsetTags = getTagSetTags(additionalTagSets)
  tags = dict(tags)
  tags.update(extraTagsetTags)
  tags = tags.items()
  tags.sort()

  # Dump the tags first so that we can tell the difference.
  dumper.dump(tags)

  if opts.dryrun:
    sys.exit(0)

  os.chdir(folder)
  checkoutTags(tags, opts.nthreads, opts.export, opts.dryrun, opts.cvsroot)

def cmd_frombase(args):
  parser = optparse.OptionParser(usage="cmspm frombase <base-release> <release> <project>")
  parser.add_option("-e", "--export", action="store_true", dest="export", default=False)
  parser.add_option("-o", "--dump-tags", action="store", type="string", dest="dumptags", default=None)
  parser.add_option("-j", "--n-threads", action="store", type="int", dest="nthreads", default=10)
  parser.add_option("-n", "--dry-run", action="store_true", dest="dryrun", default=False)
  parser.add_option("-t", "--additional-tagsets", metavar="TAGSET1[+TAGSET2[+...]]", action="store", type="string", dest="additionalTagSetsSpec", default="")
  parser.add_option("-d", "--cvsroot", dest="cvsroot", default=getenv("CVSROOT"))
  (opts, args) = parser.parse_args(args)

  if len(args) != 3:
    raise Exception("Error: Expected <release> <baserelease> <project>.")
  
  release = args[0]
  baserelease = args[1]
  project = args[2]


  print "Getting tags from TagCollector..."
  tags = getReleasesTags([release], False)
  tagsdict = dict(tags)
  difftags = getReleasesTags([release, baserelease], True)
  # Check that no package was removed and warn if a package was added
  for tag in difftags:
    if tag[1] is None:
      die('Error: The base release contains the ' + tag[0] + ' package but the release does not (i.e. the package was removed).')
    if tag[2] is None:
      print 'Warning: The release contains the ' + tag[0] + ' package but the base release does not (i.e. the package was added).'
  # We only need the release's tags, not baserelease's tags
  difftags = dict((x[0], x[1]) for x in difftags)
  print "Getting tags from TagCollector... DONE"

  # If additional tagsets are specified, we replace them int the final list of tags
  # and in the tags to be checked out.
  additionalTagSets = [x for x in opts.additionalTagSetsSpec.split("+") if x]
  extraTagsetTags = getTagSetTags(additionalTagSets)
  tags = dict(tags)
  tags.update(extraTagsetTags)
  tags = tags.items()
  tags.sort()
  difftags.update(extraTagsetTags)

  if opts.dryrun:
    # Open the file before doing anything else to catch errors earlier
    dumper = TagsDumper(opts.dumptags)
    dumper.dump(tags)
    sys.exit(0)
    
  print "Running scram project..."
  popen(['scram', 'p', 'CMSSW', project])
  os.chdir(project)
  os.chdir('src')
  print "Running scram project... DONE"
  
  print "Checking out diff tags..."
  checkoutTags(difftags.items(), opts.nthreads, False, False, opts.cvsroot)
  print "Checking out diff tags... DONE"

  print "Running checkdeps..."
  deps = popen('eval `scram run -sh` && checkdeps', False, True)
  deps = deps.splitlines()
  deps_tags = []
  for dep in deps:
    # XXX FIXME Use a proper way to get the correct lines. Maybe make checkdeps print to stderr the info messages.
    if '(' not in dep:
      continue
    package = dep.split('(')[0].strip()
    tag = tagsdict[package]
    deps_tags.append([package, tag])
  print "Running checkdeps... DONE"

  print "Checking out dependencies..."
  checkoutTags(deps_tags, opts.nthreads, False, False, opts.cvsroot)
  print "Checking out dependencies... DONE"

  if opts.export:
    deleteCVSFolders('.')

  os.chdir('..')
  os.chdir('..')
  shutil.move(os.path.join(project, 'src'), 'src')
  shutil.rmtree(project)
  dumper = TagsDumper(opts.dumptags)
  dumper.dump(tags)

def cmd_query(args):
  parser = optparse.OptionParser(usage="cmspm query <release>")
  (opts, args) = parser.parse_args(args)

  if len(args) != 1:
    raise Exception("Error: Expected <release>.")

  release = args[0]

  tags = getReleasesTags([release], False)

  for tag in tags:
    print tag[0], tag[1]

def cmd_tag(args):
  parser = optparse.OptionParser(usage="cmspm tag <release> [options]")
  parser.add_option("-n", "--dry-run", action="store_true", dest="dryrun", default=False)
  parser.add_option("-j", "--n-threads", action="store", type="int", dest="nthreads", default=10)
  parser.add_option("-d", "--cvsroot", dest="cvsroot", default=getenv("CVSROOT"))
  (opts, args) = parser.parse_args(args)

  if len(args) != 1:
    raise Exception("Error: Expected <release>.")

  release = args[0]

  checkNThreads(opts.nthreads)

  print "Getting tags from TagCollector...",
  tags = getReleasesTags([release], False)
  print "DONE"

  lock = threading.Lock()
  errors = []
  pool = ThreadPool(opts.nthreads)
  tags = mergeTags(tags)
  pool.map(rtag, tags.items(), (lock, release, opts.dryrun, errors, opts.cvsroot))

  if len(errors) != 0:
    raise Exception('Error: A tagging failed.')

def main():
  try:
    args = sys.argv[1:]
    cmd = globals()['cmd_' + args[0]]
  except:
    print __doc__
    print "Exception: Expected <command>."
    sys.exit(-1)
  cmd(args[1:])

if __name__ == '__main__':
  main()

