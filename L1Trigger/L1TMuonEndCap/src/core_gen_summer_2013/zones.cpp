// This C++ source file was automatically generated
// by VPPC from a Verilog HDL project.
// VPPC web-page: http://www.phys.ufl.edu/~madorsky/vppc/

// Author    : madorsky
// Timestamp : Thu Mar 12 14:54:02 2015

#include "zones.h"

extern size_t __glob_alwaysn__;

void zones::operator()
(
	signal_& phzvl__io,
	signal_& ph_hit__io,
	signal_& ph_zone__io,
	signal_& clk__io
)
{
	if (!built)
	{
		seg_ch = 2;
		bw_ph = 8;
		bw_th = 7;
		bw_fph = 12;
		bw_fth = 8;
		bw_wg = 7;
		bw_ds = 7;
		bw_hs = 8;
		pat_w_st3 = 3;
		pat_w_st1 = pat_w_st3 + 1;
		full_pat_w_st3 = (1 << (pat_w_st3+1)) - 1;
		full_pat_w_st1 = (1 << (pat_w_st1+1)) - 1;
		padding_w_st1 = full_pat_w_st1 / 2;
		padding_w_st3 = full_pat_w_st3 / 2;
		red_pat_w_st3 = pat_w_st3 * 2 + 1;
		red_pat_w_st1 = pat_w_st1 * 2 + 1;
		fold = 4;
		th_ch11 = seg_ch*seg_ch;
		bw_q = 4;
		bw_addr = 7;
		ph_raw_w = (1 << pat_w_st3) * 15 + 2;
		th_raw_w = (1 << bw_th);
		max_drift = 3;
		bw_phi = 12;
		bw_eta = 7;
		ph_hit_w = 40+4;
		ph_hit_w20 = ph_hit_w;
		ph_hit_w10 = 20+4;
		th_hit_w = 56 + 8;
		endcap = 1;
		n_strips = (station <= 1 && cscid <= 2) ? 64 :
						 (station <= 1 && cscid >= 6) ? 64 : 80;
		n_wg = (station <= 1 && cscid <= 3) ? 48  :
					 (station <= 1 && cscid >= 6) ? 32  :
					 (station == 2 && cscid <= 3) ? 112 :
					 (station >= 3 && cscid <= 3) ? 96  : 64;
		th_coverage = (station <= 1 && cscid <= 2) ? 45  :
						 (station <= 1 && cscid >= 6) ? 27  :
						 (station <= 1 && cscid >= 3) ? 39  :
						 (station == 2 && cscid <= 2) ? 43  :
						 (station == 2 && cscid >= 3) ? 56  :
						 (station == 3 && cscid <= 2) ? 34  :
						 (station == 3 && cscid >= 3) ? 52  :
						 (station == 4 && cscid <= 2) ? 28  :
						 (station == 4 && cscid >= 3) ? 50  : 0;
		ph_coverage = (station <= 1 && cscid >= 6) ? 15 : //30 :
						   (station >= 2 && cscid <= 2) ? 40 : 20;
		th_ch = (station <= 1 && cscid <= 2) ? (seg_ch*seg_ch) : seg_ch;
		ph_reverse = (endcap == 1 && station >= 3) ? 1 : 
			   			   (endcap == 2 && station <  3) ? 1 : 0;
		th_mem_sz = (1 << bw_addr);
		th_corr_mem_sz = (1 << bw_addr);
		mult_bw = bw_fph + 11;
		ph_zone_bnd1 = (station <= 1 && cscid <= 2) ? 41 :
							(station == 2 && cscid <= 2) ? 41 :
							(station == 2 && cscid >  2) ? 87 :
							(station == 3 && cscid >  2) ? 49 :
							(station == 4 && cscid >  2) ? 49 : 127;
		ph_zone_bnd2 = (station == 3 && cscid >  2) ? 87 : 127;
		zone_overlap = 2;
		bwr = 6;
		bpow = 6;
		cnr = (1 << bpow);
		cnrex = ph_raw_w;
		build();
		// ph zone valid flags [station][chamber][zone]
// note that zone flags in phzvl are local to each chamber
		phzvl.attach(phzvl__io);
		// ph raw hits [station][chamber]
		ph_hit.attach(ph_hit__io);
		clk.attach(clk__io);
		// ph zones [zone][station]
		ph_zone.attach(ph_zone__io);
	}


	beginalways();

	// if (*) leads to infinite iterations in modelsim here. VPPC code is OK
	if (posedge (clk))
	{
		// the hardcoded numbers in the code below come from ph_init_full* files generated by CMSSW
		// they are divided by 32 since pattern detectors are using 7-bit phi.
		// Offset is subtracted from them to account for possible chamber movement
		// CMSSW software has these numbers in ph_init_hard array, so it can  ph_offsets
		
		// ph zone 0 stations 1234
		ph_zone[0][1] = 0;
		if (phzvl[0][0][0]) ph_zone[0][1].bp(  2 , ph_hit_w10) |= ph_hit[0][0];
		if (phzvl[0][1][0]) ph_zone[0][1].bp( 20 , ph_hit_w10) |= ph_hit[0][1];
		if (phzvl[0][2][0]) ph_zone[0][1].bp( 39 , ph_hit_w10) |= ph_hit[0][2];
		if (phzvl[1][0][0]) ph_zone[0][1].bp( 58 , ph_hit_w10) |= ph_hit[1][0];
		if (phzvl[1][1][0]) ph_zone[0][1].bp( 77 , ph_hit_w10) |= ph_hit[1][1];
		if (phzvl[1][2][0]) ph_zone[0][1].bp( 95 , ph_hit_w10) |= ph_hit[1][2];
                                                          
		ph_zone[0][2] = 0;                                 
		if (phzvl[2][0][0]) ph_zone[0][2].bp(	1 , ph_hit_w20) |= ph_hit[2][0];
		if (phzvl[2][1][0]) ph_zone[0][2].bp( 39 , ph_hit_w20) |= ph_hit[2][1];
		if (phzvl[2][2][0]) ph_zone[0][2].bp( 76 , ph_hit_w20) |= ph_hit[2][2];
														
		ph_zone[0][3] = 0;								
		if (phzvl[3][0][0]) ph_zone[0][3].bp(	1 , ph_hit_w20) |= ph_hit[3][0];
		if (phzvl[3][1][0]) ph_zone[0][3].bp( 39 , ph_hit_w20) |= ph_hit[3][1];
		if (phzvl[3][2][0]) ph_zone[0][3].bp( 76 , ph_hit_w20) |= ph_hit[3][2];

		ph_zone[0][4] = 0;								
		if (phzvl[4][0][0]) ph_zone[0][4].bp(	1 , ph_hit_w20) |= ph_hit[4][0];
		if (phzvl[4][1][0]) ph_zone[0][4].bp( 39 , ph_hit_w20) |= ph_hit[4][1];
		if (phzvl[4][2][0]) ph_zone[0][4].bp( 76 , ph_hit_w20) |= ph_hit[4][2];

		// ph zone 1 stations 1234
//		ph_zone[1][1] = ph_zone[0][1]; // data taken from the same chambers
//		ph_zone[1][2] = ph_zone[0][2];                                 
		ph_zone[1][1] = 0;
		if (phzvl[0][0][1]) ph_zone[1][1].bp(	2 , ph_hit_w10) |= ph_hit[0][0];
		if (phzvl[0][1][1]) ph_zone[1][1].bp( 20 , ph_hit_w10) |= ph_hit[0][1];
		if (phzvl[0][2][1]) ph_zone[1][1].bp( 39 , ph_hit_w10) |= ph_hit[0][2];
		if (phzvl[1][0][1]) ph_zone[1][1].bp( 58 , ph_hit_w10) |= ph_hit[1][0];
		if (phzvl[1][1][1]) ph_zone[1][1].bp( 77 , ph_hit_w10) |= ph_hit[1][1];
		if (phzvl[1][2][1]) ph_zone[1][1].bp( 95 , ph_hit_w10) |= ph_hit[1][2];
														
		ph_zone[1][2] = 0;								
		if (phzvl[2][0][1]) ph_zone[1][2].bp(	1 , ph_hit_w20) |= ph_hit[2][0];
		if (phzvl[2][1][1]) ph_zone[1][2].bp( 39 , ph_hit_w20) |= ph_hit[2][1];
		if (phzvl[2][2][1]) ph_zone[1][2].bp( 76 , ph_hit_w20) |= ph_hit[2][2];

														
		ph_zone[1][3] = 0;								
		if (phzvl[3][3][0]) ph_zone[1][3].bp(	2 , ph_hit_w10) |= ph_hit[3][3];
		if (phzvl[3][4][0]) ph_zone[1][3].bp( 21 , ph_hit_w10) |= ph_hit[3][4];
		if (phzvl[3][5][0]) ph_zone[1][3].bp( 39 , ph_hit_w10) |= ph_hit[3][5];
		if (phzvl[3][6][0]) ph_zone[1][3].bp( 58 , ph_hit_w10) |= ph_hit[3][6];
		if (phzvl[3][7][0]) ph_zone[1][3].bp( 77 , ph_hit_w10) |= ph_hit[3][7];
		if (phzvl[3][8][0]) ph_zone[1][3].bp( 95 , ph_hit_w10) |= ph_hit[3][8];
														  
		ph_zone[1][4] = 0;								
		if (phzvl[4][3][0]) ph_zone[1][4].bp(	2 , ph_hit_w10) |= ph_hit[4][3];
		if (phzvl[4][4][0]) ph_zone[1][4].bp( 21 , ph_hit_w10) |= ph_hit[4][4];
		if (phzvl[4][5][0]) ph_zone[1][4].bp( 39 , ph_hit_w10) |= ph_hit[4][5];
		if (phzvl[4][6][0]) ph_zone[1][4].bp( 58 , ph_hit_w10) |= ph_hit[4][6];
		if (phzvl[4][7][0]) ph_zone[1][4].bp( 77 , ph_hit_w10) |= ph_hit[4][7];
		if (phzvl[4][8][0]) ph_zone[1][4].bp( 95 , ph_hit_w10) |= ph_hit[4][8];

		// ph zone 2 stations 1234
		ph_zone[2][1] = 0;
		if (phzvl[0][3][0]) ph_zone[2][1].bp(	2 , ph_hit_w10) |= ph_hit[0][3];
		if (phzvl[0][4][0]) ph_zone[2][1].bp( 21 , ph_hit_w10) |= ph_hit[0][4];
		if (phzvl[0][5][0]) ph_zone[2][1].bp( 39 , ph_hit_w10) |= ph_hit[0][5];
		if (phzvl[1][3][0]) ph_zone[2][1].bp( 58 , ph_hit_w10) |= ph_hit[1][3];
		if (phzvl[1][4][0]) ph_zone[2][1].bp( 77 , ph_hit_w10) |= ph_hit[1][4];
		if (phzvl[1][5][0]) ph_zone[2][1].bp( 96 , ph_hit_w10) |= ph_hit[1][5];

		ph_zone[2][2] = 0;								
		if (phzvl[2][3][0]) ph_zone[2][2].bp(	2 , ph_hit_w10) |= ph_hit[2][3];
		if (phzvl[2][4][0]) ph_zone[2][2].bp( 21 , ph_hit_w10) |= ph_hit[2][4];
		if (phzvl[2][5][0]) ph_zone[2][2].bp( 39 , ph_hit_w10) |= ph_hit[2][5];
		if (phzvl[2][6][0]) ph_zone[2][2].bp( 58 , ph_hit_w10) |= ph_hit[2][6];
		if (phzvl[2][7][0]) ph_zone[2][2].bp( 77 , ph_hit_w10) |= ph_hit[2][7];
		if (phzvl[2][8][0]) ph_zone[2][2].bp( 95 , ph_hit_w10) |= ph_hit[2][8];

//		ph_zone[2][3] = ph_zone[1][3]; // data taken from the same chambers
//		ph_zone[2][4] = ph_zone[1][4];							  
		ph_zone[2][3] = 0;								   
		if (phzvl[3][3][1]) ph_zone[2][3].bp(	2 , ph_hit_w10) |= ph_hit[3][3];
		if (phzvl[3][4][1]) ph_zone[2][3].bp( 21 , ph_hit_w10) |= ph_hit[3][4];
		if (phzvl[3][5][1]) ph_zone[2][3].bp( 39 , ph_hit_w10) |= ph_hit[3][5];
		if (phzvl[3][6][1]) ph_zone[2][3].bp( 58 , ph_hit_w10) |= ph_hit[3][6];
		if (phzvl[3][7][1]) ph_zone[2][3].bp( 77 , ph_hit_w10) |= ph_hit[3][7];
		if (phzvl[3][8][1]) ph_zone[2][3].bp( 95 , ph_hit_w10) |= ph_hit[3][8];
														  
		ph_zone[2][4] = 0;								
		if (phzvl[4][3][1]) ph_zone[2][4].bp(	1 , ph_hit_w10) |= ph_hit[4][3];
		if (phzvl[4][4][1]) ph_zone[2][4].bp( 20 , ph_hit_w10) |= ph_hit[4][4];
		if (phzvl[4][5][1]) ph_zone[2][4].bp( 39 , ph_hit_w10) |= ph_hit[4][5];
		if (phzvl[4][6][1]) ph_zone[2][4].bp( 58 , ph_hit_w10) |= ph_hit[4][6];
		if (phzvl[4][7][1]) ph_zone[2][4].bp( 76 , ph_hit_w10) |= ph_hit[4][7];
		if (phzvl[4][8][1]) ph_zone[2][4].bp( 95 , ph_hit_w10) |= ph_hit[4][8];

		// ph zone 3 stations 1234
		ph_zone[3][1] = 0;
		ph_zone[3][1].bp(	4 , ph_hit_w10) |= ph_hit[0][6];
		ph_zone[3][1].bp( 23 , ph_hit_w10) |= ph_hit[0][7];
		ph_zone[3][1].bp( 42 , ph_hit_w10) |= ph_hit[0][8];
		ph_zone[3][1].bp( 61 , ph_hit_w10) |= ph_hit[1][6];
		ph_zone[3][1].bp( 79 , ph_hit_w10) |= ph_hit[1][7];
		ph_zone[3][1].bp( 98 , ph_hit_w10) |= ph_hit[1][8];

//		ph_zone[3][2] = ph_zone[2][2]; // data taken from the same chambers
//		ph_zone[3][3] = ph_zone[2][3];
		ph_zone[3][2] = 0;                                 
		if (phzvl[2][3][1]) ph_zone[3][2].bp(	2 , ph_hit_w10) |= ph_hit[2][3];
		if (phzvl[2][4][1]) ph_zone[3][2].bp( 21 , ph_hit_w10) |= ph_hit[2][4];
		if (phzvl[2][5][1]) ph_zone[3][2].bp( 39 , ph_hit_w10) |= ph_hit[2][5];
		if (phzvl[2][6][1]) ph_zone[3][2].bp( 58 , ph_hit_w10) |= ph_hit[2][6];
		if (phzvl[2][7][1]) ph_zone[3][2].bp( 77 , ph_hit_w10) |= ph_hit[2][7];
		if (phzvl[2][8][1]) ph_zone[3][2].bp( 95 , ph_hit_w10) |= ph_hit[2][8];

		ph_zone[3][3] = 0;								  
		if (phzvl[3][3][2]) ph_zone[3][3].bp(	2 , ph_hit_w10) |= ph_hit[3][3];
		if (phzvl[3][4][2]) ph_zone[3][3].bp( 21 , ph_hit_w10) |= ph_hit[3][4];
		if (phzvl[3][5][2]) ph_zone[3][3].bp( 39 , ph_hit_w10) |= ph_hit[3][5];
		if (phzvl[3][6][2]) ph_zone[3][3].bp( 58 , ph_hit_w10) |= ph_hit[3][6];
		if (phzvl[3][7][2]) ph_zone[3][3].bp( 77 , ph_hit_w10) |= ph_hit[3][7];
		if (phzvl[3][8][2]) ph_zone[3][3].bp( 95 , ph_hit_w10) |= ph_hit[3][8];

		ph_zone[3][4] = 0; // no st 4 in this zone
	}
	endalways();
}

// vppc: code below this point are service functions, should not require your attention

// vppc: this function assigns initial values to parameters and localparams
void zones::defparam()
{
	station = 1;
	cscid = 1;
}

// vppc: this function allocates memory for internal signals
void zones::build()
{
	built = true;
	phzvl.add_dim(4, 0);
	phzvl.add_dim(8, 0);
	phzvl.bw(2, 0);
	phzvl.build();
	ph_hit.add_dim(4, 0);
	ph_hit.add_dim(8, 0);
	ph_hit.bw(ph_hit_w-1, 0);
	ph_hit.build();
	clk.bw(0, 0);
	ph_zone.add_dim(3, 0);
	ph_zone.add_dim(4, 1);
	ph_zone.bw(ph_raw_w-1, 0);
	ph_zone.build();

}

// vppc: this function checks for changes in any signal on each simulation iteration
void zones::init ()
{
	if (!built)
	{
			}
	else
	{
																																															}
}
