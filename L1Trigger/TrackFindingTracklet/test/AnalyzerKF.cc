#include "FWCore/Framework/interface/one/EDAnalyzer.h"
#include "FWCore/Framework/interface/Run.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/Utilities/interface/EDGetToken.h"
#include "FWCore/Utilities/interface/InputTag.h"
#include "FWCore/Utilities/interface/Exception.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "DataFormats/Common/interface/Handle.h"

#include "SimTracker/TrackTriggerAssociation/interface/StubAssociation.h"
#include "L1Trigger/TrackTrigger/interface/Setup.h"
#include "L1Trigger/TrackFindingTracklet/interface/DataFormats.h"

#include <TProfile.h>
#include <TH1F.h>
#include <TEfficiency.h>

#include <vector>
#include <utility>
#include <deque>
#include <set>
#include <cmath>
#include <numeric>
#include <sstream>

namespace trklet {

  /*! \class  trklet::AnalyzerKF
   *  \brief  Class to analyze hardware like structured TTTrack Collection generated by Kalman Filter
   *  \author Thomas Schuh
   *  \date   2020, Sep
   */
  class AnalyzerKF : public edm::one::EDAnalyzer<edm::one::WatchRuns, edm::one::SharedResources> {
  public:
    AnalyzerKF(const edm::ParameterSet& iConfig);
    void beginJob() override {}
    void beginRun(const edm::Run& iEvent, const edm::EventSetup& iSetup) override;
    void analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) override;
    void endRun(const edm::Run& iEvent, const edm::EventSetup& iSetup) override {}
    void endJob() override;

  private:
    //
    void associate(const std::vector<TrackKF>& tracks,
                   const std::vector<std::vector<StubKF*>>& stubs,
                   int region,
                   const tt::StubAssociation* ass,
                   std::set<TPPtr>& tps,
                   int& sum,
                   const std::vector<TH1F*>& his,
                   const std::vector<TProfile*>& prof,
                   bool perfect = true) const;
    //
    void analyzeTPz0(const tt::StubAssociation* sa);
    // ED input token of accepted Tracks
    edm::EDGetTokenT<tt::StreamsStub> edGetTokenStubs_;
    // ED input token of accepted Stubs
    edm::EDGetTokenT<tt::StreamsTrack> edGetTokenTracks_;
    // ED input token for number of accepted States
    edm::EDGetTokenT<int> edGetTokenNumStatesAccepted_;
    // ED input token for number of lost States
    edm::EDGetTokenT<int> edGetTokenNumStatesTruncated_;
    // ED input token of TTStubRef to TPPtr association for tracking efficiency
    edm::EDGetTokenT<tt::StubAssociation> edGetTokenSelection_;
    // ED input token of TTStubRef to recontructable TPPtr association
    edm::EDGetTokenT<tt::StubAssociation> edGetTokenReconstructable_;
    // Setup token
    edm::ESGetToken<tt::Setup, tt::SetupRcd> esGetTokenSetup_;
    // DataFormats token
    edm::ESGetToken<DataFormats, ChannelAssignmentRcd> esGetTokenDataFormats_;
    // stores, calculates and provides run-time constants
    const tt::Setup* setup_ = nullptr;
    //
    const DataFormats* dataFormats_ = nullptr;
    // enables analyze of TPs
    bool useMCTruth_;
    //
    int nEvents_ = 0;
    //
    std::string label_;

    // Histograms

    TProfile* prof_;
    TProfile* profChannel_;
    TH1F* hisChannel_;
    std::vector<TH1F*> hisRes_;
    std::vector<TProfile*> profRes_;
    TH1F* hisEffD0_;
    TH1F* hisEffD0Total_;
    TEfficiency* effD0_;
    TH1F* hisEffEta_;
    TH1F* hisEffEtaTotal_;
    TEfficiency* effEta_;
    TH1F* hisEffInv2R_;
    TH1F* hisEffInv2RTotal_;
    TEfficiency* effInv2R_;
    TH1F* hisEffPT_;
    TH1F* hisEffPTTotal_;
    TEfficiency* effPT_;
    TH1F* hisTracks_;
    TH1F* hisLayers_;
    TH1F* hisNumLayers_;
    TProfile* profNumLayers_;

    // printout
    std::stringstream log_;
  };

  AnalyzerKF::AnalyzerKF(const edm::ParameterSet& iConfig)
      : useMCTruth_(iConfig.getParameter<bool>("UseMCTruth")), nEvents_(0), hisRes_(9), profRes_(5) {
    usesResource("TFileService");
    // book in- and output ED products
    label_ = iConfig.getParameter<std::string>("OutputLabelKF");
    const std::string& branchStubs = iConfig.getParameter<std::string>("BranchStubs");
    const std::string& branchTracks = iConfig.getParameter<std::string>("BranchTracks");
    const std::string& branchTruncated = iConfig.getParameter<std::string>("BranchTruncated");
    edGetTokenStubs_ = consumes<tt::StreamsStub>(edm::InputTag(label_, branchStubs));
    edGetTokenTracks_ = consumes<tt::StreamsTrack>(edm::InputTag(label_, branchTracks));
    edGetTokenNumStatesAccepted_ = consumes<int>(edm::InputTag(label_, branchTracks));
    edGetTokenNumStatesTruncated_ = consumes<int>(edm::InputTag(label_, branchTruncated));
    if (useMCTruth_) {
      const auto& inputTagSelecttion = iConfig.getParameter<edm::InputTag>("InputTagSelection");
      const auto& inputTagReconstructable = iConfig.getParameter<edm::InputTag>("InputTagReconstructable");
      edGetTokenSelection_ = consumes<tt::StubAssociation>(inputTagSelecttion);
      edGetTokenReconstructable_ = consumes<tt::StubAssociation>(inputTagReconstructable);
    }
    // book ES products
    esGetTokenSetup_ = esConsumes<edm::Transition::BeginRun>();
    esGetTokenDataFormats_ = esConsumes<edm::Transition::BeginRun>();
    // log config
    log_.setf(std::ios::fixed, std::ios::floatfield);
    log_.precision(4);
  }

  void AnalyzerKF::beginRun(const edm::Run& iEvent, const edm::EventSetup& iSetup) {
    // helper class to store configurations
    setup_ = &iSetup.getData(esGetTokenSetup_);
    dataFormats_ = &iSetup.getData(esGetTokenDataFormats_);
    // book histograms
    edm::Service<TFileService> fs;
    TFileDirectory dir;
    dir = fs->mkdir("KF");
    prof_ = dir.make<TProfile>("Counts", ";", 14, 0.5, 14.5);
    prof_->GetXaxis()->SetBinLabel(1, "Stubs");
    prof_->GetXaxis()->SetBinLabel(2, "Tracks");
    prof_->GetXaxis()->SetBinLabel(4, "Matched Tracks");
    prof_->GetXaxis()->SetBinLabel(5, "All Tracks");
    prof_->GetXaxis()->SetBinLabel(6, "Found TPs");
    prof_->GetXaxis()->SetBinLabel(7, "Found selected TPs");
    prof_->GetXaxis()->SetBinLabel(9, "All TPs");
    prof_->GetXaxis()->SetBinLabel(10, "states");
    prof_->GetXaxis()->SetBinLabel(12, "max tp");
    prof_->GetXaxis()->SetBinLabel(13, "All electron TPs");
    prof_->GetXaxis()->SetBinLabel(14, "max electron tp");
    // channel occupancy
    constexpr int maxOcc = 180;
    const int numChannels = 1;
    hisChannel_ = dir.make<TH1F>("His Channel Occupancy", ";", maxOcc, -.5, maxOcc - .5);
    profChannel_ = dir.make<TProfile>("Prof Channel Occupancy", ";", numChannels, -.5, numChannels - .5);
    // resoultions
    static const std::vector<std::string> names = {"phi0", "inv2R", "z0", "cot", "d0"};
    static const std::vector<double> ranges = {.01, .004, 5., .4, 5.};
    for (int i = 0; i < 5; i++) {
      hisRes_[i] = dir.make<TH1F>(("HisRes" + names[i]).c_str(), ";", 100, -ranges[i], ranges[i]);
      profRes_[i] = dir.make<TProfile>(("ProfRes" + names[i]).c_str(), ";", 32, 0, 2.4);
    }
    for (int i = 5; i < 9; i++) {
      const std::string name = (i < 7 ? names[2] : names[3]) + (i % 2 == 1 ? "plus" : "minus");
      const double range = (i < 7 ? ranges[2] : ranges[3]);
      hisRes_[i] = dir.make<TH1F>(("HisRes" + name).c_str(), ";", 100, -range, range);
    }
    // Efficiencies
    const double rangeD0 = 10.;
    hisEffD0_ = dir.make<TH1F>("HisTPD0", ";", 32, -rangeD0 / 2., rangeD0 / 2.);
    hisEffD0Total_ = dir.make<TH1F>("HisTPD0Total", ";", 32, -rangeD0 / 2., rangeD0 / 2.);
    effD0_ = dir.make<TEfficiency>("EffD0", ";", 32, -rangeD0 / 2., rangeD0 / 2.);
    hisEffEtaTotal_ = dir.make<TH1F>("HisTPEtaTotal", ";", 48, -2.4, 2.4);
    hisEffEta_ = dir.make<TH1F>("HisTPEta", ";", 48, -2.4, 2.4);
    effEta_ = dir.make<TEfficiency>("EffEta", ";", 48, -2.4, 2.4);
    const double rangeInv2R = dataFormats_->format(Variable::inv2R, Process::dr).range();
    hisEffInv2R_ = dir.make<TH1F>("HisTPInv2R", ";", 32, -rangeInv2R / 2., rangeInv2R / 2.);
    hisEffInv2RTotal_ = dir.make<TH1F>("HisTPInv2RTotal", ";", 32, -rangeInv2R / 2., rangeInv2R / 2.);
    effInv2R_ = dir.make<TEfficiency>("EffInv2R", ";", 32, -rangeInv2R / 2., rangeInv2R / 2.);
    hisEffPT_ = dir.make<TH1F>("HisTPPT", ";", 100, 0, 100);
    hisEffPTTotal_ = dir.make<TH1F>("HisTPPTTotal", ";", 100, 0, 100);
    effPT_ = dir.make<TEfficiency>("EffPT", ";", 100, 0, 100);
    // tracks
    hisTracks_ = dir.make<TH1F>("HisTracks", ";", 40, 0., 400);
    // layers
    hisLayers_ = dir.make<TH1F>("HisLayers", ";", 8, 0, 8);
    hisNumLayers_ = dir.make<TH1F>("HisNumLayers", ";", 9, 0, 9);
    profNumLayers_ = dir.make<TProfile>("Prof NumLayers", ";", 32, 0, 2.4);
  }

  void AnalyzerKF::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {
    static const int numLayers = setup_->numLayers();
    auto fill = [this](const TPPtr& tpPtr, TH1F* hisEta, TH1F* hisInv2R, TH1F* hisPT, TH1F* hisD0) {
      hisEta->Fill(tpPtr->eta());
      hisInv2R->Fill(tpPtr->charge() / tpPtr->pt() * setup_->invPtToDphi());
      hisPT->Fill(tpPtr->pt());
      hisD0->Fill(tpPtr->d0());
    };
    // read in kf products
    edm::Handle<tt::StreamsStub> handleStubs;
    iEvent.getByToken<tt::StreamsStub>(edGetTokenStubs_, handleStubs);
    const tt::StreamsStub& allStubs = *handleStubs;
    edm::Handle<tt::StreamsTrack> handleTracks;
    iEvent.getByToken<tt::StreamsTrack>(edGetTokenTracks_, handleTracks);
    const tt::StreamsTrack& allTracks = *handleTracks;
    edm::Handle<int> handleNumStatesAccepted;
    iEvent.getByToken<int>(edGetTokenNumStatesAccepted_, handleNumStatesAccepted);
    edm::Handle<int> handleNumStatesTruncated;
    iEvent.getByToken<int>(edGetTokenNumStatesTruncated_, handleNumStatesTruncated);
    // read in MCTruth
    const tt::StubAssociation* selection = nullptr;
    const tt::StubAssociation* reconstructable = nullptr;
    if (useMCTruth_) {
      edm::Handle<tt::StubAssociation> handleSelection;
      iEvent.getByToken<tt::StubAssociation>(edGetTokenSelection_, handleSelection);
      selection = handleSelection.product();
      prof_->Fill(9, selection->numTPs());
      edm::Handle<tt::StubAssociation> handleReconstructable;
      iEvent.getByToken<tt::StubAssociation>(edGetTokenReconstructable_, handleReconstructable);
      reconstructable = handleReconstructable.product();
      for (const auto& p : selection->getTrackingParticleToTTStubsMap())
        fill(p.first, hisEffEtaTotal_, hisEffInv2RTotal_, hisEffPTTotal_, hisEffD0Total_);
    }
    // analyze kf products and associate found tracks with reconstrucable TrackingParticles
    std::set<TPPtr> tpPtrs;
    std::set<TPPtr> tpPtrsSelection;
    std::set<TPPtr> tpPtrsMax;
    int numMatched(0);
    int numTracks(0);
    for (int region = 0; region < setup_->numRegions(); region++) {
      int nRegionStubs(0);
      int nRegionTracks(0);
      const int offset = region * numLayers;
      const tt::StreamTrack& channelTracks = allTracks[region];
      hisChannel_->Fill(channelTracks.size());
      profChannel_->Fill(1, channelTracks.size());
      std::vector<TrackKF> tracks;
      std::vector<StubKF> stubs;
      std::vector<std::vector<StubKF*>> tracksStubs(channelTracks.size(), std::vector<StubKF*>(numLayers, nullptr));
      tracks.reserve(channelTracks.size());
      stubs.reserve(channelTracks.size() * numLayers);
      for (int frame = 0; frame < (int)channelTracks.size(); frame++) {
        tracks.emplace_back(channelTracks[frame], dataFormats_);
        const double eta = std::abs(std::asinh(tracks.back().cot()));
        int nLayers(0);
        for (int layer = 0; layer < numLayers; layer++) {
          const tt::FrameStub& fs = allStubs[offset + layer][frame];
          if (fs.first.isNull())
            continue;
          stubs.emplace_back(fs, dataFormats_);
          tracksStubs[frame][layer] = &stubs.back();
          hisLayers_->Fill(layer);
          nLayers++;
        }
        hisNumLayers_->Fill(nLayers);
        profNumLayers_->Fill(eta, nLayers);
      }
      nRegionStubs += stubs.size();
      nRegionTracks += tracks.size();
      if (!useMCTruth_)
        continue;
      int tmp(0);
      associate(tracks, tracksStubs, region, selection, tpPtrsSelection, tmp, hisRes_, profRes_);
      associate(tracks,
                tracksStubs,
                region,
                reconstructable,
                tpPtrs,
                numMatched,
                std::vector<TH1F*>(),
                std::vector<TProfile*>());
      associate(
          tracks, tracksStubs, region, selection, tpPtrsMax, tmp, std::vector<TH1F*>(), std::vector<TProfile*>(), false);
      numTracks += nRegionTracks;
      prof_->Fill(1, nRegionStubs);
      prof_->Fill(2, nRegionTracks);
    }
    for (const TPPtr& tpPtr : tpPtrsSelection)
      fill(tpPtr, hisEffEta_, hisEffInv2R_, hisEffPT_, hisEffD0_);
    prof_->Fill(4, numMatched);
    prof_->Fill(5, numTracks);
    prof_->Fill(6, tpPtrs.size());
    prof_->Fill(7, tpPtrsSelection.size());
    prof_->Fill(10, *handleNumStatesAccepted);
    prof_->Fill(11, *handleNumStatesTruncated);
    prof_->Fill(12, tpPtrsMax.size());
    hisTracks_->Fill(numTracks);
    nEvents_++;
  }

  void AnalyzerKF::endJob() {
    if (nEvents_ == 0)
      return;
    // effi
    effD0_->SetPassedHistogram(*hisEffD0_, "f");
    effD0_->SetTotalHistogram(*hisEffD0Total_, "f");
    effEta_->SetPassedHistogram(*hisEffEta_, "f");
    effEta_->SetTotalHistogram(*hisEffEtaTotal_, "f");
    effInv2R_->SetPassedHistogram(*hisEffInv2R_, "f");
    effInv2R_->SetTotalHistogram(*hisEffInv2RTotal_, "f");
    effPT_->SetPassedHistogram(*hisEffPT_, "f");
    effPT_->SetTotalHistogram(*hisEffPTTotal_, "f");
    // printout SF summary
    const double totalTPs = prof_->GetBinContent(9);
    const double numStubs = prof_->GetBinContent(1);
    const double numTracks = prof_->GetBinContent(2);
    const double totalTracks = prof_->GetBinContent(5);
    const double numTracksMatched = prof_->GetBinContent(4);
    const double numTPsAll = prof_->GetBinContent(6);
    const double numTPsEff = prof_->GetBinContent(7);
    const double numTPsEffMax = prof_->GetBinContent(12);
    const double errStubs = prof_->GetBinError(1);
    const double errTracks = prof_->GetBinError(2);
    const double fracFake = (totalTracks - numTracksMatched) / totalTracks;
    const double fracDup = (numTracksMatched - numTPsAll) / totalTracks;
    const double eff = numTPsEff / totalTPs;
    const double errEff = std::sqrt(eff * (1. - eff) / totalTPs / nEvents_);
    const double effMax = numTPsEffMax / totalTPs;
    const double errEffMax = std::sqrt(effMax * (1. - effMax) / totalTPs / nEvents_);
    const int numStates = prof_->GetBinContent(10);
    const int numStatesLost = prof_->GetBinContent(11);
    const double fracSatest = numStates / (double)(numStates + numStatesLost);
    const std::vector<double> nums = {numStubs, numTracks};
    const std::vector<double> errs = {errStubs, errTracks};
    const int wNums = std::ceil(std::log10(*std::max_element(nums.begin(), nums.end()))) + 5;
    const int wErrs = std::ceil(std::log10(*std::max_element(errs.begin(), errs.end()))) + 5;
    log_ << "                         KF  SUMMARY                         " << std::endl;
    log_ << "number of stubs       per TFP = " << std::setw(wNums) << numStubs << " +- " << std::setw(wErrs) << errStubs
         << std::endl;
    log_ << "number of tracks      per TFP = " << std::setw(wNums) << numTracks << " +- " << std::setw(wErrs)
         << errTracks << std::endl;
    log_ << "          tracking efficiency = " << std::setw(wNums) << eff << " +- " << std::setw(wErrs) << errEff
         << std::endl;
    log_ << "      max tracking efficiency = " << std::setw(wNums) << effMax << " +- " << std::setw(wErrs) << errEffMax
         << std::endl;
    log_ << "                    fake rate = " << std::setw(wNums) << fracFake << std::endl;
    log_ << "               duplicate rate = " << std::setw(wNums) << fracDup << std::endl;
    log_ << "    state assessment fraction = " << std::setw(wNums) << fracSatest << std::endl;
    log_ << "     number of states per TFP = " << std::setw(wNums) << (numStates + numStatesLost) / setup_->numRegions()
         << std::endl;
    log_ << "=============================================================";
    edm::LogPrint(moduleDescription().moduleName()) << log_.str();
  }

  //
  void AnalyzerKF::associate(const std::vector<TrackKF>& tracks,
                             const std::vector<std::vector<StubKF*>>& tracksStubs,
                             int region,
                             const tt::StubAssociation* ass,
                             std::set<TPPtr>& tps,
                             int& sum,
                             const std::vector<TH1F*>& his,
                             const std::vector<TProfile*>& prof,
                             bool perfect) const {
    for (int frame = 0; frame < static_cast<int>(tracks.size()); frame++) {
      const TrackKF& track = tracks[frame];
      const std::vector<StubKF*>& stubs = tracksStubs[frame];
      std::vector<TTStubRef> ttStubRefs;
      ttStubRefs.reserve(stubs.size());
      TTBV hitPattern(0, setup_->numLayers());
      int layer(-1);
      for (StubKF* stub : stubs) {
        layer++;
        if (!stub)
          continue;
        hitPattern.set(layer);
        ttStubRefs.push_back(stub->frame().first);
      }
      const std::vector<TPPtr>& tpPtrs = perfect ? ass->associateFinal(ttStubRefs) : ass->associate(ttStubRefs);
      if (tpPtrs.empty())
        continue;
      sum++;
      std::copy(tpPtrs.begin(), tpPtrs.end(), std::inserter(tps, tps.begin()));
      if (his.empty())
        continue;
      const double cot = track.cot();
      const double z0 = track.zT() - setup_->chosenRofZ() * cot;
      const double inv2R = track.inv2R();
      const double phi0 = tt::deltaPhi(track.phiT() - setup_->chosenRofPhi() * inv2R +
                                       region * dataFormats_->format(Variable::phiT, Process::kf).range());
      for (const TPPtr& tpPtr : tpPtrs) {
        const double tpPhi0 = tpPtr->phi();
        const double tpCot = std::sinh(tpPtr->eta());
        const double tpInv2R = -setup_->invPtToDphi() * tpPtr->charge() / tpPtr->pt();
        const math::XYZPointD& v = tpPtr->vertex();
        const double tpZ0 = v.z() - tpCot * (v.x() * cos(tpPhi0) + v.y() * sin(tpPhi0));
        const double dCot = tpCot - cot;
        const double dZ0 = tpZ0 - z0;
        const double dInv2R = tpInv2R - inv2R;
        const double dPhi0 = tt::deltaPhi(tpPhi0 - phi0);
        const double dD0 = tpPtr->d0() + track.frame().first->d0();
        const std::vector<double> ds = {dPhi0, dInv2R / setup_->invPtToDphi(), dZ0, dCot, dD0};
        for (int i = 0; i < (int)ds.size(); i++) {
          his[i]->Fill(ds[i]);
          prof[i]->Fill(std::abs(tpPtr->eta()), std::abs(ds[i]));
        }
        if (tpCot < 0) {
          his[6]->Fill(dZ0);
          his[8]->Fill(dCot);
        } else {
          his[5]->Fill(dZ0);
          his[7]->Fill(dCot);
        }
      }
    }
  }

}  // namespace trklet

DEFINE_FWK_MODULE(trklet::AnalyzerKF);
