
    //cout << "Read event:"<<ev.eventnum()<<" Number of stubs="
    //	 <<ev.nstubs()<<endl;
    
    cleanTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->clean();
    }
//    for (unsigned int i=0;i<ndtcs;i++) {
//      dtcs[i].clean();
//    }
    cleanTimer.stop();

    bool hitlayer[6];
    int stublayer[6];
    int stublayer1[6][NSector];
    for (unsigned int ll=0;ll<6;ll++){
      hitlayer[ll]=false;
      stublayer[ll]=0;
      for (unsigned int jj=0;jj<NSector;jj++){
        stublayer1[ll][jj]=0;
      }
    }
	
    int stubcount[6][24*NSector];	
    for (unsigned int ll=0;ll<24*NSector;ll++){
      stubcount[0][ll]=0;
      stubcount[1][ll]=0;
      stubcount[2][ll]=0;
      stubcount[3][ll]=0;
      stubcount[4][ll]=0;
      stubcount[5][ll]=0;
    }    

    addStubTimer.start();
    for (int j=0;j<ev.nstubs();j++){

      L1TStub stub=ev.stub(j);
      //if (stub.layer()>999) {
      //	 cout << "Found stub in disk : "<<stub.module()<<" r= "<<stub.r()
	// <<" z= "<<stub.z()<<endl;
      //}

	//cout << "Stub: layer="<<stub.layer()+1
	 //      <<" pt="<<stub.pt()
	 //      <<" phi="<<stub.phi()
	 //      <<" r="<<stub.r()
	 //      <<" ladder="<<stub.ladder()
	 //      <<" module="<<stub.module()
	 //      <<endl;


      if (stub.layer()<7) {

        //cout << "Stub in layer : "<<stub.layer()+1<<endl;

	hitlayer[stub.layer()]=true;

	stub.lorentzcor(-40.0/10000.0);

        double phi=stub.phi();
        if (phi<0.0) phi+=two_pi;
        unsigned int iphi=24*NSector*phi/two_pi;
        assert(iphi<24*NSector);
	double max=115.0;
	if (stub.layer()==0) max=70.0;
        if (fabs(stub.z())<max) stubcount[stub.layer()][iphi]++;
	unsigned int isector=iphi/24;
	assert(isector<NSector);
	stublayer1[stub.layer()][isector]++;
        stublayer[stub.layer()]++;

      }

      double phi=stub.phi();
      if (phi<0.0) phi+=two_pi;
      unsigned int isector=NSector*phi/two_pi;
      assert(isector<NSector);

      

      for (unsigned int k=0;k<NSector;k++) {
        int diff=k-isector;
	int nSector=NSector;
        if (diff>nSector/2) diff-=NSector;
        if (diff<-nSector/2) diff+=NSector;
	if (abs(diff)>1) continue;
        sectors[k]->addStub(stub);	  
      }

      /*
      //cout << "stub layer : "<<stub.layer()<<endl;
      if (stub.layer()<10000) {

         int layer=stub.layer()+1;
	 int ladder=stub.ladder();  //-1
	 int module=stub.module();

         double dphi=two_pi/NSector;
         double phitmp=stub.phi();
         while (fabs(phitmp)>0.75*dphi) {
           if (phitmp>0.0) {
	     phitmp-=dphi;
           }
           else {
	     phitmp+=dphi;
           }
         }
         bool overlapregion=(fabs(phitmp)<dphi/6.0);
         bool overlaplayer=(layer%2==0);

         //cout << "Will add stub layer="<<layer<<" ladder="<<ladder
	 //     <<" module="<<module<<" "<<stub.phi()<<endl;

	 std::map<int, std::map<int, std::map<int, int> > >::const_iterator it1=modules.find(layer);
	 assert(it1!=modules.end());
	 std::map<int, std::map<int, int> >::const_iterator it2=it1->second.find(ladder);
	 assert(it2!=it1->second.end());
	 std::map<int, int>::const_iterator it3=it2->second.find(module);
         if (it3==it2->second.end()) {
	    cout << "Could not add stub "<<layer<<" "<<ladder<<" "
	        <<module<<" "<<stub.phi()<<endl;
         } else {
	   int dtc=it3->second;
	   //cout << "layer ladder module dtc :"<<layer<<" "<<ladder<<" "
	   //   <<module<<" "<<dtc<<endl;
	   std::pair<FPGAStub*,L1TStub*> stubpair(0,&stub);
	   int added=dtcs[dtc].addStub(stubpair);
	   if (overlapregion&&overlaplayer) {
             if (added!=2) {
   	        cout << "Warning: In overlap region add stub "<<layer<<" "
		     <<ladder<<" "
	             <<module<<" "<<stub.phi()<<"  to "<<added<<" links for dtc = "<<dtc<<endl;
             }
           } else {
             if (added!=1) {
   	        cout << "Warning: In non-overlap region add stub "<<layer<<" "
		     <<ladder<<" "
	             <<module<<" "<<stub.phi()<<"  to "<<added<<" links for dtc = "<<dtc<<endl;
             }
           }
  	 }
	 //cout << "Done add stub"<<endl;	
      }

      */

    }

/*
    if (writeDTCLinks) {
      //cout << "Will write DTC links"<<endl;
      static ofstream out("dtclinks.txt");
      for (unsigned int i=0;i<ndtcs;i++) {
        for (unsigned int j=0;j<dtcs[i].nLinks();j++) {
	   //cout << i << " " << j << " " << dtcs[i].link(j).nStubs() << endl;    
	   out << i << " " << j << " " << dtcs[i].link(j).nStubs() << endl;    
        }	 
      }
      //cout << "Done write DTC links"<<endl;
    }
*/

    if (writestubs || writestubs_in2) {
      for (unsigned int k=0;k<NSector;k++) {
        sectors[k]->writeInputStubs(first);
      }
    }

    if (writeHitEff) {
        static ofstream outhit("hiteff.txt");
    	outhit << hitlayer[0] << " " << hitlayer[1] << " "
                  << hitlayer[2] << " " << hitlayer[3] << " "	  
		  << hitlayer[4] << " " << hitlayer[5] << endl;
    }

    if (writeStubsLayer) {
      static ofstream out("stubslayer.txt");
      out <<stublayer[0]<<" "<<stublayer[1]<<" "<<stublayer[2]<<" "
          <<stublayer[3]<<" "<<stublayer[4]<<" "<<stublayer[5]<<endl;
    }     


    if (writeStubsLayerperSector) {
      static ofstream out("stubslayerpersector.txt");
      for(unsigned int jj=0;jj<NSector;jj++){
        out <<stublayer1[0][jj]<<" "<<stublayer1[1][jj]<<" "
	    <<stublayer1[2][jj]<<" "
            <<stublayer1[3][jj]<<" "<<stublayer1[4][jj]<<" "
            <<stublayer1[5][jj]<<endl; 
      }
    }     


    
    if (0) {
      static ofstream out("newvmoccupancy.txt");
      for (unsigned int ll=0;ll<24*NSector;ll++){
        out<<1<<" "<<stubcount[0][ll]<<endl;
        out<<2<<" "<<stubcount[1][ll]<<endl;
        out<<3<<" "<<stubcount[2][ll]<<endl;
        out<<4<<" "<<stubcount[3][ll]<<endl;
        out<<5<<" "<<stubcount[4][ll]<<endl;
        out<<6<<" "<<stubcount[5][ll]<<endl;
      }
    } 



    addStubTimer.stop();


    //Now start processing


    layerdiskRouterTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeLR();	 
      sectors[k]->executeDR();	
      if (writemem&&k<4) {
        sectors[k]->writeSL(first);	 
        sectors[k]->writeSD(first);	 
      }      
    }
    layerdiskRouterTimer.stop();


    VMRouterTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeVMR();	 
      if (writemem&&k<4) {
        sectors[k]->writeVMSTE(first);	 
        sectors[k]->writeVMSME(first);	 
        sectors[k]->writeAS(first);	 
      }      
    }
    VMRouterTimer.stop();

    TETimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeTE();	
      if(writemem && k<4){
        sectors[k]->writeSP(first);
      } 
    }
    TETimer.stop();


    TCTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeTC();	 
      if(writemem && k<4){
        sectors[k]->writeTPAR(first);
        sectors[k]->writeTPROJ(first);
      } 
    }
    TCTimer.stop();




    PTTimer.start();
    //Here we do the projections to the nearest neigbors  
    for (unsigned int k=0;k<NSector;k++) {
      unsigned int  plus=k+1;
      if (plus>=NSector) plus=0;
      int minus=k-1;
      if (minus<0) minus=NSector-1;
      sectors[k]->executePT(sectors[plus],sectors[minus]);	 
    }
    PTTimer.stop();



    PRTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executePR();	
      if(writemem && k<4){
        sectors[k]->writeVMPROJ(first);
      }
    }
    PRTimer.stop();

    
    METimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeME();	 
    }
    METimer.stop();


    MCTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeMC();
      if(writemem && k<4){
        sectors[k]->writeMC(first);
      }
    }
    MCTimer.stop();



    MTTimer.start();
    //Here we return the matches
    for (unsigned int k=0;k<NSector;k++) {
      unsigned int  plus=k+1;
      if (plus>=NSector) plus=0;
      int minus=k-1;
      if (minus<0) minus=NSector-1;
      sectors[k]->executeMT(sectors[plus],sectors[minus]);	 
    }
    MTTimer.stop();


    FTTimer.start();
    for (unsigned int k=0;k<NSector;k++) {
      sectors[k]->executeFT();	 
      if(writeifit&&(k==1||k==2||k==3)){
         sectors[k]->writeTF(first);
      }
    }
    FTTimer.stop();

    DuplicateTimer.start();
    bool match=false;
    for (unsigned int k=0;k<NSector;k++) {
      //cout << "FPGA.icc " << k << " " << tracks.size() << endl;
      sectors[k]->findduplicates(tracks);
      if (selectmu==1) {
	if (ev.nsimtracks()>0) {
	  match=match||sectors[k]->foundTrack(outres,simtrk);
	}
      }
    }
    


    //Tag adjacent sector duplicates
    for (int itrk=0; itrk<(int)tracks.size(); itrk++) {
        //if primary track is a duplicate, it cannot veto any...move on
        if(!tracks[itrk].duplicate()) {	  
	
            for(int jtrk=itrk+1; jtrk<(int)tracks.size(); jtrk++){
	            //if secondary track is a duplicate or not in an adjacent sector, it cannot veto any...move on
                if(!tracks[jtrk].duplicate() && ( abs(tracks[itrk].isector()-tracks[jtrk].isector())==1 || abs(tracks[itrk].isector()-tracks[jtrk].isector())==27)) {

                    //get stub information
		            int nShare=0;
		            std::map<int, int> stubsTrk1 = tracks[itrk].stubID();
		            std::map<int, int> stubsTrk2 = tracks[jtrk].stubID();

                    //count shared stubs
                    for(std::map<int, int>::iterator  st=stubsTrk1.begin(); st!=stubsTrk1.end(); st++) {
                        if( stubsTrk2.find(st->first) != stubsTrk2.end() ) {
                            if(st->second == stubsTrk2[st->first] && st->second != 63) { nShare++; }
                        }   	  
                    } //loop over stubs

	           	    //Decide if we should flag either of the tracks as a duplicate
			        if(stubsTrk1.size()>=stubsTrk2.size()) {
			            if( (((int)stubsTrk2.size()-nShare)<minIndepStubs) && !tracks[itrk].duplicate() ) tracks[jtrk].setDuplicate(true);
			        } else {
			            if( (((int)stubsTrk1.size()-nShare)<minIndepStubs) && !tracks[jtrk].duplicate() ) tracks[itrk].setDuplicate(true);
                    }
                } //if second track not a duplicate already
            } //loop over second track
        } //if first track not a duplicate already  	  
    } //loop over first track

    DuplicateTimer.stop();

    outeff << simtrk.pt()*simtrk.id()/fabs(simtrk.id())<<" "<<simtrk.eta()
	   <<" "<<simtrk.phi();
    if (match) {
      outeff << " 1"<<endl;
    } else {
      outeff << " 0"<<endl;
    }


