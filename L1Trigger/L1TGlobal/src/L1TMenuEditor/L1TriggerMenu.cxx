// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/pre.hxx>

#include "L1Trigger/L1TGlobal/src/L1TMenuEditor/L1TriggerMenu.hxx"

namespace l1t
{
  // DateTime
  // 


  // Label
  // 


  // Description
  // 


  // MenuName
  // 


  // ScalesKey
  // 


  // FirmwareVersion
  // 


  // History
  // 

  const History::revision_sequence& History::
  revision () const
  {
    return this->revision_;
  }

  History::revision_sequence& History::
  revision ()
  {
    return this->revision_;
  }

  void History::
  revision (const revision_sequence& s)
  {
    this->revision_ = s;
  }


  // Revision
  // 

  const Revision::author_type& Revision::
  author () const
  {
    return this->author_.get ();
  }

  Revision::author_type& Revision::
  author ()
  {
    return this->author_.get ();
  }

  void Revision::
  author (const author_type& x)
  {
    this->author_.set (x);
  }

  void Revision::
  author (::std::auto_ptr< author_type > x)
  {
    this->author_.set (x);
  }

  const Revision::datetime_type& Revision::
  datetime () const
  {
    return this->datetime_.get ();
  }

  Revision::datetime_type& Revision::
  datetime ()
  {
    return this->datetime_.get ();
  }

  void Revision::
  datetime (const datetime_type& x)
  {
    this->datetime_.set (x);
  }

  void Revision::
  datetime (::std::auto_ptr< datetime_type > x)
  {
    this->datetime_.set (x);
  }

  const Revision::username_optional& Revision::
  username () const
  {
    return this->username_;
  }

  Revision::username_optional& Revision::
  username ()
  {
    return this->username_;
  }

  void Revision::
  username (const username_type& x)
  {
    this->username_.set (x);
  }

  void Revision::
  username (const username_optional& x)
  {
    this->username_ = x;
  }

  void Revision::
  username (::std::auto_ptr< username_type > x)
  {
    this->username_.set (x);
  }

  const Revision::hostname_optional& Revision::
  hostname () const
  {
    return this->hostname_;
  }

  Revision::hostname_optional& Revision::
  hostname ()
  {
    return this->hostname_;
  }

  void Revision::
  hostname (const hostname_type& x)
  {
    this->hostname_.set (x);
  }

  void Revision::
  hostname (const hostname_optional& x)
  {
    this->hostname_ = x;
  }

  void Revision::
  hostname (::std::auto_ptr< hostname_type > x)
  {
    this->hostname_.set (x);
  }


  // EtComparison
  // 

  EtComparison::
  EtComparison (value v)
  : ::xml_schema::string (_xsd_EtComparison_literals_[v])
  {
  }

  EtComparison::
  EtComparison (const char* v)
  : ::xml_schema::string (v)
  {
  }

  EtComparison::
  EtComparison (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  EtComparison::
  EtComparison (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  EtComparison::
  EtComparison (const EtComparison& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  EtComparison& EtComparison::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_EtComparison_literals_[v]);

    return *this;
  }


  // RelativeBx
  // 


  // ConditionName
  // 


  // ConditionType
  // 

  ConditionType::
  ConditionType (value v)
  : ::xml_schema::string (_xsd_ConditionType_literals_[v])
  {
  }

  ConditionType::
  ConditionType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ConditionType::
  ConditionType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ConditionType::
  ConditionType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ConditionType::
  ConditionType (const ConditionType& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ConditionType& ConditionType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ConditionType_literals_[v]);

    return *this;
  }


  // CalorimeterObjectType
  // 

  CalorimeterObjectType::
  CalorimeterObjectType (value v)
  : ::xml_schema::string (_xsd_CalorimeterObjectType_literals_[v])
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const CalorimeterObjectType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  CalorimeterObjectType& CalorimeterObjectType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_CalorimeterObjectType_literals_[v]);

    return *this;
  }


  // EtThreshold
  // 


  // AlgorithmName
  // 


  // AlgorithmIndex
  // 


  // AlgorithmEquation
  // 


  // Meta
  // 

  const Meta::name_type& Meta::
  name () const
  {
    return this->name_.get ();
  }

  Meta::name_type& Meta::
  name ()
  {
    return this->name_.get ();
  }

  void Meta::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Meta::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Meta::scalesKey_type& Meta::
  scalesKey () const
  {
    return this->scalesKey_.get ();
  }

  Meta::scalesKey_type& Meta::
  scalesKey ()
  {
    return this->scalesKey_.get ();
  }

  void Meta::
  scalesKey (const scalesKey_type& x)
  {
    this->scalesKey_.set (x);
  }

  void Meta::
  scalesKey (::std::auto_ptr< scalesKey_type > x)
  {
    this->scalesKey_.set (x);
  }

  const Meta::firmwareVersion_type& Meta::
  firmwareVersion () const
  {
    return this->firmwareVersion_.get ();
  }

  Meta::firmwareVersion_type& Meta::
  firmwareVersion ()
  {
    return this->firmwareVersion_.get ();
  }

  void Meta::
  firmwareVersion (const firmwareVersion_type& x)
  {
    this->firmwareVersion_.set (x);
  }

  void Meta::
  firmwareVersion (::std::auto_ptr< firmwareVersion_type > x)
  {
    this->firmwareVersion_.set (x);
  }

  const Meta::description_type& Meta::
  description () const
  {
    return this->description_.get ();
  }

  Meta::description_type& Meta::
  description ()
  {
    return this->description_.get ();
  }

  void Meta::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Meta::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const Meta::history_type& Meta::
  history () const
  {
    return this->history_.get ();
  }

  Meta::history_type& Meta::
  history ()
  {
    return this->history_.get ();
  }

  void Meta::
  history (const history_type& x)
  {
    this->history_.set (x);
  }

  void Meta::
  history (::std::auto_ptr< history_type > x)
  {
    this->history_.set (x);
  }


  // ConditionList
  // 

  const ConditionList::condCalorimeter_sequence& ConditionList::
  condCalorimeter () const
  {
    return this->condCalorimeter_;
  }

  ConditionList::condCalorimeter_sequence& ConditionList::
  condCalorimeter ()
  {
    return this->condCalorimeter_;
  }

  void ConditionList::
  condCalorimeter (const condCalorimeter_sequence& s)
  {
    this->condCalorimeter_ = s;
  }

  const ConditionList::condMuon_sequence& ConditionList::
  condMuon () const
  {
    return this->condMuon_;
  }

  ConditionList::condMuon_sequence& ConditionList::
  condMuon ()
  {
    return this->condMuon_;
  }

  void ConditionList::
  condMuon (const condMuon_sequence& s)
  {
    this->condMuon_ = s;
  }

  const ConditionList::condEnergySums_sequence& ConditionList::
  condEnergySums () const
  {
    return this->condEnergySums_;
  }

  ConditionList::condEnergySums_sequence& ConditionList::
  condEnergySums ()
  {
    return this->condEnergySums_;
  }

  void ConditionList::
  condEnergySums (const condEnergySums_sequence& s)
  {
    this->condEnergySums_ = s;
  }

  const ConditionList::condCorrelation_sequence& ConditionList::
  condCorrelation () const
  {
    return this->condCorrelation_;
  }

  ConditionList::condCorrelation_sequence& ConditionList::
  condCorrelation ()
  {
    return this->condCorrelation_;
  }

  void ConditionList::
  condCorrelation (const condCorrelation_sequence& s)
  {
    this->condCorrelation_ = s;
  }

  const ConditionList::condInvariantMass_sequence& ConditionList::
  condInvariantMass () const
  {
    return this->condInvariantMass_;
  }

  ConditionList::condInvariantMass_sequence& ConditionList::
  condInvariantMass ()
  {
    return this->condInvariantMass_;
  }

  void ConditionList::
  condInvariantMass (const condInvariantMass_sequence& s)
  {
    this->condInvariantMass_ = s;
  }

  const ConditionList::condDeltaR_sequence& ConditionList::
  condDeltaR () const
  {
    return this->condDeltaR_;
  }

  ConditionList::condDeltaR_sequence& ConditionList::
  condDeltaR ()
  {
    return this->condDeltaR_;
  }

  void ConditionList::
  condDeltaR (const condDeltaR_sequence& s)
  {
    this->condDeltaR_ = s;
  }


  // Condition
  // 

  const Condition::name_type& Condition::
  name () const
  {
    return this->name_.get ();
  }

  Condition::name_type& Condition::
  name ()
  {
    return this->name_.get ();
  }

  void Condition::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Condition::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Condition::description_type& Condition::
  description () const
  {
    return this->description_.get ();
  }

  Condition::description_type& Condition::
  description ()
  {
    return this->description_.get ();
  }

  void Condition::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Condition::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const Condition::locked_type& Condition::
  locked () const
  {
    return this->locked_.get ();
  }

  Condition::locked_type& Condition::
  locked ()
  {
    return this->locked_.get ();
  }

  void Condition::
  locked (const locked_type& x)
  {
    this->locked_.set (x);
  }


  // Window
  // 

  const Window::lower_type& Window::
  lower () const
  {
    return this->lower_.get ();
  }

  Window::lower_type& Window::
  lower ()
  {
    return this->lower_.get ();
  }

  void Window::
  lower (const lower_type& x)
  {
    this->lower_.set (x);
  }

  const Window::upper_type& Window::
  upper () const
  {
    return this->upper_.get ();
  }

  Window::upper_type& Window::
  upper ()
  {
    return this->upper_.get ();
  }

  void Window::
  upper (const upper_type& x)
  {
    this->upper_.set (x);
  }


  // DeltaRequirement
  // 

  const DeltaRequirement::deltaPhiRange_type& DeltaRequirement::
  deltaPhiRange () const
  {
    return this->deltaPhiRange_.get ();
  }

  DeltaRequirement::deltaPhiRange_type& DeltaRequirement::
  deltaPhiRange ()
  {
    return this->deltaPhiRange_.get ();
  }

  void DeltaRequirement::
  deltaPhiRange (const deltaPhiRange_type& x)
  {
    this->deltaPhiRange_.set (x);
  }

  void DeltaRequirement::
  deltaPhiRange (::std::auto_ptr< deltaPhiRange_type > x)
  {
    this->deltaPhiRange_.set (x);
  }

  const DeltaRequirement::deltaEtaRange_type& DeltaRequirement::
  deltaEtaRange () const
  {
    return this->deltaEtaRange_.get ();
  }

  DeltaRequirement::deltaEtaRange_type& DeltaRequirement::
  deltaEtaRange ()
  {
    return this->deltaEtaRange_.get ();
  }

  void DeltaRequirement::
  deltaEtaRange (const deltaEtaRange_type& x)
  {
    this->deltaEtaRange_.set (x);
  }

  void DeltaRequirement::
  deltaEtaRange (::std::auto_ptr< deltaEtaRange_type > x)
  {
    this->deltaEtaRange_.set (x);
  }


  // CalorimeterObjectRequirement
  // 

  const CalorimeterObjectRequirement::etThreshold_type& CalorimeterObjectRequirement::
  etThreshold () const
  {
    return this->etThreshold_.get ();
  }

  CalorimeterObjectRequirement::etThreshold_type& CalorimeterObjectRequirement::
  etThreshold ()
  {
    return this->etThreshold_.get ();
  }

  void CalorimeterObjectRequirement::
  etThreshold (const etThreshold_type& x)
  {
    this->etThreshold_.set (x);
  }

  void CalorimeterObjectRequirement::
  etThreshold (::std::auto_ptr< etThreshold_type > x)
  {
    this->etThreshold_.set (x);
  }

  const CalorimeterObjectRequirement::phiWindow_sequence& CalorimeterObjectRequirement::
  phiWindow () const
  {
    return this->phiWindow_;
  }

  CalorimeterObjectRequirement::phiWindow_sequence& CalorimeterObjectRequirement::
  phiWindow ()
  {
    return this->phiWindow_;
  }

  void CalorimeterObjectRequirement::
  phiWindow (const phiWindow_sequence& s)
  {
    this->phiWindow_ = s;
  }

  const CalorimeterObjectRequirement::etaWindow_sequence& CalorimeterObjectRequirement::
  etaWindow () const
  {
    return this->etaWindow_;
  }

  CalorimeterObjectRequirement::etaWindow_sequence& CalorimeterObjectRequirement::
  etaWindow ()
  {
    return this->etaWindow_;
  }

  void CalorimeterObjectRequirement::
  etaWindow (const etaWindow_sequence& s)
  {
    this->etaWindow_ = s;
  }


  // CalorimeterObjectRequirements
  // 

  const CalorimeterObjectRequirements::objectRequirement_sequence& CalorimeterObjectRequirements::
  objectRequirement () const
  {
    return this->objectRequirement_;
  }

  CalorimeterObjectRequirements::objectRequirement_sequence& CalorimeterObjectRequirements::
  objectRequirement ()
  {
    return this->objectRequirement_;
  }

  void CalorimeterObjectRequirements::
  objectRequirement (const objectRequirement_sequence& s)
  {
    this->objectRequirement_ = s;
  }


  // CalorimeterCondition
  // 

  const CalorimeterCondition::type_type& CalorimeterCondition::
  type () const
  {
    return this->type_.get ();
  }

  CalorimeterCondition::type_type& CalorimeterCondition::
  type ()
  {
    return this->type_.get ();
  }

  void CalorimeterCondition::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void CalorimeterCondition::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const CalorimeterCondition::etComparison_type& CalorimeterCondition::
  etComparison () const
  {
    return this->etComparison_.get ();
  }

  CalorimeterCondition::etComparison_type& CalorimeterCondition::
  etComparison ()
  {
    return this->etComparison_.get ();
  }

  void CalorimeterCondition::
  etComparison (const etComparison_type& x)
  {
    this->etComparison_.set (x);
  }

  void CalorimeterCondition::
  etComparison (::std::auto_ptr< etComparison_type > x)
  {
    this->etComparison_.set (x);
  }

  const CalorimeterCondition::objectType_type& CalorimeterCondition::
  objectType () const
  {
    return this->objectType_.get ();
  }

  CalorimeterCondition::objectType_type& CalorimeterCondition::
  objectType ()
  {
    return this->objectType_.get ();
  }

  void CalorimeterCondition::
  objectType (const objectType_type& x)
  {
    this->objectType_.set (x);
  }

  void CalorimeterCondition::
  objectType (::std::auto_ptr< objectType_type > x)
  {
    this->objectType_.set (x);
  }

  const CalorimeterCondition::objectRequirements_type& CalorimeterCondition::
  objectRequirements () const
  {
    return this->objectRequirements_.get ();
  }

  CalorimeterCondition::objectRequirements_type& CalorimeterCondition::
  objectRequirements ()
  {
    return this->objectRequirements_.get ();
  }

  void CalorimeterCondition::
  objectRequirements (const objectRequirements_type& x)
  {
    this->objectRequirements_.set (x);
  }

  void CalorimeterCondition::
  objectRequirements (::std::auto_ptr< objectRequirements_type > x)
  {
    this->objectRequirements_.set (x);
  }

  const CalorimeterCondition::deltaRequirement_optional& CalorimeterCondition::
  deltaRequirement () const
  {
    return this->deltaRequirement_;
  }

  CalorimeterCondition::deltaRequirement_optional& CalorimeterCondition::
  deltaRequirement ()
  {
    return this->deltaRequirement_;
  }

  void CalorimeterCondition::
  deltaRequirement (const deltaRequirement_type& x)
  {
    this->deltaRequirement_.set (x);
  }

  void CalorimeterCondition::
  deltaRequirement (const deltaRequirement_optional& x)
  {
    this->deltaRequirement_ = x;
  }

  void CalorimeterCondition::
  deltaRequirement (::std::auto_ptr< deltaRequirement_type > x)
  {
    this->deltaRequirement_.set (x);
  }

  const CalorimeterCondition::relativeBx_type& CalorimeterCondition::
  relativeBx () const
  {
    return this->relativeBx_.get ();
  }

  CalorimeterCondition::relativeBx_type& CalorimeterCondition::
  relativeBx ()
  {
    return this->relativeBx_.get ();
  }

  void CalorimeterCondition::
  relativeBx (const relativeBx_type& x)
  {
    this->relativeBx_.set (x);
  }

  void CalorimeterCondition::
  relativeBx (::std::auto_ptr< relativeBx_type > x)
  {
    this->relativeBx_.set (x);
  }


  // MuonCondition
  // 

  const MuonCondition::type_type& MuonCondition::
  type () const
  {
    return this->type_.get ();
  }

  MuonCondition::type_type& MuonCondition::
  type ()
  {
    return this->type_.get ();
  }

  void MuonCondition::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void MuonCondition::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const MuonCondition::etComparison_type& MuonCondition::
  etComparison () const
  {
    return this->etComparison_.get ();
  }

  MuonCondition::etComparison_type& MuonCondition::
  etComparison ()
  {
    return this->etComparison_.get ();
  }

  void MuonCondition::
  etComparison (const etComparison_type& x)
  {
    this->etComparison_.set (x);
  }

  void MuonCondition::
  etComparison (::std::auto_ptr< etComparison_type > x)
  {
    this->etComparison_.set (x);
  }

  const MuonCondition::relativeBx_type& MuonCondition::
  relativeBx () const
  {
    return this->relativeBx_.get ();
  }

  MuonCondition::relativeBx_type& MuonCondition::
  relativeBx ()
  {
    return this->relativeBx_.get ();
  }

  void MuonCondition::
  relativeBx (const relativeBx_type& x)
  {
    this->relativeBx_.set (x);
  }

  void MuonCondition::
  relativeBx (::std::auto_ptr< relativeBx_type > x)
  {
    this->relativeBx_.set (x);
  }


  // EnergySumsCondition
  // 


  // CorrelationCondition
  // 


  // InvariantMassCondition
  // 


  // DeltaRCondition
  // 


  // Algorithm
  // 

  const Algorithm::name_type& Algorithm::
  name () const
  {
    return this->name_.get ();
  }

  Algorithm::name_type& Algorithm::
  name ()
  {
    return this->name_.get ();
  }

  void Algorithm::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Algorithm::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Algorithm::index_type& Algorithm::
  index () const
  {
    return this->index_.get ();
  }

  Algorithm::index_type& Algorithm::
  index ()
  {
    return this->index_.get ();
  }

  void Algorithm::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void Algorithm::
  index (::std::auto_ptr< index_type > x)
  {
    this->index_.set (x);
  }

  const Algorithm::equation_type& Algorithm::
  equation () const
  {
    return this->equation_.get ();
  }

  Algorithm::equation_type& Algorithm::
  equation ()
  {
    return this->equation_.get ();
  }

  void Algorithm::
  equation (const equation_type& x)
  {
    this->equation_.set (x);
  }

  void Algorithm::
  equation (::std::auto_ptr< equation_type > x)
  {
    this->equation_.set (x);
  }

  const Algorithm::description_type& Algorithm::
  description () const
  {
    return this->description_.get ();
  }

  Algorithm::description_type& Algorithm::
  description ()
  {
    return this->description_.get ();
  }

  void Algorithm::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Algorithm::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const Algorithm::locked_type& Algorithm::
  locked () const
  {
    return this->locked_.get ();
  }

  Algorithm::locked_type& Algorithm::
  locked ()
  {
    return this->locked_.get ();
  }

  void Algorithm::
  locked (const locked_type& x)
  {
    this->locked_.set (x);
  }


  // AlgorithmList
  // 

  const AlgorithmList::algorithm_sequence& AlgorithmList::
  algorithm () const
  {
    return this->algorithm_;
  }

  AlgorithmList::algorithm_sequence& AlgorithmList::
  algorithm ()
  {
    return this->algorithm_;
  }

  void AlgorithmList::
  algorithm (const algorithm_sequence& s)
  {
    this->algorithm_ = s;
  }


  // L1TriggerMenu
  // 

  const L1TriggerMenu::meta_type& L1TriggerMenu::
  meta () const
  {
    return this->meta_.get ();
  }

  L1TriggerMenu::meta_type& L1TriggerMenu::
  meta ()
  {
    return this->meta_.get ();
  }

  void L1TriggerMenu::
  meta (const meta_type& x)
  {
    this->meta_.set (x);
  }

  void L1TriggerMenu::
  meta (::std::auto_ptr< meta_type > x)
  {
    this->meta_.set (x);
  }

  const L1TriggerMenu::conditions_type& L1TriggerMenu::
  conditions () const
  {
    return this->conditions_.get ();
  }

  L1TriggerMenu::conditions_type& L1TriggerMenu::
  conditions ()
  {
    return this->conditions_.get ();
  }

  void L1TriggerMenu::
  conditions (const conditions_type& x)
  {
    this->conditions_.set (x);
  }

  void L1TriggerMenu::
  conditions (::std::auto_ptr< conditions_type > x)
  {
    this->conditions_.set (x);
  }

  const L1TriggerMenu::algorithms_type& L1TriggerMenu::
  algorithms () const
  {
    return this->algorithms_.get ();
  }

  L1TriggerMenu::algorithms_type& L1TriggerMenu::
  algorithms ()
  {
    return this->algorithms_.get ();
  }

  void L1TriggerMenu::
  algorithms (const algorithms_type& x)
  {
    this->algorithms_.set (x);
  }

  void L1TriggerMenu::
  algorithms (::std::auto_ptr< algorithms_type > x)
  {
    this->algorithms_.set (x);
  }

  const L1TriggerMenu::version_type& L1TriggerMenu::
  version () const
  {
    return this->version_.get ();
  }

  const L1TriggerMenu::version_type& L1TriggerMenu::
  version_default_value ()
  {
    return version_default_value_;
  }
}

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/xml/dom/parsing-source.hxx>

namespace l1t
{
  // DateTime
  //

  DateTime::
  DateTime (const ::xml_schema::date_time& _xsd_date_time_base)
  : ::xml_schema::date_time (_xsd_date_time_base)
  {
  }

  DateTime::
  DateTime (const DateTime& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (x, f, c)
  {
  }

  DateTime::
  DateTime (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (e, f, c)
  {
  }

  DateTime::
  DateTime (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (a, f, c)
  {
  }

  DateTime::
  DateTime (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (s, e, f, c)
  {
  }

  DateTime* DateTime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DateTime (*this, f, c);
  }

  DateTime::
  ~DateTime ()
  {
  }

  // Label
  //

  Label::
  Label ()
  : ::xml_schema::string ()
  {
  }

  Label::
  Label (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Label::
  Label (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Label::
  Label (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Label::
  Label (const Label& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Label::
  Label (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Label::
  Label (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Label::
  Label (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Label* Label::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Label (*this, f, c);
  }

  Label::
  ~Label ()
  {
  }

  // Description
  //

  Description::
  Description ()
  : ::xml_schema::string ()
  {
  }

  Description::
  Description (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Description::
  Description (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Description::
  Description (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Description::
  Description (const Description& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Description::
  Description (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Description::
  Description (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Description::
  Description (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Description* Description::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Description (*this, f, c);
  }

  Description::
  ~Description ()
  {
  }

  // MenuName
  //

  MenuName::
  MenuName ()
  : ::xml_schema::string ()
  {
  }

  MenuName::
  MenuName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const MenuName& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  MenuName::
  MenuName (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  MenuName::
  MenuName (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  MenuName::
  MenuName (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  MenuName* MenuName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MenuName (*this, f, c);
  }

  MenuName::
  ~MenuName ()
  {
  }

  // ScalesKey
  //

  ScalesKey::
  ScalesKey ()
  : ::xml_schema::string ()
  {
  }

  ScalesKey::
  ScalesKey (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ScalesKey::
  ScalesKey (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ScalesKey::
  ScalesKey (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ScalesKey::
  ScalesKey (const ScalesKey& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  ScalesKey::
  ScalesKey (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ScalesKey::
  ScalesKey (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ScalesKey::
  ScalesKey (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ScalesKey* ScalesKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScalesKey (*this, f, c);
  }

  ScalesKey::
  ~ScalesKey ()
  {
  }

  // FirmwareVersion
  //

  FirmwareVersion::
  FirmwareVersion (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const FirmwareVersion& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  FirmwareVersion* FirmwareVersion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FirmwareVersion (*this, f, c);
  }

  FirmwareVersion::
  ~FirmwareVersion ()
  {
  }

  // History
  //

  History::
  History ()
  : ::xml_schema::type (),
    revision_ (::xml_schema::flags (), this)
  {
  }

  History::
  History (const History& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    revision_ (x.revision_, f, this)
  {
  }

  History::
  History (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    revision_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void History::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // revision
      //
      if (n.name () == "revision" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< revision_type > r (
          revision_traits::create (i, f, this));

        this->revision_.push_back (r);
        continue;
      }

      break;
    }
  }

  History* History::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class History (*this, f, c);
  }

  History::
  ~History ()
  {
  }

  // Revision
  //

  Revision::
  Revision (const author_type& author,
            const datetime_type& datetime)
  : ::xml_schema::type (),
    author_ (author, ::xml_schema::flags (), this),
    datetime_ (datetime, ::xml_schema::flags (), this),
    username_ (::xml_schema::flags (), this),
    hostname_ (::xml_schema::flags (), this)
  {
  }

  Revision::
  Revision (const Revision& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    author_ (x.author_, f, this),
    datetime_ (x.datetime_, f, this),
    username_ (x.username_, f, this),
    hostname_ (x.hostname_, f, this)
  {
  }

  Revision::
  Revision (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    author_ (f, this),
    datetime_ (f, this),
    username_ (f, this),
    hostname_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Revision::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // author
      //
      if (n.name () == "author" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< author_type > r (
          author_traits::create (i, f, this));

        if (!author_.present ())
        {
          this->author_.set (r);
          continue;
        }
      }

      // datetime
      //
      if (n.name () == "datetime" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< datetime_type > r (
          datetime_traits::create (i, f, this));

        if (!datetime_.present ())
        {
          this->datetime_.set (r);
          continue;
        }
      }

      break;
    }

    if (!author_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "author",
        "http://www.cern.ch/l1t");
    }

    if (!datetime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "datetime",
        "http://www.cern.ch/l1t");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "username" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< username_type > r (
          username_traits::create (i, f, this));

        this->username_.set (r);
        continue;
      }

      if (n.name () == "hostname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< hostname_type > r (
          hostname_traits::create (i, f, this));

        this->hostname_.set (r);
        continue;
      }
    }
  }

  Revision* Revision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Revision (*this, f, c);
  }

  Revision::
  ~Revision ()
  {
  }

  // EtComparison
  //

  EtComparison::
  EtComparison (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_EtComparison_convert ();
  }

  EtComparison::
  EtComparison (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_EtComparison_convert ();
  }

  EtComparison::
  EtComparison (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_EtComparison_convert ();
  }

  EtComparison* EtComparison::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EtComparison (*this, f, c);
  }

  EtComparison::value EtComparison::
  _xsd_EtComparison_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EtComparison_literals_);
    const value* i (::std::lower_bound (
                      _xsd_EtComparison_indexes_,
                      _xsd_EtComparison_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_EtComparison_indexes_ + 2 || _xsd_EtComparison_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const EtComparison::
  _xsd_EtComparison_literals_[2] =
  {
    "eq",
    "ge"
  };

  const EtComparison::value EtComparison::
  _xsd_EtComparison_indexes_[2] =
  {
    ::l1t::EtComparison::eq,
    ::l1t::EtComparison::ge
  };

  // RelativeBx
  //

  RelativeBx::
  RelativeBx (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  RelativeBx::
  RelativeBx (const RelativeBx& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  RelativeBx* RelativeBx::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelativeBx (*this, f, c);
  }

  RelativeBx::
  ~RelativeBx ()
  {
  }

  // ConditionName
  //

  ConditionName::
  ConditionName ()
  : ::xml_schema::string ()
  {
  }

  ConditionName::
  ConditionName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ConditionName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ConditionName* ConditionName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionName (*this, f, c);
  }

  ConditionName::
  ~ConditionName ()
  {
  }

  // ConditionType
  //

  ConditionType::
  ConditionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ConditionType_convert ();
  }

  ConditionType::
  ConditionType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ConditionType_convert ();
  }

  ConditionType::
  ConditionType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ConditionType_convert ();
  }

  ConditionType* ConditionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionType (*this, f, c);
  }

  ConditionType::value ConditionType::
  _xsd_ConditionType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ConditionType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ConditionType_indexes_,
                      _xsd_ConditionType_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_ConditionType_indexes_ + 5 || _xsd_ConditionType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ConditionType::
  _xsd_ConditionType_literals_[5] =
  {
    "single",
    "double",
    "triple",
    "quad",
    "double_wsc"
  };

  const ConditionType::value ConditionType::
  _xsd_ConditionType_indexes_[5] =
  {
    ::l1t::ConditionType::double_,
    ::l1t::ConditionType::double_wsc,
    ::l1t::ConditionType::quad,
    ::l1t::ConditionType::single,
    ::l1t::ConditionType::triple
  };

  // CalorimeterObjectType
  //

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType* CalorimeterObjectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectType (*this, f, c);
  }

  CalorimeterObjectType::value CalorimeterObjectType::
  _xsd_CalorimeterObjectType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalorimeterObjectType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CalorimeterObjectType_indexes_,
                      _xsd_CalorimeterObjectType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CalorimeterObjectType_indexes_ + 3 || _xsd_CalorimeterObjectType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalorimeterObjectType::
  _xsd_CalorimeterObjectType_literals_[3] =
  {
    "eg",
    "jet",
    "tau"
  };

  const CalorimeterObjectType::value CalorimeterObjectType::
  _xsd_CalorimeterObjectType_indexes_[3] =
  {
    ::l1t::CalorimeterObjectType::eg,
    ::l1t::CalorimeterObjectType::jet,
    ::l1t::CalorimeterObjectType::tau
  };

  // EtThreshold
  //

  EtThreshold::
  EtThreshold (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  EtThreshold::
  EtThreshold (const EtThreshold& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  EtThreshold::
  EtThreshold (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  EtThreshold::
  EtThreshold (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  EtThreshold::
  EtThreshold (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  EtThreshold* EtThreshold::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EtThreshold (*this, f, c);
  }

  EtThreshold::
  ~EtThreshold ()
  {
  }

  // AlgorithmName
  //

  AlgorithmName::
  AlgorithmName ()
  : ::xml_schema::string ()
  {
  }

  AlgorithmName::
  AlgorithmName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const AlgorithmName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  AlgorithmName* AlgorithmName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmName (*this, f, c);
  }

  AlgorithmName::
  ~AlgorithmName ()
  {
  }

  // AlgorithmIndex
  //

  AlgorithmIndex::
  AlgorithmIndex (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const AlgorithmIndex& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  AlgorithmIndex* AlgorithmIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmIndex (*this, f, c);
  }

  AlgorithmIndex::
  ~AlgorithmIndex ()
  {
  }

  // AlgorithmEquation
  //

  AlgorithmEquation::
  AlgorithmEquation ()
  : ::xml_schema::string ()
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const AlgorithmEquation& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  AlgorithmEquation* AlgorithmEquation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmEquation (*this, f, c);
  }

  AlgorithmEquation::
  ~AlgorithmEquation ()
  {
  }

  // Meta
  //

  Meta::
  Meta (const name_type& name,
        const scalesKey_type& scalesKey,
        const firmwareVersion_type& firmwareVersion,
        const description_type& description,
        const history_type& history)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    scalesKey_ (scalesKey, ::xml_schema::flags (), this),
    firmwareVersion_ (firmwareVersion, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    history_ (history, ::xml_schema::flags (), this)
  {
  }

  Meta::
  Meta (const name_type& name,
        const scalesKey_type& scalesKey,
        const firmwareVersion_type& firmwareVersion,
        const description_type& description,
        ::std::auto_ptr< history_type >& history)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    scalesKey_ (scalesKey, ::xml_schema::flags (), this),
    firmwareVersion_ (firmwareVersion, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    history_ (history, ::xml_schema::flags (), this)
  {
  }

  Meta::
  Meta (const Meta& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    scalesKey_ (x.scalesKey_, f, this),
    firmwareVersion_ (x.firmwareVersion_, f, this),
    description_ (x.description_, f, this),
    history_ (x.history_, f, this)
  {
  }

  Meta::
  Meta (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    scalesKey_ (f, this),
    firmwareVersion_ (f, this),
    description_ (f, this),
    history_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Meta::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // scalesKey
      //
      if (n.name () == "scalesKey" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< scalesKey_type > r (
          scalesKey_traits::create (i, f, this));

        if (!scalesKey_.present ())
        {
          this->scalesKey_.set (r);
          continue;
        }
      }

      // firmwareVersion
      //
      if (n.name () == "firmwareVersion" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< firmwareVersion_type > r (
          firmwareVersion_traits::create (i, f, this));

        if (!firmwareVersion_.present ())
        {
          this->firmwareVersion_.set (r);
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // history
      //
      if (n.name () == "history" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< history_type > r (
          history_traits::create (i, f, this));

        if (!history_.present ())
        {
          this->history_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t");
    }

    if (!scalesKey_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scalesKey",
        "http://www.cern.ch/l1t");
    }

    if (!firmwareVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "firmwareVersion",
        "http://www.cern.ch/l1t");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://www.cern.ch/l1t");
    }

    if (!history_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "history",
        "http://www.cern.ch/l1t");
    }
  }

  Meta* Meta::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Meta (*this, f, c);
  }

  Meta::
  ~Meta ()
  {
  }

  // ConditionList
  //

  ConditionList::
  ConditionList ()
  : ::xml_schema::type (),
    condCalorimeter_ (::xml_schema::flags (), this),
    condMuon_ (::xml_schema::flags (), this),
    condEnergySums_ (::xml_schema::flags (), this),
    condCorrelation_ (::xml_schema::flags (), this),
    condInvariantMass_ (::xml_schema::flags (), this),
    condDeltaR_ (::xml_schema::flags (), this)
  {
  }

  ConditionList::
  ConditionList (const ConditionList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    condCalorimeter_ (x.condCalorimeter_, f, this),
    condMuon_ (x.condMuon_, f, this),
    condEnergySums_ (x.condEnergySums_, f, this),
    condCorrelation_ (x.condCorrelation_, f, this),
    condInvariantMass_ (x.condInvariantMass_, f, this),
    condDeltaR_ (x.condDeltaR_, f, this)
  {
  }

  ConditionList::
  ConditionList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    condCalorimeter_ (f, this),
    condMuon_ (f, this),
    condEnergySums_ (f, this),
    condCorrelation_ (f, this),
    condInvariantMass_ (f, this),
    condDeltaR_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConditionList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condCalorimeter
      //
      if (n.name () == "condCalorimeter" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condCalorimeter_type > r (
          condCalorimeter_traits::create (i, f, this));

        this->condCalorimeter_.push_back (r);
        continue;
      }

      // condMuon
      //
      if (n.name () == "condMuon" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condMuon_type > r (
          condMuon_traits::create (i, f, this));

        this->condMuon_.push_back (r);
        continue;
      }

      // condEnergySums
      //
      if (n.name () == "condEnergySums" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condEnergySums_type > r (
          condEnergySums_traits::create (i, f, this));

        this->condEnergySums_.push_back (r);
        continue;
      }

      // condCorrelation
      //
      if (n.name () == "condCorrelation" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condCorrelation_type > r (
          condCorrelation_traits::create (i, f, this));

        this->condCorrelation_.push_back (r);
        continue;
      }

      // condInvariantMass
      //
      if (n.name () == "condInvariantMass" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condInvariantMass_type > r (
          condInvariantMass_traits::create (i, f, this));

        this->condInvariantMass_.push_back (r);
        continue;
      }

      // condDeltaR
      //
      if (n.name () == "condDeltaR" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condDeltaR_type > r (
          condDeltaR_traits::create (i, f, this));

        this->condDeltaR_.push_back (r);
        continue;
      }

      break;
    }
  }

  ConditionList* ConditionList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionList (*this, f, c);
  }

  ConditionList::
  ~ConditionList ()
  {
  }

  // Condition
  //

  Condition::
  Condition (const name_type& name,
             const description_type& description,
             const locked_type& locked)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this)
  {
  }

  Condition::
  Condition (const Condition& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    description_ (x.description_, f, this),
    locked_ (x.locked_, f, this)
  {
  }

  Condition::
  Condition (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    description_ (f, this),
    locked_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Condition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // locked
      //
      if (n.name () == "locked" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!locked_.present ())
        {
          this->locked_.set (locked_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://www.cern.ch/l1t");
    }

    if (!locked_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locked",
        "http://www.cern.ch/l1t");
    }
  }

  Condition* Condition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Condition (*this, f, c);
  }

  Condition::
  ~Condition ()
  {
  }

  // Window
  //

  Window::
  Window (const lower_type& lower,
          const upper_type& upper)
  : ::xml_schema::type (),
    lower_ (lower, ::xml_schema::flags (), this),
    upper_ (upper, ::xml_schema::flags (), this)
  {
  }

  Window::
  Window (const Window& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lower_ (x.lower_, f, this),
    upper_ (x.upper_, f, this)
  {
  }

  Window::
  Window (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lower_ (f, this),
    upper_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Window::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lower
      //
      if (n.name () == "lower" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!lower_.present ())
        {
          this->lower_.set (lower_traits::create (i, f, this));
          continue;
        }
      }

      // upper
      //
      if (n.name () == "upper" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!upper_.present ())
        {
          this->upper_.set (upper_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!lower_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lower",
        "http://www.cern.ch/l1t");
    }

    if (!upper_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "upper",
        "http://www.cern.ch/l1t");
    }
  }

  Window* Window::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Window (*this, f, c);
  }

  Window::
  ~Window ()
  {
  }

  // DeltaRequirement
  //

  DeltaRequirement::
  DeltaRequirement (const deltaPhiRange_type& deltaPhiRange,
                    const deltaEtaRange_type& deltaEtaRange)
  : ::xml_schema::type (),
    deltaPhiRange_ (deltaPhiRange, ::xml_schema::flags (), this),
    deltaEtaRange_ (deltaEtaRange, ::xml_schema::flags (), this)
  {
  }

  DeltaRequirement::
  DeltaRequirement (::std::auto_ptr< deltaPhiRange_type >& deltaPhiRange,
                    ::std::auto_ptr< deltaEtaRange_type >& deltaEtaRange)
  : ::xml_schema::type (),
    deltaPhiRange_ (deltaPhiRange, ::xml_schema::flags (), this),
    deltaEtaRange_ (deltaEtaRange, ::xml_schema::flags (), this)
  {
  }

  DeltaRequirement::
  DeltaRequirement (const DeltaRequirement& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    deltaPhiRange_ (x.deltaPhiRange_, f, this),
    deltaEtaRange_ (x.deltaEtaRange_, f, this)
  {
  }

  DeltaRequirement::
  DeltaRequirement (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    deltaPhiRange_ (f, this),
    deltaEtaRange_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeltaRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deltaPhiRange
      //
      if (n.name () == "deltaPhiRange" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< deltaPhiRange_type > r (
          deltaPhiRange_traits::create (i, f, this));

        if (!deltaPhiRange_.present ())
        {
          this->deltaPhiRange_.set (r);
          continue;
        }
      }

      // deltaEtaRange
      //
      if (n.name () == "deltaEtaRange" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< deltaEtaRange_type > r (
          deltaEtaRange_traits::create (i, f, this));

        if (!deltaEtaRange_.present ())
        {
          this->deltaEtaRange_.set (r);
          continue;
        }
      }

      break;
    }

    if (!deltaPhiRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deltaPhiRange",
        "http://www.cern.ch/l1t");
    }

    if (!deltaEtaRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deltaEtaRange",
        "http://www.cern.ch/l1t");
    }
  }

  DeltaRequirement* DeltaRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeltaRequirement (*this, f, c);
  }

  DeltaRequirement::
  ~DeltaRequirement ()
  {
  }

  // CalorimeterObjectRequirement
  //

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const etThreshold_type& etThreshold)
  : ::xml_schema::type (),
    etThreshold_ (etThreshold, ::xml_schema::flags (), this),
    phiWindow_ (::xml_schema::flags (), this),
    etaWindow_ (::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const CalorimeterObjectRequirement& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    etThreshold_ (x.etThreshold_, f, this),
    phiWindow_ (x.phiWindow_, f, this),
    etaWindow_ (x.etaWindow_, f, this)
  {
  }

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    etThreshold_ (f, this),
    phiWindow_ (f, this),
    etaWindow_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterObjectRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // etThreshold
      //
      if (n.name () == "etThreshold" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etThreshold_type > r (
          etThreshold_traits::create (i, f, this));

        if (!etThreshold_.present ())
        {
          this->etThreshold_.set (r);
          continue;
        }
      }

      // phiWindow
      //
      if (n.name () == "phiWindow" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< phiWindow_type > r (
          phiWindow_traits::create (i, f, this));

        this->phiWindow_.push_back (r);
        continue;
      }

      // etaWindow
      //
      if (n.name () == "etaWindow" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etaWindow_type > r (
          etaWindow_traits::create (i, f, this));

        this->etaWindow_.push_back (r);
        continue;
      }

      break;
    }

    if (!etThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etThreshold",
        "http://www.cern.ch/l1t");
    }
  }

  CalorimeterObjectRequirement* CalorimeterObjectRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectRequirement (*this, f, c);
  }

  CalorimeterObjectRequirement::
  ~CalorimeterObjectRequirement ()
  {
  }

  // CalorimeterObjectRequirements
  //

  CalorimeterObjectRequirements::
  CalorimeterObjectRequirements ()
  : ::xml_schema::type (),
    objectRequirement_ (::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectRequirements::
  CalorimeterObjectRequirements (const CalorimeterObjectRequirements& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    objectRequirement_ (x.objectRequirement_, f, this)
  {
  }

  CalorimeterObjectRequirements::
  CalorimeterObjectRequirements (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    objectRequirement_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterObjectRequirements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // objectRequirement
      //
      if (n.name () == "objectRequirement" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< objectRequirement_type > r (
          objectRequirement_traits::create (i, f, this));

        this->objectRequirement_.push_back (r);
        continue;
      }

      break;
    }
  }

  CalorimeterObjectRequirements* CalorimeterObjectRequirements::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectRequirements (*this, f, c);
  }

  CalorimeterObjectRequirements::
  ~CalorimeterObjectRequirements ()
  {
  }

  // CalorimeterCondition
  //

  CalorimeterCondition::
  CalorimeterCondition (const name_type& name,
                        const description_type& description,
                        const locked_type& locked,
                        const type_type& type,
                        const etComparison_type& etComparison,
                        const objectType_type& objectType,
                        const objectRequirements_type& objectRequirements,
                        const relativeBx_type& relativeBx)
  : ::l1t::Condition (name,
                      description,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    etComparison_ (etComparison, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectRequirements_ (objectRequirements, ::xml_schema::flags (), this),
    deltaRequirement_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const name_type& name,
                        const description_type& description,
                        const locked_type& locked,
                        const type_type& type,
                        const etComparison_type& etComparison,
                        const objectType_type& objectType,
                        ::std::auto_ptr< objectRequirements_type >& objectRequirements,
                        const relativeBx_type& relativeBx)
  : ::l1t::Condition (name,
                      description,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    etComparison_ (etComparison, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectRequirements_ (objectRequirements, ::xml_schema::flags (), this),
    deltaRequirement_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const CalorimeterCondition& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c),
    type_ (x.type_, f, this),
    etComparison_ (x.etComparison_, f, this),
    objectType_ (x.objectType_, f, this),
    objectRequirements_ (x.objectRequirements_, f, this),
    deltaRequirement_ (x.deltaRequirement_, f, this),
    relativeBx_ (x.relativeBx_, f, this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    etComparison_ (f, this),
    objectType_ (f, this),
    objectRequirements_ (f, this),
    deltaRequirement_ (f, this),
    relativeBx_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterCondition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::l1t::Condition::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // etComparison
      //
      if (n.name () == "etComparison" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etComparison_type > r (
          etComparison_traits::create (i, f, this));

        if (!etComparison_.present ())
        {
          this->etComparison_.set (r);
          continue;
        }
      }

      // objectType
      //
      if (n.name () == "objectType" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< objectType_type > r (
          objectType_traits::create (i, f, this));

        if (!objectType_.present ())
        {
          this->objectType_.set (r);
          continue;
        }
      }

      // objectRequirements
      //
      if (n.name () == "objectRequirements" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< objectRequirements_type > r (
          objectRequirements_traits::create (i, f, this));

        if (!objectRequirements_.present ())
        {
          this->objectRequirements_.set (r);
          continue;
        }
      }

      // deltaRequirement
      //
      if (n.name () == "deltaRequirement" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< deltaRequirement_type > r (
          deltaRequirement_traits::create (i, f, this));

        if (!this->deltaRequirement_)
        {
          this->deltaRequirement_.set (r);
          continue;
        }
      }

      // relativeBx
      //
      if (n.name () == "relativeBx" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< relativeBx_type > r (
          relativeBx_traits::create (i, f, this));

        if (!relativeBx_.present ())
        {
          this->relativeBx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.cern.ch/l1t");
    }

    if (!etComparison_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etComparison",
        "http://www.cern.ch/l1t");
    }

    if (!objectType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectType",
        "http://www.cern.ch/l1t");
    }

    if (!objectRequirements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectRequirements",
        "http://www.cern.ch/l1t");
    }

    if (!relativeBx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeBx",
        "http://www.cern.ch/l1t");
    }
  }

  CalorimeterCondition* CalorimeterCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterCondition (*this, f, c);
  }

  CalorimeterCondition::
  ~CalorimeterCondition ()
  {
  }

  // MuonCondition
  //

  MuonCondition::
  MuonCondition (const name_type& name,
                 const description_type& description,
                 const locked_type& locked,
                 const type_type& type,
                 const etComparison_type& etComparison,
                 const relativeBx_type& relativeBx)
  : ::l1t::Condition (name,
                      description,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    etComparison_ (etComparison, ::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  MuonCondition::
  MuonCondition (const MuonCondition& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c),
    type_ (x.type_, f, this),
    etComparison_ (x.etComparison_, f, this),
    relativeBx_ (x.relativeBx_, f, this)
  {
  }

  MuonCondition::
  MuonCondition (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::l1t::Condition (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    etComparison_ (f, this),
    relativeBx_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuonCondition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::l1t::Condition::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // etComparison
      //
      if (n.name () == "etComparison" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etComparison_type > r (
          etComparison_traits::create (i, f, this));

        if (!etComparison_.present ())
        {
          this->etComparison_.set (r);
          continue;
        }
      }

      // relativeBx
      //
      if (n.name () == "relativeBx" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< relativeBx_type > r (
          relativeBx_traits::create (i, f, this));

        if (!relativeBx_.present ())
        {
          this->relativeBx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.cern.ch/l1t");
    }

    if (!etComparison_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etComparison",
        "http://www.cern.ch/l1t");
    }

    if (!relativeBx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeBx",
        "http://www.cern.ch/l1t");
    }
  }

  MuonCondition* MuonCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonCondition (*this, f, c);
  }

  MuonCondition::
  ~MuonCondition ()
  {
  }

  // EnergySumsCondition
  //

  EnergySumsCondition::
  EnergySumsCondition (const name_type& name,
                       const description_type& description,
                       const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  EnergySumsCondition::
  EnergySumsCondition (const EnergySumsCondition& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  EnergySumsCondition::
  EnergySumsCondition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  EnergySumsCondition* EnergySumsCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnergySumsCondition (*this, f, c);
  }

  EnergySumsCondition::
  ~EnergySumsCondition ()
  {
  }

  // CorrelationCondition
  //

  CorrelationCondition::
  CorrelationCondition (const name_type& name,
                        const description_type& description,
                        const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  CorrelationCondition::
  CorrelationCondition (const CorrelationCondition& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  CorrelationCondition::
  CorrelationCondition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  CorrelationCondition* CorrelationCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrelationCondition (*this, f, c);
  }

  CorrelationCondition::
  ~CorrelationCondition ()
  {
  }

  // InvariantMassCondition
  //

  InvariantMassCondition::
  InvariantMassCondition (const name_type& name,
                          const description_type& description,
                          const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  InvariantMassCondition::
  InvariantMassCondition (const InvariantMassCondition& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  InvariantMassCondition::
  InvariantMassCondition (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  InvariantMassCondition* InvariantMassCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InvariantMassCondition (*this, f, c);
  }

  InvariantMassCondition::
  ~InvariantMassCondition ()
  {
  }

  // DeltaRCondition
  //

  DeltaRCondition::
  DeltaRCondition (const name_type& name,
                   const description_type& description,
                   const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  DeltaRCondition::
  DeltaRCondition (const DeltaRCondition& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  DeltaRCondition::
  DeltaRCondition (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  DeltaRCondition* DeltaRCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeltaRCondition (*this, f, c);
  }

  DeltaRCondition::
  ~DeltaRCondition ()
  {
  }

  // Algorithm
  //

  Algorithm::
  Algorithm (const name_type& name,
             const index_type& index,
             const equation_type& equation,
             const description_type& description,
             const locked_type& locked)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    index_ (index, ::xml_schema::flags (), this),
    equation_ (equation, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this)
  {
  }

  Algorithm::
  Algorithm (const Algorithm& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    index_ (x.index_, f, this),
    equation_ (x.equation_, f, this),
    description_ (x.description_, f, this),
    locked_ (x.locked_, f, this)
  {
  }

  Algorithm::
  Algorithm (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    index_ (f, this),
    equation_ (f, this),
    description_ (f, this),
    locked_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Algorithm::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // index
      //
      if (n.name () == "index" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< index_type > r (
          index_traits::create (i, f, this));

        if (!index_.present ())
        {
          this->index_.set (r);
          continue;
        }
      }

      // equation
      //
      if (n.name () == "equation" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< equation_type > r (
          equation_traits::create (i, f, this));

        if (!equation_.present ())
        {
          this->equation_.set (r);
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // locked
      //
      if (n.name () == "locked" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!locked_.present ())
        {
          this->locked_.set (locked_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t");
    }

    if (!index_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "index",
        "http://www.cern.ch/l1t");
    }

    if (!equation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "equation",
        "http://www.cern.ch/l1t");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://www.cern.ch/l1t");
    }

    if (!locked_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locked",
        "http://www.cern.ch/l1t");
    }
  }

  Algorithm* Algorithm::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Algorithm (*this, f, c);
  }

  Algorithm::
  ~Algorithm ()
  {
  }

  // AlgorithmList
  //

  AlgorithmList::
  AlgorithmList ()
  : ::xml_schema::type (),
    algorithm_ (::xml_schema::flags (), this)
  {
  }

  AlgorithmList::
  AlgorithmList (const AlgorithmList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    algorithm_ (x.algorithm_, f, this)
  {
  }

  AlgorithmList::
  AlgorithmList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    algorithm_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AlgorithmList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // algorithm
      //
      if (n.name () == "algorithm" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< algorithm_type > r (
          algorithm_traits::create (i, f, this));

        this->algorithm_.push_back (r);
        continue;
      }

      break;
    }
  }

  AlgorithmList* AlgorithmList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmList (*this, f, c);
  }

  AlgorithmList::
  ~AlgorithmList ()
  {
  }

  // L1TriggerMenu
  //

  const L1TriggerMenu::version_type L1TriggerMenu::version_default_value_ (
    "0.5.0");

  L1TriggerMenu::
  L1TriggerMenu (const meta_type& meta,
                 const conditions_type& conditions,
                 const algorithms_type& algorithms)
  : ::xml_schema::type (),
    meta_ (meta, ::xml_schema::flags (), this),
    conditions_ (conditions, ::xml_schema::flags (), this),
    algorithms_ (algorithms, ::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (::std::auto_ptr< meta_type >& meta,
                 ::std::auto_ptr< conditions_type >& conditions,
                 ::std::auto_ptr< algorithms_type >& algorithms)
  : ::xml_schema::type (),
    meta_ (meta, ::xml_schema::flags (), this),
    conditions_ (conditions, ::xml_schema::flags (), this),
    algorithms_ (algorithms, ::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (const L1TriggerMenu& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    meta_ (x.meta_, f, this),
    conditions_ (x.conditions_, f, this),
    algorithms_ (x.algorithms_, f, this),
    version_ (x.version_, f, this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    meta_ (f, this),
    conditions_ (f, this),
    algorithms_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void L1TriggerMenu::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // meta
      //
      if (n.name () == "meta" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< meta_type > r (
          meta_traits::create (i, f, this));

        if (!meta_.present ())
        {
          this->meta_.set (r);
          continue;
        }
      }

      // conditions
      //
      if (n.name () == "conditions" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< conditions_type > r (
          conditions_traits::create (i, f, this));

        if (!conditions_.present ())
        {
          this->conditions_.set (r);
          continue;
        }
      }

      // algorithms
      //
      if (n.name () == "algorithms" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< algorithms_type > r (
          algorithms_traits::create (i, f, this));

        if (!algorithms_.present ())
        {
          this->algorithms_.set (r);
          continue;
        }
      }

      break;
    }

    if (!meta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "meta",
        "http://www.cern.ch/l1t");
    }

    if (!conditions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "conditions",
        "http://www.cern.ch/l1t");
    }

    if (!algorithms_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "algorithms",
        "http://www.cern.ch/l1t");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  L1TriggerMenu* L1TriggerMenu::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class L1TriggerMenu (*this, f, c);
  }

  L1TriggerMenu::
  ~L1TriggerMenu ()
  {
  }
}

#include <istream>
#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/xml/sax/std-input-source.hxx>
#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/tree/error-handler.hxx>

namespace l1t
{
  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::l1t::l1TriggerMenu (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "l1TriggerMenu" &&
        n.namespace_ () == "http://www.cern.ch/l1t")
    {
      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::xsd::cxx::tree::traits< ::l1t::L1TriggerMenu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "l1TriggerMenu",
      "http://www.cern.ch/l1t");
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "l1TriggerMenu" &&
        n.namespace_ () == "http://www.cern.ch/l1t")
    {
      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::xsd::cxx::tree::traits< ::l1t::L1TriggerMenu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "l1TriggerMenu",
      "http://www.cern.ch/l1t");
  }
}

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

