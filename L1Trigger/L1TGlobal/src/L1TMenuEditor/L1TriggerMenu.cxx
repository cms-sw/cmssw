// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/pre.hxx>

#include "L1Trigger/L1TGlobal/src/L1TMenuEditor/L1TriggerMenu.hxx"

namespace l1t
{
  // UUID
  // 


  // DateTime
  // 


  // Name
  // 


  // Comment
  // 


  // MenuName
  // 


  // ScaleSet
  // 


  // Version
  // 


  // RevisionList
  // 

  const RevisionList::revision_sequence& RevisionList::
  revision () const
  {
    return this->revision_;
  }

  RevisionList::revision_sequence& RevisionList::
  revision ()
  {
    return this->revision_;
  }

  void RevisionList::
  revision (const revision_sequence& s)
  {
    this->revision_ = s;
  }


  // Revision
  // 

  const Revision::author_type& Revision::
  author () const
  {
    return this->author_.get ();
  }

  Revision::author_type& Revision::
  author ()
  {
    return this->author_.get ();
  }

  void Revision::
  author (const author_type& x)
  {
    this->author_.set (x);
  }

  void Revision::
  author (::std::auto_ptr< author_type > x)
  {
    this->author_.set (x);
  }

  const Revision::datetime_type& Revision::
  datetime () const
  {
    return this->datetime_.get ();
  }

  Revision::datetime_type& Revision::
  datetime ()
  {
    return this->datetime_.get ();
  }

  void Revision::
  datetime (const datetime_type& x)
  {
    this->datetime_.set (x);
  }

  void Revision::
  datetime (::std::auto_ptr< datetime_type > x)
  {
    this->datetime_.set (x);
  }

  const Revision::username_optional& Revision::
  username () const
  {
    return this->username_;
  }

  Revision::username_optional& Revision::
  username ()
  {
    return this->username_;
  }

  void Revision::
  username (const username_type& x)
  {
    this->username_.set (x);
  }

  void Revision::
  username (const username_optional& x)
  {
    this->username_ = x;
  }

  void Revision::
  username (::std::auto_ptr< username_type > x)
  {
    this->username_.set (x);
  }

  const Revision::hostname_optional& Revision::
  hostname () const
  {
    return this->hostname_;
  }

  Revision::hostname_optional& Revision::
  hostname ()
  {
    return this->hostname_;
  }

  void Revision::
  hostname (const hostname_type& x)
  {
    this->hostname_.set (x);
  }

  void Revision::
  hostname (const hostname_optional& x)
  {
    this->hostname_ = x;
  }

  void Revision::
  hostname (::std::auto_ptr< hostname_type > x)
  {
    this->hostname_.set (x);
  }


  // ComparisonOperator
  // 

  ComparisonOperator::
  ComparisonOperator (value v)
  : ::xml_schema::string (_xsd_ComparisonOperator_literals_[v])
  {
  }

  ComparisonOperator::
  ComparisonOperator (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ComparisonOperator::
  ComparisonOperator (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ComparisonOperator::
  ComparisonOperator (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ComparisonOperator::
  ComparisonOperator (const ComparisonOperator& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ComparisonOperator& ComparisonOperator::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ComparisonOperator_literals_[v]);

    return *this;
  }


  // RelativeBx
  // 


  // ConditionName
  // 


  // ConditionType
  // 

  ConditionType::
  ConditionType (value v)
  : ::xml_schema::string (_xsd_ConditionType_literals_[v])
  {
  }

  ConditionType::
  ConditionType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ConditionType::
  ConditionType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ConditionType::
  ConditionType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ConditionType::
  ConditionType (const ConditionType& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ConditionType& ConditionType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ConditionType_literals_[v]);

    return *this;
  }


  // CalorimeterObjectType
  // 

  CalorimeterObjectType::
  CalorimeterObjectType (value v)
  : ::xml_schema::string (_xsd_CalorimeterObjectType_literals_[v])
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const CalorimeterObjectType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  CalorimeterObjectType& CalorimeterObjectType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_CalorimeterObjectType_literals_[v]);

    return *this;
  }


  // MuonRequstedCharge
  // 

  MuonRequstedCharge::
  MuonRequstedCharge (value v)
  : ::xml_schema::string (_xsd_MuonRequstedCharge_literals_[v])
  {
  }

  MuonRequstedCharge::
  MuonRequstedCharge (const char* v)
  : ::xml_schema::string (v)
  {
  }

  MuonRequstedCharge::
  MuonRequstedCharge (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  MuonRequstedCharge::
  MuonRequstedCharge (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  MuonRequstedCharge::
  MuonRequstedCharge (const MuonRequstedCharge& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  MuonRequstedCharge& MuonRequstedCharge::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_MuonRequstedCharge_literals_[v]);

    return *this;
  }


  // MuonRequstedChargeCorr
  // 

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (value v)
  : ::xml_schema::string (_xsd_MuonRequstedChargeCorr_literals_[v])
  {
  }

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const char* v)
  : ::xml_schema::string (v)
  {
  }

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const MuonRequstedChargeCorr& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  MuonRequstedChargeCorr& MuonRequstedChargeCorr::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_MuonRequstedChargeCorr_literals_[v]);

    return *this;
  }


  // EnergySumsObjectType
  // 

  EnergySumsObjectType::
  EnergySumsObjectType (value v)
  : ::xml_schema::string (_xsd_EnergySumsObjectType_literals_[v])
  {
  }

  EnergySumsObjectType::
  EnergySumsObjectType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  EnergySumsObjectType::
  EnergySumsObjectType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  EnergySumsObjectType::
  EnergySumsObjectType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  EnergySumsObjectType::
  EnergySumsObjectType (const EnergySumsObjectType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  EnergySumsObjectType& EnergySumsObjectType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_EnergySumsObjectType_literals_[v]);

    return *this;
  }


  // EtThreshold
  // 


  // PtThreshold
  // 


  // AlgorithmName
  // 


  // AlgorithmIndex
  // 


  // LogicalExpression
  // 


  // AlgorithmMappedModule
  // 


  // AlgorithmMappedIndex
  // 


  // Meta
  // 

  const Meta::name_type& Meta::
  name () const
  {
    return this->name_.get ();
  }

  Meta::name_type& Meta::
  name ()
  {
    return this->name_.get ();
  }

  void Meta::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Meta::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Meta::datetime_type& Meta::
  datetime () const
  {
    return this->datetime_.get ();
  }

  Meta::datetime_type& Meta::
  datetime ()
  {
    return this->datetime_.get ();
  }

  void Meta::
  datetime (const datetime_type& x)
  {
    this->datetime_.set (x);
  }

  void Meta::
  datetime (::std::auto_ptr< datetime_type > x)
  {
    this->datetime_.set (x);
  }

  const Meta::uuid_menu_type& Meta::
  uuid_menu () const
  {
    return this->uuid_menu_.get ();
  }

  Meta::uuid_menu_type& Meta::
  uuid_menu ()
  {
    return this->uuid_menu_.get ();
  }

  void Meta::
  uuid_menu (const uuid_menu_type& x)
  {
    this->uuid_menu_.set (x);
  }

  void Meta::
  uuid_menu (::std::auto_ptr< uuid_menu_type > x)
  {
    this->uuid_menu_.set (x);
  }

  const Meta::uuid_firmware_optional& Meta::
  uuid_firmware () const
  {
    return this->uuid_firmware_;
  }

  Meta::uuid_firmware_optional& Meta::
  uuid_firmware ()
  {
    return this->uuid_firmware_;
  }

  void Meta::
  uuid_firmware (const uuid_firmware_type& x)
  {
    this->uuid_firmware_.set (x);
  }

  void Meta::
  uuid_firmware (const uuid_firmware_optional& x)
  {
    this->uuid_firmware_ = x;
  }

  void Meta::
  uuid_firmware (::std::auto_ptr< uuid_firmware_type > x)
  {
    this->uuid_firmware_.set (x);
  }

  const Meta::comment_type& Meta::
  comment () const
  {
    return this->comment_.get ();
  }

  Meta::comment_type& Meta::
  comment ()
  {
    return this->comment_.get ();
  }

  void Meta::
  comment (const comment_type& x)
  {
    this->comment_.set (x);
  }

  void Meta::
  comment (::std::auto_ptr< comment_type > x)
  {
    this->comment_.set (x);
  }

  const Meta::scale_set_type& Meta::
  scale_set () const
  {
    return this->scale_set_.get ();
  }

  Meta::scale_set_type& Meta::
  scale_set ()
  {
    return this->scale_set_.get ();
  }

  void Meta::
  scale_set (const scale_set_type& x)
  {
    this->scale_set_.set (x);
  }

  void Meta::
  scale_set (::std::auto_ptr< scale_set_type > x)
  {
    this->scale_set_.set (x);
  }

  const Meta::editor_version_optional& Meta::
  editor_version () const
  {
    return this->editor_version_;
  }

  Meta::editor_version_optional& Meta::
  editor_version ()
  {
    return this->editor_version_;
  }

  void Meta::
  editor_version (const editor_version_type& x)
  {
    this->editor_version_.set (x);
  }

  void Meta::
  editor_version (const editor_version_optional& x)
  {
    this->editor_version_ = x;
  }

  void Meta::
  editor_version (::std::auto_ptr< editor_version_type > x)
  {
    this->editor_version_.set (x);
  }

  const Meta::revisions_type& Meta::
  revisions () const
  {
    return this->revisions_.get ();
  }

  Meta::revisions_type& Meta::
  revisions ()
  {
    return this->revisions_.get ();
  }

  void Meta::
  revisions (const revisions_type& x)
  {
    this->revisions_.set (x);
  }

  void Meta::
  revisions (::std::auto_ptr< revisions_type > x)
  {
    this->revisions_.set (x);
  }


  // ConditionList
  // 

  const ConditionList::condCalorimeter_sequence& ConditionList::
  condCalorimeter () const
  {
    return this->condCalorimeter_;
  }

  ConditionList::condCalorimeter_sequence& ConditionList::
  condCalorimeter ()
  {
    return this->condCalorimeter_;
  }

  void ConditionList::
  condCalorimeter (const condCalorimeter_sequence& s)
  {
    this->condCalorimeter_ = s;
  }

  const ConditionList::condMuon_sequence& ConditionList::
  condMuon () const
  {
    return this->condMuon_;
  }

  ConditionList::condMuon_sequence& ConditionList::
  condMuon ()
  {
    return this->condMuon_;
  }

  void ConditionList::
  condMuon (const condMuon_sequence& s)
  {
    this->condMuon_ = s;
  }

  const ConditionList::condEnergySums_sequence& ConditionList::
  condEnergySums () const
  {
    return this->condEnergySums_;
  }

  ConditionList::condEnergySums_sequence& ConditionList::
  condEnergySums ()
  {
    return this->condEnergySums_;
  }

  void ConditionList::
  condEnergySums (const condEnergySums_sequence& s)
  {
    this->condEnergySums_ = s;
  }


  // Condition
  // 

  const Condition::uid_type& Condition::
  uid () const
  {
    return this->uid_.get ();
  }

  Condition::uid_type& Condition::
  uid ()
  {
    return this->uid_.get ();
  }

  void Condition::
  uid (const uid_type& x)
  {
    this->uid_.set (x);
  }

  void Condition::
  uid (::std::auto_ptr< uid_type > x)
  {
    this->uid_.set (x);
  }

  const Condition::name_type& Condition::
  name () const
  {
    return this->name_.get ();
  }

  Condition::name_type& Condition::
  name ()
  {
    return this->name_.get ();
  }

  void Condition::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Condition::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Condition::comment_type& Condition::
  comment () const
  {
    return this->comment_.get ();
  }

  Condition::comment_type& Condition::
  comment ()
  {
    return this->comment_.get ();
  }

  void Condition::
  comment (const comment_type& x)
  {
    this->comment_.set (x);
  }

  void Condition::
  comment (::std::auto_ptr< comment_type > x)
  {
    this->comment_.set (x);
  }

  const Condition::locked_type& Condition::
  locked () const
  {
    return this->locked_.get ();
  }

  Condition::locked_type& Condition::
  locked ()
  {
    return this->locked_.get ();
  }

  void Condition::
  locked (const locked_type& x)
  {
    this->locked_.set (x);
  }


  // Window
  // 

  const Window::lower_type& Window::
  lower () const
  {
    return this->lower_.get ();
  }

  Window::lower_type& Window::
  lower ()
  {
    return this->lower_.get ();
  }

  void Window::
  lower (const lower_type& x)
  {
    this->lower_.set (x);
  }

  const Window::upper_type& Window::
  upper () const
  {
    return this->upper_.get ();
  }

  Window::upper_type& Window::
  upper ()
  {
    return this->upper_.get ();
  }

  void Window::
  upper (const upper_type& x)
  {
    this->upper_.set (x);
  }


  // DeltaRequirement
  // 

  const DeltaRequirement::deltaPhiRange_type& DeltaRequirement::
  deltaPhiRange () const
  {
    return this->deltaPhiRange_.get ();
  }

  DeltaRequirement::deltaPhiRange_type& DeltaRequirement::
  deltaPhiRange ()
  {
    return this->deltaPhiRange_.get ();
  }

  void DeltaRequirement::
  deltaPhiRange (const deltaPhiRange_type& x)
  {
    this->deltaPhiRange_.set (x);
  }

  void DeltaRequirement::
  deltaPhiRange (::std::auto_ptr< deltaPhiRange_type > x)
  {
    this->deltaPhiRange_.set (x);
  }

  const DeltaRequirement::deltaEtaRange_type& DeltaRequirement::
  deltaEtaRange () const
  {
    return this->deltaEtaRange_.get ();
  }

  DeltaRequirement::deltaEtaRange_type& DeltaRequirement::
  deltaEtaRange ()
  {
    return this->deltaEtaRange_.get ();
  }

  void DeltaRequirement::
  deltaEtaRange (const deltaEtaRange_type& x)
  {
    this->deltaEtaRange_.set (x);
  }

  void DeltaRequirement::
  deltaEtaRange (::std::auto_ptr< deltaEtaRange_type > x)
  {
    this->deltaEtaRange_.set (x);
  }


  // CalorimeterIsolationLUT
  // 

  const CalorimeterIsolationLUT::isolation_sequence& CalorimeterIsolationLUT::
  isolation () const
  {
    return this->isolation_;
  }

  CalorimeterIsolationLUT::isolation_sequence& CalorimeterIsolationLUT::
  isolation ()
  {
    return this->isolation_;
  }

  void CalorimeterIsolationLUT::
  isolation (const isolation_sequence& s)
  {
    this->isolation_ = s;
  }


  // CalorimeterObjectRequirement
  // 

  const CalorimeterObjectRequirement::etThreshold_type& CalorimeterObjectRequirement::
  etThreshold () const
  {
    return this->etThreshold_.get ();
  }

  CalorimeterObjectRequirement::etThreshold_type& CalorimeterObjectRequirement::
  etThreshold ()
  {
    return this->etThreshold_.get ();
  }

  void CalorimeterObjectRequirement::
  etThreshold (const etThreshold_type& x)
  {
    this->etThreshold_.set (x);
  }

  void CalorimeterObjectRequirement::
  etThreshold (::std::auto_ptr< etThreshold_type > x)
  {
    this->etThreshold_.set (x);
  }

  const CalorimeterObjectRequirement::phiWindow_sequence& CalorimeterObjectRequirement::
  phiWindow () const
  {
    return this->phiWindow_;
  }

  CalorimeterObjectRequirement::phiWindow_sequence& CalorimeterObjectRequirement::
  phiWindow ()
  {
    return this->phiWindow_;
  }

  void CalorimeterObjectRequirement::
  phiWindow (const phiWindow_sequence& s)
  {
    this->phiWindow_ = s;
  }

  const CalorimeterObjectRequirement::etaWindow_sequence& CalorimeterObjectRequirement::
  etaWindow () const
  {
    return this->etaWindow_;
  }

  CalorimeterObjectRequirement::etaWindow_sequence& CalorimeterObjectRequirement::
  etaWindow ()
  {
    return this->etaWindow_;
  }

  void CalorimeterObjectRequirement::
  etaWindow (const etaWindow_sequence& s)
  {
    this->etaWindow_ = s;
  }

  const CalorimeterObjectRequirement::isolationLut_type& CalorimeterObjectRequirement::
  isolationLut () const
  {
    return this->isolationLut_.get ();
  }

  CalorimeterObjectRequirement::isolationLut_type& CalorimeterObjectRequirement::
  isolationLut ()
  {
    return this->isolationLut_.get ();
  }

  void CalorimeterObjectRequirement::
  isolationLut (const isolationLut_type& x)
  {
    this->isolationLut_.set (x);
  }

  void CalorimeterObjectRequirement::
  isolationLut (::std::auto_ptr< isolationLut_type > x)
  {
    this->isolationLut_.set (x);
  }


  // CalorimeterObjectRequirements
  // 

  const CalorimeterObjectRequirements::objectRequirement_sequence& CalorimeterObjectRequirements::
  objectRequirement () const
  {
    return this->objectRequirement_;
  }

  CalorimeterObjectRequirements::objectRequirement_sequence& CalorimeterObjectRequirements::
  objectRequirement ()
  {
    return this->objectRequirement_;
  }

  void CalorimeterObjectRequirements::
  objectRequirement (const objectRequirement_sequence& s)
  {
    this->objectRequirement_ = s;
  }


  // CalorimeterCondition
  // 

  const CalorimeterCondition::type_type& CalorimeterCondition::
  type () const
  {
    return this->type_.get ();
  }

  CalorimeterCondition::type_type& CalorimeterCondition::
  type ()
  {
    return this->type_.get ();
  }

  void CalorimeterCondition::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void CalorimeterCondition::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const CalorimeterCondition::comparison_operator_type& CalorimeterCondition::
  comparison_operator () const
  {
    return this->comparison_operator_.get ();
  }

  CalorimeterCondition::comparison_operator_type& CalorimeterCondition::
  comparison_operator ()
  {
    return this->comparison_operator_.get ();
  }

  void CalorimeterCondition::
  comparison_operator (const comparison_operator_type& x)
  {
    this->comparison_operator_.set (x);
  }

  void CalorimeterCondition::
  comparison_operator (::std::auto_ptr< comparison_operator_type > x)
  {
    this->comparison_operator_.set (x);
  }

  const CalorimeterCondition::objectType_type& CalorimeterCondition::
  objectType () const
  {
    return this->objectType_.get ();
  }

  CalorimeterCondition::objectType_type& CalorimeterCondition::
  objectType ()
  {
    return this->objectType_.get ();
  }

  void CalorimeterCondition::
  objectType (const objectType_type& x)
  {
    this->objectType_.set (x);
  }

  void CalorimeterCondition::
  objectType (::std::auto_ptr< objectType_type > x)
  {
    this->objectType_.set (x);
  }

  const CalorimeterCondition::objectRequirements_type& CalorimeterCondition::
  objectRequirements () const
  {
    return this->objectRequirements_.get ();
  }

  CalorimeterCondition::objectRequirements_type& CalorimeterCondition::
  objectRequirements ()
  {
    return this->objectRequirements_.get ();
  }

  void CalorimeterCondition::
  objectRequirements (const objectRequirements_type& x)
  {
    this->objectRequirements_.set (x);
  }

  void CalorimeterCondition::
  objectRequirements (::std::auto_ptr< objectRequirements_type > x)
  {
    this->objectRequirements_.set (x);
  }

  const CalorimeterCondition::deltaRequirement_optional& CalorimeterCondition::
  deltaRequirement () const
  {
    return this->deltaRequirement_;
  }

  CalorimeterCondition::deltaRequirement_optional& CalorimeterCondition::
  deltaRequirement ()
  {
    return this->deltaRequirement_;
  }

  void CalorimeterCondition::
  deltaRequirement (const deltaRequirement_type& x)
  {
    this->deltaRequirement_.set (x);
  }

  void CalorimeterCondition::
  deltaRequirement (const deltaRequirement_optional& x)
  {
    this->deltaRequirement_ = x;
  }

  void CalorimeterCondition::
  deltaRequirement (::std::auto_ptr< deltaRequirement_type > x)
  {
    this->deltaRequirement_.set (x);
  }

  const CalorimeterCondition::relativeBx_type& CalorimeterCondition::
  relativeBx () const
  {
    return this->relativeBx_.get ();
  }

  CalorimeterCondition::relativeBx_type& CalorimeterCondition::
  relativeBx ()
  {
    return this->relativeBx_.get ();
  }

  void CalorimeterCondition::
  relativeBx (const relativeBx_type& x)
  {
    this->relativeBx_.set (x);
  }

  void CalorimeterCondition::
  relativeBx (::std::auto_ptr< relativeBx_type > x)
  {
    this->relativeBx_.set (x);
  }


  // MuonObjectRequirement
  // 

  const MuonObjectRequirement::ptThreshold_type& MuonObjectRequirement::
  ptThreshold () const
  {
    return this->ptThreshold_.get ();
  }

  MuonObjectRequirement::ptThreshold_type& MuonObjectRequirement::
  ptThreshold ()
  {
    return this->ptThreshold_.get ();
  }

  void MuonObjectRequirement::
  ptThreshold (const ptThreshold_type& x)
  {
    this->ptThreshold_.set (x);
  }

  void MuonObjectRequirement::
  ptThreshold (::std::auto_ptr< ptThreshold_type > x)
  {
    this->ptThreshold_.set (x);
  }

  const MuonObjectRequirement::phiWindow_sequence& MuonObjectRequirement::
  phiWindow () const
  {
    return this->phiWindow_;
  }

  MuonObjectRequirement::phiWindow_sequence& MuonObjectRequirement::
  phiWindow ()
  {
    return this->phiWindow_;
  }

  void MuonObjectRequirement::
  phiWindow (const phiWindow_sequence& s)
  {
    this->phiWindow_ = s;
  }

  const MuonObjectRequirement::etaWindow_sequence& MuonObjectRequirement::
  etaWindow () const
  {
    return this->etaWindow_;
  }

  MuonObjectRequirement::etaWindow_sequence& MuonObjectRequirement::
  etaWindow ()
  {
    return this->etaWindow_;
  }

  void MuonObjectRequirement::
  etaWindow (const etaWindow_sequence& s)
  {
    this->etaWindow_ = s;
  }

  const MuonObjectRequirement::requestedCharge_type& MuonObjectRequirement::
  requestedCharge () const
  {
    return this->requestedCharge_.get ();
  }

  MuonObjectRequirement::requestedCharge_type& MuonObjectRequirement::
  requestedCharge ()
  {
    return this->requestedCharge_.get ();
  }

  void MuonObjectRequirement::
  requestedCharge (const requestedCharge_type& x)
  {
    this->requestedCharge_.set (x);
  }

  void MuonObjectRequirement::
  requestedCharge (::std::auto_ptr< requestedCharge_type > x)
  {
    this->requestedCharge_.set (x);
  }

  const MuonObjectRequirement::qualityLut_type& MuonObjectRequirement::
  qualityLut () const
  {
    return this->qualityLut_.get ();
  }

  MuonObjectRequirement::qualityLut_type& MuonObjectRequirement::
  qualityLut ()
  {
    return this->qualityLut_.get ();
  }

  void MuonObjectRequirement::
  qualityLut (const qualityLut_type& x)
  {
    this->qualityLut_.set (x);
  }

  void MuonObjectRequirement::
  qualityLut (::std::auto_ptr< qualityLut_type > x)
  {
    this->qualityLut_.set (x);
  }

  const MuonObjectRequirement::isolationLut_type& MuonObjectRequirement::
  isolationLut () const
  {
    return this->isolationLut_.get ();
  }

  MuonObjectRequirement::isolationLut_type& MuonObjectRequirement::
  isolationLut ()
  {
    return this->isolationLut_.get ();
  }

  void MuonObjectRequirement::
  isolationLut (const isolationLut_type& x)
  {
    this->isolationLut_.set (x);
  }

  void MuonObjectRequirement::
  isolationLut (::std::auto_ptr< isolationLut_type > x)
  {
    this->isolationLut_.set (x);
  }


  // MuonObjectRequirements
  // 

  const MuonObjectRequirements::objectRequirement_sequence& MuonObjectRequirements::
  objectRequirement () const
  {
    return this->objectRequirement_;
  }

  MuonObjectRequirements::objectRequirement_sequence& MuonObjectRequirements::
  objectRequirement ()
  {
    return this->objectRequirement_;
  }

  void MuonObjectRequirements::
  objectRequirement (const objectRequirement_sequence& s)
  {
    this->objectRequirement_ = s;
  }


  // MuonQualityLUT
  // 

  const MuonQualityLUT::quality_sequence& MuonQualityLUT::
  quality () const
  {
    return this->quality_;
  }

  MuonQualityLUT::quality_sequence& MuonQualityLUT::
  quality ()
  {
    return this->quality_;
  }

  void MuonQualityLUT::
  quality (const quality_sequence& s)
  {
    this->quality_ = s;
  }


  // MuonIsolationLUT
  // 

  const MuonIsolationLUT::isolation_sequence& MuonIsolationLUT::
  isolation () const
  {
    return this->isolation_;
  }

  MuonIsolationLUT::isolation_sequence& MuonIsolationLUT::
  isolation ()
  {
    return this->isolation_;
  }

  void MuonIsolationLUT::
  isolation (const isolation_sequence& s)
  {
    this->isolation_ = s;
  }


  // MuonCondition
  // 

  const MuonCondition::type_type& MuonCondition::
  type () const
  {
    return this->type_.get ();
  }

  MuonCondition::type_type& MuonCondition::
  type ()
  {
    return this->type_.get ();
  }

  void MuonCondition::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void MuonCondition::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const MuonCondition::comparison_operator_type& MuonCondition::
  comparison_operator () const
  {
    return this->comparison_operator_.get ();
  }

  MuonCondition::comparison_operator_type& MuonCondition::
  comparison_operator ()
  {
    return this->comparison_operator_.get ();
  }

  void MuonCondition::
  comparison_operator (const comparison_operator_type& x)
  {
    this->comparison_operator_.set (x);
  }

  void MuonCondition::
  comparison_operator (::std::auto_ptr< comparison_operator_type > x)
  {
    this->comparison_operator_.set (x);
  }

  const MuonCondition::objectRequirements_type& MuonCondition::
  objectRequirements () const
  {
    return this->objectRequirements_.get ();
  }

  MuonCondition::objectRequirements_type& MuonCondition::
  objectRequirements ()
  {
    return this->objectRequirements_.get ();
  }

  void MuonCondition::
  objectRequirements (const objectRequirements_type& x)
  {
    this->objectRequirements_.set (x);
  }

  void MuonCondition::
  objectRequirements (::std::auto_ptr< objectRequirements_type > x)
  {
    this->objectRequirements_.set (x);
  }

  const MuonCondition::requestedChargeCorr_type& MuonCondition::
  requestedChargeCorr () const
  {
    return this->requestedChargeCorr_.get ();
  }

  MuonCondition::requestedChargeCorr_type& MuonCondition::
  requestedChargeCorr ()
  {
    return this->requestedChargeCorr_.get ();
  }

  void MuonCondition::
  requestedChargeCorr (const requestedChargeCorr_type& x)
  {
    this->requestedChargeCorr_.set (x);
  }

  void MuonCondition::
  requestedChargeCorr (::std::auto_ptr< requestedChargeCorr_type > x)
  {
    this->requestedChargeCorr_.set (x);
  }

  const MuonCondition::deltaRequirement_optional& MuonCondition::
  deltaRequirement () const
  {
    return this->deltaRequirement_;
  }

  MuonCondition::deltaRequirement_optional& MuonCondition::
  deltaRequirement ()
  {
    return this->deltaRequirement_;
  }

  void MuonCondition::
  deltaRequirement (const deltaRequirement_type& x)
  {
    this->deltaRequirement_.set (x);
  }

  void MuonCondition::
  deltaRequirement (const deltaRequirement_optional& x)
  {
    this->deltaRequirement_ = x;
  }

  void MuonCondition::
  deltaRequirement (::std::auto_ptr< deltaRequirement_type > x)
  {
    this->deltaRequirement_.set (x);
  }

  const MuonCondition::relativeBx_type& MuonCondition::
  relativeBx () const
  {
    return this->relativeBx_.get ();
  }

  MuonCondition::relativeBx_type& MuonCondition::
  relativeBx ()
  {
    return this->relativeBx_.get ();
  }

  void MuonCondition::
  relativeBx (const relativeBx_type& x)
  {
    this->relativeBx_.set (x);
  }

  void MuonCondition::
  relativeBx (::std::auto_ptr< relativeBx_type > x)
  {
    this->relativeBx_.set (x);
  }


  // EnergySumsObjectRequirement
  // 

  const EnergySumsObjectRequirement::etThreshold_type& EnergySumsObjectRequirement::
  etThreshold () const
  {
    return this->etThreshold_.get ();
  }

  EnergySumsObjectRequirement::etThreshold_type& EnergySumsObjectRequirement::
  etThreshold ()
  {
    return this->etThreshold_.get ();
  }

  void EnergySumsObjectRequirement::
  etThreshold (const etThreshold_type& x)
  {
    this->etThreshold_.set (x);
  }

  void EnergySumsObjectRequirement::
  etThreshold (::std::auto_ptr< etThreshold_type > x)
  {
    this->etThreshold_.set (x);
  }

  const EnergySumsObjectRequirement::phiWindow_sequence& EnergySumsObjectRequirement::
  phiWindow () const
  {
    return this->phiWindow_;
  }

  EnergySumsObjectRequirement::phiWindow_sequence& EnergySumsObjectRequirement::
  phiWindow ()
  {
    return this->phiWindow_;
  }

  void EnergySumsObjectRequirement::
  phiWindow (const phiWindow_sequence& s)
  {
    this->phiWindow_ = s;
  }


  // EnergySumsCondition
  // 

  const EnergySumsCondition::comparison_operator_type& EnergySumsCondition::
  comparison_operator () const
  {
    return this->comparison_operator_.get ();
  }

  EnergySumsCondition::comparison_operator_type& EnergySumsCondition::
  comparison_operator ()
  {
    return this->comparison_operator_.get ();
  }

  void EnergySumsCondition::
  comparison_operator (const comparison_operator_type& x)
  {
    this->comparison_operator_.set (x);
  }

  void EnergySumsCondition::
  comparison_operator (::std::auto_ptr< comparison_operator_type > x)
  {
    this->comparison_operator_.set (x);
  }

  const EnergySumsCondition::objectType_type& EnergySumsCondition::
  objectType () const
  {
    return this->objectType_.get ();
  }

  EnergySumsCondition::objectType_type& EnergySumsCondition::
  objectType ()
  {
    return this->objectType_.get ();
  }

  void EnergySumsCondition::
  objectType (const objectType_type& x)
  {
    this->objectType_.set (x);
  }

  void EnergySumsCondition::
  objectType (::std::auto_ptr< objectType_type > x)
  {
    this->objectType_.set (x);
  }

  const EnergySumsCondition::objectRequirement_type& EnergySumsCondition::
  objectRequirement () const
  {
    return this->objectRequirement_.get ();
  }

  EnergySumsCondition::objectRequirement_type& EnergySumsCondition::
  objectRequirement ()
  {
    return this->objectRequirement_.get ();
  }

  void EnergySumsCondition::
  objectRequirement (const objectRequirement_type& x)
  {
    this->objectRequirement_.set (x);
  }

  void EnergySumsCondition::
  objectRequirement (::std::auto_ptr< objectRequirement_type > x)
  {
    this->objectRequirement_.set (x);
  }

  const EnergySumsCondition::relativeBx_type& EnergySumsCondition::
  relativeBx () const
  {
    return this->relativeBx_.get ();
  }

  EnergySumsCondition::relativeBx_type& EnergySumsCondition::
  relativeBx ()
  {
    return this->relativeBx_.get ();
  }

  void EnergySumsCondition::
  relativeBx (const relativeBx_type& x)
  {
    this->relativeBx_.set (x);
  }

  void EnergySumsCondition::
  relativeBx (::std::auto_ptr< relativeBx_type > x)
  {
    this->relativeBx_.set (x);
  }


  // Algorithm
  // 

  const Algorithm::uid_type& Algorithm::
  uid () const
  {
    return this->uid_.get ();
  }

  Algorithm::uid_type& Algorithm::
  uid ()
  {
    return this->uid_.get ();
  }

  void Algorithm::
  uid (const uid_type& x)
  {
    this->uid_.set (x);
  }

  void Algorithm::
  uid (::std::auto_ptr< uid_type > x)
  {
    this->uid_.set (x);
  }

  const Algorithm::name_type& Algorithm::
  name () const
  {
    return this->name_.get ();
  }

  Algorithm::name_type& Algorithm::
  name ()
  {
    return this->name_.get ();
  }

  void Algorithm::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Algorithm::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Algorithm::index_type& Algorithm::
  index () const
  {
    return this->index_.get ();
  }

  Algorithm::index_type& Algorithm::
  index ()
  {
    return this->index_.get ();
  }

  void Algorithm::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void Algorithm::
  index (::std::auto_ptr< index_type > x)
  {
    this->index_.set (x);
  }

  const Algorithm::logical_expression_type& Algorithm::
  logical_expression () const
  {
    return this->logical_expression_.get ();
  }

  Algorithm::logical_expression_type& Algorithm::
  logical_expression ()
  {
    return this->logical_expression_.get ();
  }

  void Algorithm::
  logical_expression (const logical_expression_type& x)
  {
    this->logical_expression_.set (x);
  }

  void Algorithm::
  logical_expression (::std::auto_ptr< logical_expression_type > x)
  {
    this->logical_expression_.set (x);
  }

  const Algorithm::comment_type& Algorithm::
  comment () const
  {
    return this->comment_.get ();
  }

  Algorithm::comment_type& Algorithm::
  comment ()
  {
    return this->comment_.get ();
  }

  void Algorithm::
  comment (const comment_type& x)
  {
    this->comment_.set (x);
  }

  void Algorithm::
  comment (::std::auto_ptr< comment_type > x)
  {
    this->comment_.set (x);
  }

  const Algorithm::locked_type& Algorithm::
  locked () const
  {
    return this->locked_.get ();
  }

  Algorithm::locked_type& Algorithm::
  locked ()
  {
    return this->locked_.get ();
  }

  void Algorithm::
  locked (const locked_type& x)
  {
    this->locked_.set (x);
  }

  const Algorithm::mapping_type& Algorithm::
  mapping () const
  {
    return this->mapping_.get ();
  }

  Algorithm::mapping_type& Algorithm::
  mapping ()
  {
    return this->mapping_.get ();
  }

  void Algorithm::
  mapping (const mapping_type& x)
  {
    this->mapping_.set (x);
  }

  void Algorithm::
  mapping (::std::auto_ptr< mapping_type > x)
  {
    this->mapping_.set (x);
  }


  // AlgorithmMapping
  // 

  const AlgorithmMapping::module_type& AlgorithmMapping::
  module () const
  {
    return this->module_.get ();
  }

  AlgorithmMapping::module_type& AlgorithmMapping::
  module ()
  {
    return this->module_.get ();
  }

  void AlgorithmMapping::
  module (const module_type& x)
  {
    this->module_.set (x);
  }

  void AlgorithmMapping::
  module (::std::auto_ptr< module_type > x)
  {
    this->module_.set (x);
  }

  const AlgorithmMapping::index_type& AlgorithmMapping::
  index () const
  {
    return this->index_.get ();
  }

  AlgorithmMapping::index_type& AlgorithmMapping::
  index ()
  {
    return this->index_.get ();
  }

  void AlgorithmMapping::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void AlgorithmMapping::
  index (::std::auto_ptr< index_type > x)
  {
    this->index_.set (x);
  }


  // AlgorithmList
  // 

  const AlgorithmList::algorithm_sequence& AlgorithmList::
  algorithm () const
  {
    return this->algorithm_;
  }

  AlgorithmList::algorithm_sequence& AlgorithmList::
  algorithm ()
  {
    return this->algorithm_;
  }

  void AlgorithmList::
  algorithm (const algorithm_sequence& s)
  {
    this->algorithm_ = s;
  }


  // L1TriggerMenu
  // 

  const L1TriggerMenu::meta_type& L1TriggerMenu::
  meta () const
  {
    return this->meta_.get ();
  }

  L1TriggerMenu::meta_type& L1TriggerMenu::
  meta ()
  {
    return this->meta_.get ();
  }

  void L1TriggerMenu::
  meta (const meta_type& x)
  {
    this->meta_.set (x);
  }

  void L1TriggerMenu::
  meta (::std::auto_ptr< meta_type > x)
  {
    this->meta_.set (x);
  }

  const L1TriggerMenu::conditions_type& L1TriggerMenu::
  conditions () const
  {
    return this->conditions_.get ();
  }

  L1TriggerMenu::conditions_type& L1TriggerMenu::
  conditions ()
  {
    return this->conditions_.get ();
  }

  void L1TriggerMenu::
  conditions (const conditions_type& x)
  {
    this->conditions_.set (x);
  }

  void L1TriggerMenu::
  conditions (::std::auto_ptr< conditions_type > x)
  {
    this->conditions_.set (x);
  }

  const L1TriggerMenu::algorithms_type& L1TriggerMenu::
  algorithms () const
  {
    return this->algorithms_.get ();
  }

  L1TriggerMenu::algorithms_type& L1TriggerMenu::
  algorithms ()
  {
    return this->algorithms_.get ();
  }

  void L1TriggerMenu::
  algorithms (const algorithms_type& x)
  {
    this->algorithms_.set (x);
  }

  void L1TriggerMenu::
  algorithms (::std::auto_ptr< algorithms_type > x)
  {
    this->algorithms_.set (x);
  }
}

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/xml/dom/parsing-source.hxx>

namespace l1t
{
  // UUID
  //

  UUID::
  UUID ()
  : ::xml_schema::string ()
  {
  }

  UUID::
  UUID (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UUID::
  UUID (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UUID::
  UUID (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UUID::
  UUID (const UUID& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  UUID::
  UUID (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  UUID::
  UUID (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  UUID::
  UUID (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  UUID* UUID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UUID (*this, f, c);
  }

  UUID::
  ~UUID ()
  {
  }

  // DateTime
  //

  DateTime::
  DateTime (const ::xml_schema::date_time& _xsd_date_time_base)
  : ::xml_schema::date_time (_xsd_date_time_base)
  {
  }

  DateTime::
  DateTime (const DateTime& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (x, f, c)
  {
  }

  DateTime::
  DateTime (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (e, f, c)
  {
  }

  DateTime::
  DateTime (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (a, f, c)
  {
  }

  DateTime::
  DateTime (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (s, e, f, c)
  {
  }

  DateTime* DateTime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DateTime (*this, f, c);
  }

  DateTime::
  ~DateTime ()
  {
  }

  // Name
  //

  Name::
  Name ()
  : ::xml_schema::string ()
  {
  }

  Name::
  Name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Name::
  Name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Name::
  Name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Name::
  Name (const Name& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Name::
  Name (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Name::
  Name (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Name::
  Name (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Name* Name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Name (*this, f, c);
  }

  Name::
  ~Name ()
  {
  }

  // Comment
  //

  Comment::
  Comment ()
  : ::xml_schema::string ()
  {
  }

  Comment::
  Comment (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Comment::
  Comment (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Comment::
  Comment (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Comment::
  Comment (const Comment& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Comment::
  Comment (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Comment::
  Comment (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Comment::
  Comment (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Comment* Comment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Comment (*this, f, c);
  }

  Comment::
  ~Comment ()
  {
  }

  // MenuName
  //

  MenuName::
  MenuName ()
  : ::l1t::Name ()
  {
  }

  MenuName::
  MenuName (const char* _xsd_string_base)
  : ::l1t::Name (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const ::std::string& _xsd_string_base)
  : ::l1t::Name (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const ::xml_schema::string& _xsd_string_base)
  : ::l1t::Name (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const MenuName& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (x, f, c)
  {
  }

  MenuName::
  MenuName (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (e, f, c)
  {
  }

  MenuName::
  MenuName (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (a, f, c)
  {
  }

  MenuName::
  MenuName (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (s, e, f, c)
  {
  }

  MenuName* MenuName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MenuName (*this, f, c);
  }

  MenuName::
  ~MenuName ()
  {
  }

  // ScaleSet
  //

  ScaleSet::
  ScaleSet ()
  : ::l1t::Name ()
  {
  }

  ScaleSet::
  ScaleSet (const char* _xsd_string_base)
  : ::l1t::Name (_xsd_string_base)
  {
  }

  ScaleSet::
  ScaleSet (const ::std::string& _xsd_string_base)
  : ::l1t::Name (_xsd_string_base)
  {
  }

  ScaleSet::
  ScaleSet (const ::xml_schema::string& _xsd_string_base)
  : ::l1t::Name (_xsd_string_base)
  {
  }

  ScaleSet::
  ScaleSet (const ScaleSet& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (x, f, c)
  {
  }

  ScaleSet::
  ScaleSet (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (e, f, c)
  {
  }

  ScaleSet::
  ScaleSet (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (a, f, c)
  {
  }

  ScaleSet::
  ScaleSet (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::l1t::Name (s, e, f, c)
  {
  }

  ScaleSet* ScaleSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScaleSet (*this, f, c);
  }

  ScaleSet::
  ~ScaleSet ()
  {
  }

  // Version
  //

  Version::
  Version ()
  : ::xml_schema::string ()
  {
  }

  Version::
  Version (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const Version& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Version::
  Version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Version::
  Version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Version::
  Version (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Version* Version::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Version (*this, f, c);
  }

  Version::
  ~Version ()
  {
  }

  // RevisionList
  //

  RevisionList::
  RevisionList ()
  : ::xml_schema::type (),
    revision_ (::xml_schema::flags (), this)
  {
  }

  RevisionList::
  RevisionList (const RevisionList& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    revision_ (x.revision_, f, this)
  {
  }

  RevisionList::
  RevisionList (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    revision_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RevisionList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // revision
      //
      if (n.name () == "revision" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< revision_type > r (
          revision_traits::create (i, f, this));

        this->revision_.push_back (r);
        continue;
      }

      break;
    }
  }

  RevisionList* RevisionList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RevisionList (*this, f, c);
  }

  RevisionList::
  ~RevisionList ()
  {
  }

  // Revision
  //

  Revision::
  Revision (const author_type& author,
            const datetime_type& datetime)
  : ::xml_schema::type (),
    author_ (author, ::xml_schema::flags (), this),
    datetime_ (datetime, ::xml_schema::flags (), this),
    username_ (::xml_schema::flags (), this),
    hostname_ (::xml_schema::flags (), this)
  {
  }

  Revision::
  Revision (const Revision& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    author_ (x.author_, f, this),
    datetime_ (x.datetime_, f, this),
    username_ (x.username_, f, this),
    hostname_ (x.hostname_, f, this)
  {
  }

  Revision::
  Revision (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    author_ (f, this),
    datetime_ (f, this),
    username_ (f, this),
    hostname_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Revision::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // author
      //
      if (n.name () == "author" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< author_type > r (
          author_traits::create (i, f, this));

        if (!author_.present ())
        {
          this->author_.set (r);
          continue;
        }
      }

      // datetime
      //
      if (n.name () == "datetime" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< datetime_type > r (
          datetime_traits::create (i, f, this));

        if (!datetime_.present ())
        {
          this->datetime_.set (r);
          continue;
        }
      }

      break;
    }

    if (!author_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "author",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!datetime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "datetime",
        "http://www.cern.ch/l1t/0.7.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "username" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< username_type > r (
          username_traits::create (i, f, this));

        this->username_.set (r);
        continue;
      }

      if (n.name () == "hostname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< hostname_type > r (
          hostname_traits::create (i, f, this));

        this->hostname_.set (r);
        continue;
      }
    }
  }

  Revision* Revision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Revision (*this, f, c);
  }

  Revision::
  ~Revision ()
  {
  }

  // ComparisonOperator
  //

  ComparisonOperator::
  ComparisonOperator (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ComparisonOperator_convert ();
  }

  ComparisonOperator::
  ComparisonOperator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ComparisonOperator_convert ();
  }

  ComparisonOperator::
  ComparisonOperator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ComparisonOperator_convert ();
  }

  ComparisonOperator* ComparisonOperator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComparisonOperator (*this, f, c);
  }

  ComparisonOperator::value ComparisonOperator::
  _xsd_ComparisonOperator_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ComparisonOperator_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ComparisonOperator_indexes_,
                      _xsd_ComparisonOperator_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_ComparisonOperator_indexes_ + 2 || _xsd_ComparisonOperator_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ComparisonOperator::
  _xsd_ComparisonOperator_literals_[2] =
  {
    "eq",
    "ge"
  };

  const ComparisonOperator::value ComparisonOperator::
  _xsd_ComparisonOperator_indexes_[2] =
  {
    ::l1t::ComparisonOperator::eq,
    ::l1t::ComparisonOperator::ge
  };

  // RelativeBx
  //

  RelativeBx::
  RelativeBx (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  RelativeBx::
  RelativeBx (const RelativeBx& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  RelativeBx* RelativeBx::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelativeBx (*this, f, c);
  }

  RelativeBx::
  ~RelativeBx ()
  {
  }

  // ConditionName
  //

  ConditionName::
  ConditionName ()
  : ::xml_schema::string ()
  {
  }

  ConditionName::
  ConditionName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ConditionName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ConditionName* ConditionName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionName (*this, f, c);
  }

  ConditionName::
  ~ConditionName ()
  {
  }

  // ConditionType
  //

  ConditionType::
  ConditionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ConditionType_convert ();
  }

  ConditionType::
  ConditionType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ConditionType_convert ();
  }

  ConditionType::
  ConditionType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ConditionType_convert ();
  }

  ConditionType* ConditionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionType (*this, f, c);
  }

  ConditionType::value ConditionType::
  _xsd_ConditionType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ConditionType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ConditionType_indexes_,
                      _xsd_ConditionType_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_ConditionType_indexes_ + 5 || _xsd_ConditionType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ConditionType::
  _xsd_ConditionType_literals_[5] =
  {
    "single",
    "double",
    "triple",
    "quad",
    "double_wsc"
  };

  const ConditionType::value ConditionType::
  _xsd_ConditionType_indexes_[5] =
  {
    ::l1t::ConditionType::double_,
    ::l1t::ConditionType::double_wsc,
    ::l1t::ConditionType::quad,
    ::l1t::ConditionType::single,
    ::l1t::ConditionType::triple
  };

  // CalorimeterObjectType
  //

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType* CalorimeterObjectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectType (*this, f, c);
  }

  CalorimeterObjectType::value CalorimeterObjectType::
  _xsd_CalorimeterObjectType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalorimeterObjectType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CalorimeterObjectType_indexes_,
                      _xsd_CalorimeterObjectType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CalorimeterObjectType_indexes_ + 3 || _xsd_CalorimeterObjectType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalorimeterObjectType::
  _xsd_CalorimeterObjectType_literals_[3] =
  {
    "eg",
    "jet",
    "tau"
  };

  const CalorimeterObjectType::value CalorimeterObjectType::
  _xsd_CalorimeterObjectType_indexes_[3] =
  {
    ::l1t::CalorimeterObjectType::eg,
    ::l1t::CalorimeterObjectType::jet,
    ::l1t::CalorimeterObjectType::tau
  };

  // MuonRequstedCharge
  //

  MuonRequstedCharge::
  MuonRequstedCharge (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_MuonRequstedCharge_convert ();
  }

  MuonRequstedCharge::
  MuonRequstedCharge (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_MuonRequstedCharge_convert ();
  }

  MuonRequstedCharge::
  MuonRequstedCharge (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_MuonRequstedCharge_convert ();
  }

  MuonRequstedCharge* MuonRequstedCharge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonRequstedCharge (*this, f, c);
  }

  MuonRequstedCharge::value MuonRequstedCharge::
  _xsd_MuonRequstedCharge_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MuonRequstedCharge_literals_);
    const value* i (::std::lower_bound (
                      _xsd_MuonRequstedCharge_indexes_,
                      _xsd_MuonRequstedCharge_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_MuonRequstedCharge_indexes_ + 3 || _xsd_MuonRequstedCharge_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MuonRequstedCharge::
  _xsd_MuonRequstedCharge_literals_[3] =
  {
    "pos",
    "neg",
    "ign"
  };

  const MuonRequstedCharge::value MuonRequstedCharge::
  _xsd_MuonRequstedCharge_indexes_[3] =
  {
    ::l1t::MuonRequstedCharge::ign,
    ::l1t::MuonRequstedCharge::neg,
    ::l1t::MuonRequstedCharge::pos
  };

  // MuonRequstedChargeCorr
  //

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_MuonRequstedChargeCorr_convert ();
  }

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_MuonRequstedChargeCorr_convert ();
  }

  MuonRequstedChargeCorr::
  MuonRequstedChargeCorr (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_MuonRequstedChargeCorr_convert ();
  }

  MuonRequstedChargeCorr* MuonRequstedChargeCorr::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonRequstedChargeCorr (*this, f, c);
  }

  MuonRequstedChargeCorr::value MuonRequstedChargeCorr::
  _xsd_MuonRequstedChargeCorr_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MuonRequstedChargeCorr_literals_);
    const value* i (::std::lower_bound (
                      _xsd_MuonRequstedChargeCorr_indexes_,
                      _xsd_MuonRequstedChargeCorr_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_MuonRequstedChargeCorr_indexes_ + 3 || _xsd_MuonRequstedChargeCorr_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MuonRequstedChargeCorr::
  _xsd_MuonRequstedChargeCorr_literals_[3] =
  {
    "ls",
    "os",
    "ig"
  };

  const MuonRequstedChargeCorr::value MuonRequstedChargeCorr::
  _xsd_MuonRequstedChargeCorr_indexes_[3] =
  {
    ::l1t::MuonRequstedChargeCorr::ig,
    ::l1t::MuonRequstedChargeCorr::ls,
    ::l1t::MuonRequstedChargeCorr::os
  };

  // EnergySumsObjectType
  //

  EnergySumsObjectType::
  EnergySumsObjectType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_EnergySumsObjectType_convert ();
  }

  EnergySumsObjectType::
  EnergySumsObjectType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_EnergySumsObjectType_convert ();
  }

  EnergySumsObjectType::
  EnergySumsObjectType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_EnergySumsObjectType_convert ();
  }

  EnergySumsObjectType* EnergySumsObjectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnergySumsObjectType (*this, f, c);
  }

  EnergySumsObjectType::value EnergySumsObjectType::
  _xsd_EnergySumsObjectType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EnergySumsObjectType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_EnergySumsObjectType_indexes_,
                      _xsd_EnergySumsObjectType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_EnergySumsObjectType_indexes_ + 4 || _xsd_EnergySumsObjectType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const EnergySumsObjectType::
  _xsd_EnergySumsObjectType_literals_[4] =
  {
    "ett",
    "etm",
    "htt",
    "htm"
  };

  const EnergySumsObjectType::value EnergySumsObjectType::
  _xsd_EnergySumsObjectType_indexes_[4] =
  {
    ::l1t::EnergySumsObjectType::etm,
    ::l1t::EnergySumsObjectType::ett,
    ::l1t::EnergySumsObjectType::htm,
    ::l1t::EnergySumsObjectType::htt
  };

  // EtThreshold
  //

  EtThreshold::
  EtThreshold (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  EtThreshold::
  EtThreshold (const EtThreshold& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  EtThreshold::
  EtThreshold (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  EtThreshold::
  EtThreshold (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  EtThreshold::
  EtThreshold (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  EtThreshold* EtThreshold::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EtThreshold (*this, f, c);
  }

  EtThreshold::
  ~EtThreshold ()
  {
  }

  // PtThreshold
  //

  PtThreshold::
  PtThreshold (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  PtThreshold::
  PtThreshold (const PtThreshold& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  PtThreshold::
  PtThreshold (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  PtThreshold::
  PtThreshold (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  PtThreshold::
  PtThreshold (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  PtThreshold* PtThreshold::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PtThreshold (*this, f, c);
  }

  PtThreshold::
  ~PtThreshold ()
  {
  }

  // AlgorithmName
  //

  AlgorithmName::
  AlgorithmName ()
  : ::xml_schema::string ()
  {
  }

  AlgorithmName::
  AlgorithmName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const AlgorithmName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  AlgorithmName* AlgorithmName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmName (*this, f, c);
  }

  AlgorithmName::
  ~AlgorithmName ()
  {
  }

  // AlgorithmIndex
  //

  AlgorithmIndex::
  AlgorithmIndex (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const AlgorithmIndex& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  AlgorithmIndex* AlgorithmIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmIndex (*this, f, c);
  }

  AlgorithmIndex::
  ~AlgorithmIndex ()
  {
  }

  // LogicalExpression
  //

  LogicalExpression::
  LogicalExpression ()
  : ::xml_schema::string ()
  {
  }

  LogicalExpression::
  LogicalExpression (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LogicalExpression::
  LogicalExpression (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LogicalExpression::
  LogicalExpression (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LogicalExpression::
  LogicalExpression (const LogicalExpression& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  LogicalExpression::
  LogicalExpression (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  LogicalExpression::
  LogicalExpression (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  LogicalExpression::
  LogicalExpression (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  LogicalExpression* LogicalExpression::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalExpression (*this, f, c);
  }

  LogicalExpression::
  ~LogicalExpression ()
  {
  }

  // AlgorithmMappedModule
  //

  AlgorithmMappedModule::
  AlgorithmMappedModule (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  AlgorithmMappedModule::
  AlgorithmMappedModule (const AlgorithmMappedModule& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  AlgorithmMappedModule::
  AlgorithmMappedModule (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  AlgorithmMappedModule::
  AlgorithmMappedModule (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  AlgorithmMappedModule::
  AlgorithmMappedModule (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  AlgorithmMappedModule* AlgorithmMappedModule::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmMappedModule (*this, f, c);
  }

  AlgorithmMappedModule::
  ~AlgorithmMappedModule ()
  {
  }

  // AlgorithmMappedIndex
  //

  AlgorithmMappedIndex::
  AlgorithmMappedIndex (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::l1t::AlgorithmIndex (_xsd_unsigned_int_base)
  {
  }

  AlgorithmMappedIndex::
  AlgorithmMappedIndex (const AlgorithmMappedIndex& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::AlgorithmIndex (x, f, c)
  {
  }

  AlgorithmMappedIndex::
  AlgorithmMappedIndex (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::AlgorithmIndex (e, f, c)
  {
  }

  AlgorithmMappedIndex::
  AlgorithmMappedIndex (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::AlgorithmIndex (a, f, c)
  {
  }

  AlgorithmMappedIndex::
  AlgorithmMappedIndex (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::AlgorithmIndex (s, e, f, c)
  {
  }

  AlgorithmMappedIndex* AlgorithmMappedIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmMappedIndex (*this, f, c);
  }

  AlgorithmMappedIndex::
  ~AlgorithmMappedIndex ()
  {
  }

  // Meta
  //

  Meta::
  Meta (const name_type& name,
        const datetime_type& datetime,
        const uuid_menu_type& uuid_menu,
        const comment_type& comment,
        const scale_set_type& scale_set,
        const revisions_type& revisions)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    datetime_ (datetime, ::xml_schema::flags (), this),
    uuid_menu_ (uuid_menu, ::xml_schema::flags (), this),
    uuid_firmware_ (::xml_schema::flags (), this),
    comment_ (comment, ::xml_schema::flags (), this),
    scale_set_ (scale_set, ::xml_schema::flags (), this),
    editor_version_ (::xml_schema::flags (), this),
    revisions_ (revisions, ::xml_schema::flags (), this)
  {
  }

  Meta::
  Meta (const name_type& name,
        const datetime_type& datetime,
        const uuid_menu_type& uuid_menu,
        const comment_type& comment,
        const scale_set_type& scale_set,
        ::std::auto_ptr< revisions_type >& revisions)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    datetime_ (datetime, ::xml_schema::flags (), this),
    uuid_menu_ (uuid_menu, ::xml_schema::flags (), this),
    uuid_firmware_ (::xml_schema::flags (), this),
    comment_ (comment, ::xml_schema::flags (), this),
    scale_set_ (scale_set, ::xml_schema::flags (), this),
    editor_version_ (::xml_schema::flags (), this),
    revisions_ (revisions, ::xml_schema::flags (), this)
  {
  }

  Meta::
  Meta (const Meta& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    datetime_ (x.datetime_, f, this),
    uuid_menu_ (x.uuid_menu_, f, this),
    uuid_firmware_ (x.uuid_firmware_, f, this),
    comment_ (x.comment_, f, this),
    scale_set_ (x.scale_set_, f, this),
    editor_version_ (x.editor_version_, f, this),
    revisions_ (x.revisions_, f, this)
  {
  }

  Meta::
  Meta (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    datetime_ (f, this),
    uuid_menu_ (f, this),
    uuid_firmware_ (f, this),
    comment_ (f, this),
    scale_set_ (f, this),
    editor_version_ (f, this),
    revisions_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Meta::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // datetime
      //
      if (n.name () == "datetime" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< datetime_type > r (
          datetime_traits::create (i, f, this));

        if (!datetime_.present ())
        {
          this->datetime_.set (r);
          continue;
        }
      }

      // uuid_menu
      //
      if (n.name () == "uuid_menu" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< uuid_menu_type > r (
          uuid_menu_traits::create (i, f, this));

        if (!uuid_menu_.present ())
        {
          this->uuid_menu_.set (r);
          continue;
        }
      }

      // uuid_firmware
      //
      if (n.name () == "uuid_firmware" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< uuid_firmware_type > r (
          uuid_firmware_traits::create (i, f, this));

        if (!this->uuid_firmware_)
        {
          this->uuid_firmware_.set (r);
          continue;
        }
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        if (!comment_.present ())
        {
          this->comment_.set (r);
          continue;
        }
      }

      // scale_set
      //
      if (n.name () == "scale_set" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< scale_set_type > r (
          scale_set_traits::create (i, f, this));

        if (!scale_set_.present ())
        {
          this->scale_set_.set (r);
          continue;
        }
      }

      // editor_version
      //
      if (n.name () == "editor_version" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< editor_version_type > r (
          editor_version_traits::create (i, f, this));

        if (!this->editor_version_)
        {
          this->editor_version_.set (r);
          continue;
        }
      }

      // revisions
      //
      if (n.name () == "revisions" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< revisions_type > r (
          revisions_traits::create (i, f, this));

        if (!revisions_.present ())
        {
          this->revisions_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!datetime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "datetime",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!uuid_menu_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uuid_menu",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!comment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comment",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!scale_set_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scale_set",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!revisions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "revisions",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  Meta* Meta::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Meta (*this, f, c);
  }

  Meta::
  ~Meta ()
  {
  }

  // ConditionList
  //

  ConditionList::
  ConditionList ()
  : ::xml_schema::type (),
    condCalorimeter_ (::xml_schema::flags (), this),
    condMuon_ (::xml_schema::flags (), this),
    condEnergySums_ (::xml_schema::flags (), this)
  {
  }

  ConditionList::
  ConditionList (const ConditionList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    condCalorimeter_ (x.condCalorimeter_, f, this),
    condMuon_ (x.condMuon_, f, this),
    condEnergySums_ (x.condEnergySums_, f, this)
  {
  }

  ConditionList::
  ConditionList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    condCalorimeter_ (f, this),
    condMuon_ (f, this),
    condEnergySums_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConditionList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condCalorimeter
      //
      if (n.name () == "condCalorimeter" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< condCalorimeter_type > r (
          condCalorimeter_traits::create (i, f, this));

        this->condCalorimeter_.push_back (r);
        continue;
      }

      // condMuon
      //
      if (n.name () == "condMuon" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< condMuon_type > r (
          condMuon_traits::create (i, f, this));

        this->condMuon_.push_back (r);
        continue;
      }

      // condEnergySums
      //
      if (n.name () == "condEnergySums" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< condEnergySums_type > r (
          condEnergySums_traits::create (i, f, this));

        this->condEnergySums_.push_back (r);
        continue;
      }

      break;
    }
  }

  ConditionList* ConditionList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionList (*this, f, c);
  }

  ConditionList::
  ~ConditionList ()
  {
  }

  // Condition
  //

  Condition::
  Condition (const uid_type& uid,
             const name_type& name,
             const comment_type& comment,
             const locked_type& locked)
  : ::xml_schema::type (),
    uid_ (uid, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    comment_ (comment, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this)
  {
  }

  Condition::
  Condition (const Condition& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    uid_ (x.uid_, f, this),
    name_ (x.name_, f, this),
    comment_ (x.comment_, f, this),
    locked_ (x.locked_, f, this)
  {
  }

  Condition::
  Condition (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    uid_ (f, this),
    name_ (f, this),
    comment_ (f, this),
    locked_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Condition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // uid
      //
      if (n.name () == "uid" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< uid_type > r (
          uid_traits::create (i, f, this));

        if (!uid_.present ())
        {
          this->uid_.set (r);
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        if (!comment_.present ())
        {
          this->comment_.set (r);
          continue;
        }
      }

      // locked
      //
      if (n.name () == "locked" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        if (!locked_.present ())
        {
          this->locked_.set (locked_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!uid_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uid",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!comment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comment",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!locked_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locked",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  Condition* Condition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Condition (*this, f, c);
  }

  Condition::
  ~Condition ()
  {
  }

  // Window
  //

  Window::
  Window (const lower_type& lower,
          const upper_type& upper)
  : ::xml_schema::type (),
    lower_ (lower, ::xml_schema::flags (), this),
    upper_ (upper, ::xml_schema::flags (), this)
  {
  }

  Window::
  Window (const Window& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lower_ (x.lower_, f, this),
    upper_ (x.upper_, f, this)
  {
  }

  Window::
  Window (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lower_ (f, this),
    upper_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Window::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lower
      //
      if (n.name () == "lower" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        if (!lower_.present ())
        {
          this->lower_.set (lower_traits::create (i, f, this));
          continue;
        }
      }

      // upper
      //
      if (n.name () == "upper" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        if (!upper_.present ())
        {
          this->upper_.set (upper_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!lower_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lower",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!upper_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "upper",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  Window* Window::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Window (*this, f, c);
  }

  Window::
  ~Window ()
  {
  }

  // DeltaRequirement
  //

  DeltaRequirement::
  DeltaRequirement (const deltaPhiRange_type& deltaPhiRange,
                    const deltaEtaRange_type& deltaEtaRange)
  : ::xml_schema::type (),
    deltaPhiRange_ (deltaPhiRange, ::xml_schema::flags (), this),
    deltaEtaRange_ (deltaEtaRange, ::xml_schema::flags (), this)
  {
  }

  DeltaRequirement::
  DeltaRequirement (::std::auto_ptr< deltaPhiRange_type >& deltaPhiRange,
                    ::std::auto_ptr< deltaEtaRange_type >& deltaEtaRange)
  : ::xml_schema::type (),
    deltaPhiRange_ (deltaPhiRange, ::xml_schema::flags (), this),
    deltaEtaRange_ (deltaEtaRange, ::xml_schema::flags (), this)
  {
  }

  DeltaRequirement::
  DeltaRequirement (const DeltaRequirement& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    deltaPhiRange_ (x.deltaPhiRange_, f, this),
    deltaEtaRange_ (x.deltaEtaRange_, f, this)
  {
  }

  DeltaRequirement::
  DeltaRequirement (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    deltaPhiRange_ (f, this),
    deltaEtaRange_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeltaRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deltaPhiRange
      //
      if (n.name () == "deltaPhiRange" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< deltaPhiRange_type > r (
          deltaPhiRange_traits::create (i, f, this));

        if (!deltaPhiRange_.present ())
        {
          this->deltaPhiRange_.set (r);
          continue;
        }
      }

      // deltaEtaRange
      //
      if (n.name () == "deltaEtaRange" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< deltaEtaRange_type > r (
          deltaEtaRange_traits::create (i, f, this));

        if (!deltaEtaRange_.present ())
        {
          this->deltaEtaRange_.set (r);
          continue;
        }
      }

      break;
    }

    if (!deltaPhiRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deltaPhiRange",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!deltaEtaRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deltaEtaRange",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  DeltaRequirement* DeltaRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeltaRequirement (*this, f, c);
  }

  DeltaRequirement::
  ~DeltaRequirement ()
  {
  }

  // CalorimeterIsolationLUT
  //

  CalorimeterIsolationLUT::
  CalorimeterIsolationLUT ()
  : ::xml_schema::type (),
    isolation_ (::xml_schema::flags (), this)
  {
  }

  CalorimeterIsolationLUT::
  CalorimeterIsolationLUT (const CalorimeterIsolationLUT& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    isolation_ (x.isolation_, f, this)
  {
  }

  CalorimeterIsolationLUT::
  CalorimeterIsolationLUT (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    isolation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterIsolationLUT::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // isolation
      //
      if (n.name () == "isolation" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        this->isolation_.push_back (isolation_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  CalorimeterIsolationLUT* CalorimeterIsolationLUT::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterIsolationLUT (*this, f, c);
  }

  CalorimeterIsolationLUT::
  ~CalorimeterIsolationLUT ()
  {
  }

  // CalorimeterObjectRequirement
  //

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const etThreshold_type& etThreshold,
                                const isolationLut_type& isolationLut)
  : ::xml_schema::type (),
    etThreshold_ (etThreshold, ::xml_schema::flags (), this),
    phiWindow_ (::xml_schema::flags (), this),
    etaWindow_ (::xml_schema::flags (), this),
    isolationLut_ (isolationLut, ::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const etThreshold_type& etThreshold,
                                ::std::auto_ptr< isolationLut_type >& isolationLut)
  : ::xml_schema::type (),
    etThreshold_ (etThreshold, ::xml_schema::flags (), this),
    phiWindow_ (::xml_schema::flags (), this),
    etaWindow_ (::xml_schema::flags (), this),
    isolationLut_ (isolationLut, ::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const CalorimeterObjectRequirement& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    etThreshold_ (x.etThreshold_, f, this),
    phiWindow_ (x.phiWindow_, f, this),
    etaWindow_ (x.etaWindow_, f, this),
    isolationLut_ (x.isolationLut_, f, this)
  {
  }

  CalorimeterObjectRequirement::
  CalorimeterObjectRequirement (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    etThreshold_ (f, this),
    phiWindow_ (f, this),
    etaWindow_ (f, this),
    isolationLut_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterObjectRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // etThreshold
      //
      if (n.name () == "etThreshold" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< etThreshold_type > r (
          etThreshold_traits::create (i, f, this));

        if (!etThreshold_.present ())
        {
          this->etThreshold_.set (r);
          continue;
        }
      }

      // phiWindow
      //
      if (n.name () == "phiWindow" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< phiWindow_type > r (
          phiWindow_traits::create (i, f, this));

        this->phiWindow_.push_back (r);
        continue;
      }

      // etaWindow
      //
      if (n.name () == "etaWindow" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< etaWindow_type > r (
          etaWindow_traits::create (i, f, this));

        this->etaWindow_.push_back (r);
        continue;
      }

      // isolationLut
      //
      if (n.name () == "isolationLut" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< isolationLut_type > r (
          isolationLut_traits::create (i, f, this));

        if (!isolationLut_.present ())
        {
          this->isolationLut_.set (r);
          continue;
        }
      }

      break;
    }

    if (!etThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etThreshold",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!isolationLut_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "isolationLut",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  CalorimeterObjectRequirement* CalorimeterObjectRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectRequirement (*this, f, c);
  }

  CalorimeterObjectRequirement::
  ~CalorimeterObjectRequirement ()
  {
  }

  // CalorimeterObjectRequirements
  //

  CalorimeterObjectRequirements::
  CalorimeterObjectRequirements ()
  : ::xml_schema::type (),
    objectRequirement_ (::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectRequirements::
  CalorimeterObjectRequirements (const CalorimeterObjectRequirements& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    objectRequirement_ (x.objectRequirement_, f, this)
  {
  }

  CalorimeterObjectRequirements::
  CalorimeterObjectRequirements (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    objectRequirement_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterObjectRequirements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // objectRequirement
      //
      if (n.name () == "objectRequirement" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectRequirement_type > r (
          objectRequirement_traits::create (i, f, this));

        this->objectRequirement_.push_back (r);
        continue;
      }

      break;
    }
  }

  CalorimeterObjectRequirements* CalorimeterObjectRequirements::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectRequirements (*this, f, c);
  }

  CalorimeterObjectRequirements::
  ~CalorimeterObjectRequirements ()
  {
  }

  // CalorimeterCondition
  //

  CalorimeterCondition::
  CalorimeterCondition (const uid_type& uid,
                        const name_type& name,
                        const comment_type& comment,
                        const locked_type& locked,
                        const type_type& type,
                        const comparison_operator_type& comparison_operator,
                        const objectType_type& objectType,
                        const objectRequirements_type& objectRequirements,
                        const relativeBx_type& relativeBx)
  : ::l1t::Condition (uid,
                      name,
                      comment,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    comparison_operator_ (comparison_operator, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectRequirements_ (objectRequirements, ::xml_schema::flags (), this),
    deltaRequirement_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const uid_type& uid,
                        const name_type& name,
                        const comment_type& comment,
                        const locked_type& locked,
                        const type_type& type,
                        const comparison_operator_type& comparison_operator,
                        const objectType_type& objectType,
                        ::std::auto_ptr< objectRequirements_type >& objectRequirements,
                        const relativeBx_type& relativeBx)
  : ::l1t::Condition (uid,
                      name,
                      comment,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    comparison_operator_ (comparison_operator, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectRequirements_ (objectRequirements, ::xml_schema::flags (), this),
    deltaRequirement_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const CalorimeterCondition& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c),
    type_ (x.type_, f, this),
    comparison_operator_ (x.comparison_operator_, f, this),
    objectType_ (x.objectType_, f, this),
    objectRequirements_ (x.objectRequirements_, f, this),
    deltaRequirement_ (x.deltaRequirement_, f, this),
    relativeBx_ (x.relativeBx_, f, this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    comparison_operator_ (f, this),
    objectType_ (f, this),
    objectRequirements_ (f, this),
    deltaRequirement_ (f, this),
    relativeBx_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterCondition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::l1t::Condition::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // comparison_operator
      //
      if (n.name () == "comparison_operator" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< comparison_operator_type > r (
          comparison_operator_traits::create (i, f, this));

        if (!comparison_operator_.present ())
        {
          this->comparison_operator_.set (r);
          continue;
        }
      }

      // objectType
      //
      if (n.name () == "objectType" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectType_type > r (
          objectType_traits::create (i, f, this));

        if (!objectType_.present ())
        {
          this->objectType_.set (r);
          continue;
        }
      }

      // objectRequirements
      //
      if (n.name () == "objectRequirements" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectRequirements_type > r (
          objectRequirements_traits::create (i, f, this));

        if (!objectRequirements_.present ())
        {
          this->objectRequirements_.set (r);
          continue;
        }
      }

      // deltaRequirement
      //
      if (n.name () == "deltaRequirement" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< deltaRequirement_type > r (
          deltaRequirement_traits::create (i, f, this));

        if (!this->deltaRequirement_)
        {
          this->deltaRequirement_.set (r);
          continue;
        }
      }

      // relativeBx
      //
      if (n.name () == "relativeBx" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< relativeBx_type > r (
          relativeBx_traits::create (i, f, this));

        if (!relativeBx_.present ())
        {
          this->relativeBx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!comparison_operator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comparison_operator",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!objectType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectType",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!objectRequirements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectRequirements",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!relativeBx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeBx",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  CalorimeterCondition* CalorimeterCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterCondition (*this, f, c);
  }

  CalorimeterCondition::
  ~CalorimeterCondition ()
  {
  }

  // MuonObjectRequirement
  //

  MuonObjectRequirement::
  MuonObjectRequirement (const ptThreshold_type& ptThreshold,
                         const requestedCharge_type& requestedCharge,
                         const qualityLut_type& qualityLut,
                         const isolationLut_type& isolationLut)
  : ::xml_schema::type (),
    ptThreshold_ (ptThreshold, ::xml_schema::flags (), this),
    phiWindow_ (::xml_schema::flags (), this),
    etaWindow_ (::xml_schema::flags (), this),
    requestedCharge_ (requestedCharge, ::xml_schema::flags (), this),
    qualityLut_ (qualityLut, ::xml_schema::flags (), this),
    isolationLut_ (isolationLut, ::xml_schema::flags (), this)
  {
  }

  MuonObjectRequirement::
  MuonObjectRequirement (const ptThreshold_type& ptThreshold,
                         const requestedCharge_type& requestedCharge,
                         ::std::auto_ptr< qualityLut_type >& qualityLut,
                         ::std::auto_ptr< isolationLut_type >& isolationLut)
  : ::xml_schema::type (),
    ptThreshold_ (ptThreshold, ::xml_schema::flags (), this),
    phiWindow_ (::xml_schema::flags (), this),
    etaWindow_ (::xml_schema::flags (), this),
    requestedCharge_ (requestedCharge, ::xml_schema::flags (), this),
    qualityLut_ (qualityLut, ::xml_schema::flags (), this),
    isolationLut_ (isolationLut, ::xml_schema::flags (), this)
  {
  }

  MuonObjectRequirement::
  MuonObjectRequirement (const MuonObjectRequirement& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ptThreshold_ (x.ptThreshold_, f, this),
    phiWindow_ (x.phiWindow_, f, this),
    etaWindow_ (x.etaWindow_, f, this),
    requestedCharge_ (x.requestedCharge_, f, this),
    qualityLut_ (x.qualityLut_, f, this),
    isolationLut_ (x.isolationLut_, f, this)
  {
  }

  MuonObjectRequirement::
  MuonObjectRequirement (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ptThreshold_ (f, this),
    phiWindow_ (f, this),
    etaWindow_ (f, this),
    requestedCharge_ (f, this),
    qualityLut_ (f, this),
    isolationLut_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuonObjectRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ptThreshold
      //
      if (n.name () == "ptThreshold" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< ptThreshold_type > r (
          ptThreshold_traits::create (i, f, this));

        if (!ptThreshold_.present ())
        {
          this->ptThreshold_.set (r);
          continue;
        }
      }

      // phiWindow
      //
      if (n.name () == "phiWindow" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< phiWindow_type > r (
          phiWindow_traits::create (i, f, this));

        this->phiWindow_.push_back (r);
        continue;
      }

      // etaWindow
      //
      if (n.name () == "etaWindow" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< etaWindow_type > r (
          etaWindow_traits::create (i, f, this));

        this->etaWindow_.push_back (r);
        continue;
      }

      // requestedCharge
      //
      if (n.name () == "requestedCharge" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< requestedCharge_type > r (
          requestedCharge_traits::create (i, f, this));

        if (!requestedCharge_.present ())
        {
          this->requestedCharge_.set (r);
          continue;
        }
      }

      // qualityLut
      //
      if (n.name () == "qualityLut" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< qualityLut_type > r (
          qualityLut_traits::create (i, f, this));

        if (!qualityLut_.present ())
        {
          this->qualityLut_.set (r);
          continue;
        }
      }

      // isolationLut
      //
      if (n.name () == "isolationLut" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< isolationLut_type > r (
          isolationLut_traits::create (i, f, this));

        if (!isolationLut_.present ())
        {
          this->isolationLut_.set (r);
          continue;
        }
      }

      break;
    }

    if (!ptThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ptThreshold",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!requestedCharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "requestedCharge",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!qualityLut_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "qualityLut",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!isolationLut_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "isolationLut",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  MuonObjectRequirement* MuonObjectRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonObjectRequirement (*this, f, c);
  }

  MuonObjectRequirement::
  ~MuonObjectRequirement ()
  {
  }

  // MuonObjectRequirements
  //

  MuonObjectRequirements::
  MuonObjectRequirements ()
  : ::xml_schema::type (),
    objectRequirement_ (::xml_schema::flags (), this)
  {
  }

  MuonObjectRequirements::
  MuonObjectRequirements (const MuonObjectRequirements& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    objectRequirement_ (x.objectRequirement_, f, this)
  {
  }

  MuonObjectRequirements::
  MuonObjectRequirements (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    objectRequirement_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuonObjectRequirements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // objectRequirement
      //
      if (n.name () == "objectRequirement" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectRequirement_type > r (
          objectRequirement_traits::create (i, f, this));

        this->objectRequirement_.push_back (r);
        continue;
      }

      break;
    }
  }

  MuonObjectRequirements* MuonObjectRequirements::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonObjectRequirements (*this, f, c);
  }

  MuonObjectRequirements::
  ~MuonObjectRequirements ()
  {
  }

  // MuonQualityLUT
  //

  MuonQualityLUT::
  MuonQualityLUT ()
  : ::xml_schema::type (),
    quality_ (::xml_schema::flags (), this)
  {
  }

  MuonQualityLUT::
  MuonQualityLUT (const MuonQualityLUT& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quality_ (x.quality_, f, this)
  {
  }

  MuonQualityLUT::
  MuonQualityLUT (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quality_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuonQualityLUT::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quality
      //
      if (n.name () == "quality" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        this->quality_.push_back (quality_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  MuonQualityLUT* MuonQualityLUT::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonQualityLUT (*this, f, c);
  }

  MuonQualityLUT::
  ~MuonQualityLUT ()
  {
  }

  // MuonIsolationLUT
  //

  MuonIsolationLUT::
  MuonIsolationLUT ()
  : ::xml_schema::type (),
    isolation_ (::xml_schema::flags (), this)
  {
  }

  MuonIsolationLUT::
  MuonIsolationLUT (const MuonIsolationLUT& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    isolation_ (x.isolation_, f, this)
  {
  }

  MuonIsolationLUT::
  MuonIsolationLUT (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    isolation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuonIsolationLUT::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // isolation
      //
      if (n.name () == "isolation" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        this->isolation_.push_back (isolation_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  MuonIsolationLUT* MuonIsolationLUT::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonIsolationLUT (*this, f, c);
  }

  MuonIsolationLUT::
  ~MuonIsolationLUT ()
  {
  }

  // MuonCondition
  //

  MuonCondition::
  MuonCondition (const uid_type& uid,
                 const name_type& name,
                 const comment_type& comment,
                 const locked_type& locked,
                 const type_type& type,
                 const comparison_operator_type& comparison_operator,
                 const objectRequirements_type& objectRequirements,
                 const requestedChargeCorr_type& requestedChargeCorr,
                 const relativeBx_type& relativeBx)
  : ::l1t::Condition (uid,
                      name,
                      comment,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    comparison_operator_ (comparison_operator, ::xml_schema::flags (), this),
    objectRequirements_ (objectRequirements, ::xml_schema::flags (), this),
    requestedChargeCorr_ (requestedChargeCorr, ::xml_schema::flags (), this),
    deltaRequirement_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  MuonCondition::
  MuonCondition (const uid_type& uid,
                 const name_type& name,
                 const comment_type& comment,
                 const locked_type& locked,
                 const type_type& type,
                 const comparison_operator_type& comparison_operator,
                 ::std::auto_ptr< objectRequirements_type >& objectRequirements,
                 const requestedChargeCorr_type& requestedChargeCorr,
                 const relativeBx_type& relativeBx)
  : ::l1t::Condition (uid,
                      name,
                      comment,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    comparison_operator_ (comparison_operator, ::xml_schema::flags (), this),
    objectRequirements_ (objectRequirements, ::xml_schema::flags (), this),
    requestedChargeCorr_ (requestedChargeCorr, ::xml_schema::flags (), this),
    deltaRequirement_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  MuonCondition::
  MuonCondition (const MuonCondition& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c),
    type_ (x.type_, f, this),
    comparison_operator_ (x.comparison_operator_, f, this),
    objectRequirements_ (x.objectRequirements_, f, this),
    requestedChargeCorr_ (x.requestedChargeCorr_, f, this),
    deltaRequirement_ (x.deltaRequirement_, f, this),
    relativeBx_ (x.relativeBx_, f, this)
  {
  }

  MuonCondition::
  MuonCondition (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::l1t::Condition (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    comparison_operator_ (f, this),
    objectRequirements_ (f, this),
    requestedChargeCorr_ (f, this),
    deltaRequirement_ (f, this),
    relativeBx_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuonCondition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::l1t::Condition::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // comparison_operator
      //
      if (n.name () == "comparison_operator" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< comparison_operator_type > r (
          comparison_operator_traits::create (i, f, this));

        if (!comparison_operator_.present ())
        {
          this->comparison_operator_.set (r);
          continue;
        }
      }

      // objectRequirements
      //
      if (n.name () == "objectRequirements" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectRequirements_type > r (
          objectRequirements_traits::create (i, f, this));

        if (!objectRequirements_.present ())
        {
          this->objectRequirements_.set (r);
          continue;
        }
      }

      // requestedChargeCorr
      //
      if (n.name () == "requestedChargeCorr" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< requestedChargeCorr_type > r (
          requestedChargeCorr_traits::create (i, f, this));

        if (!requestedChargeCorr_.present ())
        {
          this->requestedChargeCorr_.set (r);
          continue;
        }
      }

      // deltaRequirement
      //
      if (n.name () == "deltaRequirement" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< deltaRequirement_type > r (
          deltaRequirement_traits::create (i, f, this));

        if (!this->deltaRequirement_)
        {
          this->deltaRequirement_.set (r);
          continue;
        }
      }

      // relativeBx
      //
      if (n.name () == "relativeBx" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< relativeBx_type > r (
          relativeBx_traits::create (i, f, this));

        if (!relativeBx_.present ())
        {
          this->relativeBx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!comparison_operator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comparison_operator",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!objectRequirements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectRequirements",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!requestedChargeCorr_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "requestedChargeCorr",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!relativeBx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeBx",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  MuonCondition* MuonCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonCondition (*this, f, c);
  }

  MuonCondition::
  ~MuonCondition ()
  {
  }

  // EnergySumsObjectRequirement
  //

  EnergySumsObjectRequirement::
  EnergySumsObjectRequirement (const etThreshold_type& etThreshold)
  : ::xml_schema::type (),
    etThreshold_ (etThreshold, ::xml_schema::flags (), this),
    phiWindow_ (::xml_schema::flags (), this)
  {
  }

  EnergySumsObjectRequirement::
  EnergySumsObjectRequirement (const EnergySumsObjectRequirement& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    etThreshold_ (x.etThreshold_, f, this),
    phiWindow_ (x.phiWindow_, f, this)
  {
  }

  EnergySumsObjectRequirement::
  EnergySumsObjectRequirement (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    etThreshold_ (f, this),
    phiWindow_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void EnergySumsObjectRequirement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // etThreshold
      //
      if (n.name () == "etThreshold" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< etThreshold_type > r (
          etThreshold_traits::create (i, f, this));

        if (!etThreshold_.present ())
        {
          this->etThreshold_.set (r);
          continue;
        }
      }

      // phiWindow
      //
      if (n.name () == "phiWindow" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< phiWindow_type > r (
          phiWindow_traits::create (i, f, this));

        this->phiWindow_.push_back (r);
        continue;
      }

      break;
    }

    if (!etThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etThreshold",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  EnergySumsObjectRequirement* EnergySumsObjectRequirement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnergySumsObjectRequirement (*this, f, c);
  }

  EnergySumsObjectRequirement::
  ~EnergySumsObjectRequirement ()
  {
  }

  // EnergySumsCondition
  //

  EnergySumsCondition::
  EnergySumsCondition (const uid_type& uid,
                       const name_type& name,
                       const comment_type& comment,
                       const locked_type& locked,
                       const comparison_operator_type& comparison_operator,
                       const objectType_type& objectType,
                       const objectRequirement_type& objectRequirement,
                       const relativeBx_type& relativeBx)
  : ::l1t::Condition (uid,
                      name,
                      comment,
                      locked),
    comparison_operator_ (comparison_operator, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectRequirement_ (objectRequirement, ::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  EnergySumsCondition::
  EnergySumsCondition (const uid_type& uid,
                       const name_type& name,
                       const comment_type& comment,
                       const locked_type& locked,
                       const comparison_operator_type& comparison_operator,
                       const objectType_type& objectType,
                       ::std::auto_ptr< objectRequirement_type >& objectRequirement,
                       const relativeBx_type& relativeBx)
  : ::l1t::Condition (uid,
                      name,
                      comment,
                      locked),
    comparison_operator_ (comparison_operator, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectRequirement_ (objectRequirement, ::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  EnergySumsCondition::
  EnergySumsCondition (const EnergySumsCondition& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c),
    comparison_operator_ (x.comparison_operator_, f, this),
    objectType_ (x.objectType_, f, this),
    objectRequirement_ (x.objectRequirement_, f, this),
    relativeBx_ (x.relativeBx_, f, this)
  {
  }

  EnergySumsCondition::
  EnergySumsCondition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::l1t::Condition (e, f | ::xml_schema::flags::base, c),
    comparison_operator_ (f, this),
    objectType_ (f, this),
    objectRequirement_ (f, this),
    relativeBx_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void EnergySumsCondition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::l1t::Condition::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // comparison_operator
      //
      if (n.name () == "comparison_operator" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< comparison_operator_type > r (
          comparison_operator_traits::create (i, f, this));

        if (!comparison_operator_.present ())
        {
          this->comparison_operator_.set (r);
          continue;
        }
      }

      // objectType
      //
      if (n.name () == "objectType" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectType_type > r (
          objectType_traits::create (i, f, this));

        if (!objectType_.present ())
        {
          this->objectType_.set (r);
          continue;
        }
      }

      // objectRequirement
      //
      if (n.name () == "objectRequirement" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< objectRequirement_type > r (
          objectRequirement_traits::create (i, f, this));

        if (!objectRequirement_.present ())
        {
          this->objectRequirement_.set (r);
          continue;
        }
      }

      // relativeBx
      //
      if (n.name () == "relativeBx" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< relativeBx_type > r (
          relativeBx_traits::create (i, f, this));

        if (!relativeBx_.present ())
        {
          this->relativeBx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!comparison_operator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comparison_operator",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!objectType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectType",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!objectRequirement_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectRequirement",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!relativeBx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeBx",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  EnergySumsCondition* EnergySumsCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnergySumsCondition (*this, f, c);
  }

  EnergySumsCondition::
  ~EnergySumsCondition ()
  {
  }

  // Algorithm
  //

  Algorithm::
  Algorithm (const uid_type& uid,
             const name_type& name,
             const index_type& index,
             const logical_expression_type& logical_expression,
             const comment_type& comment,
             const locked_type& locked,
             const mapping_type& mapping)
  : ::xml_schema::type (),
    uid_ (uid, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    index_ (index, ::xml_schema::flags (), this),
    logical_expression_ (logical_expression, ::xml_schema::flags (), this),
    comment_ (comment, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this),
    mapping_ (mapping, ::xml_schema::flags (), this)
  {
  }

  Algorithm::
  Algorithm (const uid_type& uid,
             const name_type& name,
             const index_type& index,
             const logical_expression_type& logical_expression,
             const comment_type& comment,
             const locked_type& locked,
             ::std::auto_ptr< mapping_type >& mapping)
  : ::xml_schema::type (),
    uid_ (uid, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    index_ (index, ::xml_schema::flags (), this),
    logical_expression_ (logical_expression, ::xml_schema::flags (), this),
    comment_ (comment, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this),
    mapping_ (mapping, ::xml_schema::flags (), this)
  {
  }

  Algorithm::
  Algorithm (const Algorithm& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    uid_ (x.uid_, f, this),
    name_ (x.name_, f, this),
    index_ (x.index_, f, this),
    logical_expression_ (x.logical_expression_, f, this),
    comment_ (x.comment_, f, this),
    locked_ (x.locked_, f, this),
    mapping_ (x.mapping_, f, this)
  {
  }

  Algorithm::
  Algorithm (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    uid_ (f, this),
    name_ (f, this),
    index_ (f, this),
    logical_expression_ (f, this),
    comment_ (f, this),
    locked_ (f, this),
    mapping_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Algorithm::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // uid
      //
      if (n.name () == "uid" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< uid_type > r (
          uid_traits::create (i, f, this));

        if (!uid_.present ())
        {
          this->uid_.set (r);
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // index
      //
      if (n.name () == "index" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< index_type > r (
          index_traits::create (i, f, this));

        if (!index_.present ())
        {
          this->index_.set (r);
          continue;
        }
      }

      // logical_expression
      //
      if (n.name () == "logical_expression" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< logical_expression_type > r (
          logical_expression_traits::create (i, f, this));

        if (!logical_expression_.present ())
        {
          this->logical_expression_.set (r);
          continue;
        }
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        if (!comment_.present ())
        {
          this->comment_.set (r);
          continue;
        }
      }

      // locked
      //
      if (n.name () == "locked" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        if (!locked_.present ())
        {
          this->locked_.set (locked_traits::create (i, f, this));
          continue;
        }
      }

      // mapping
      //
      if (n.name () == "mapping" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< mapping_type > r (
          mapping_traits::create (i, f, this));

        if (!mapping_.present ())
        {
          this->mapping_.set (r);
          continue;
        }
      }

      break;
    }

    if (!uid_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uid",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!index_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "index",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!logical_expression_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "logical_expression",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!comment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comment",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!locked_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locked",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!mapping_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mapping",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  Algorithm* Algorithm::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Algorithm (*this, f, c);
  }

  Algorithm::
  ~Algorithm ()
  {
  }

  // AlgorithmMapping
  //

  AlgorithmMapping::
  AlgorithmMapping (const module_type& module,
                    const index_type& index)
  : ::xml_schema::type (),
    module_ (module, ::xml_schema::flags (), this),
    index_ (index, ::xml_schema::flags (), this)
  {
  }

  AlgorithmMapping::
  AlgorithmMapping (const AlgorithmMapping& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    module_ (x.module_, f, this),
    index_ (x.index_, f, this)
  {
  }

  AlgorithmMapping::
  AlgorithmMapping (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    module_ (f, this),
    index_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AlgorithmMapping::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // module
      //
      if (n.name () == "module" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< module_type > r (
          module_traits::create (i, f, this));

        if (!module_.present ())
        {
          this->module_.set (r);
          continue;
        }
      }

      // index
      //
      if (n.name () == "index" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< index_type > r (
          index_traits::create (i, f, this));

        if (!index_.present ())
        {
          this->index_.set (r);
          continue;
        }
      }

      break;
    }

    if (!module_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "module",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!index_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "index",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  AlgorithmMapping* AlgorithmMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmMapping (*this, f, c);
  }

  AlgorithmMapping::
  ~AlgorithmMapping ()
  {
  }

  // AlgorithmList
  //

  AlgorithmList::
  AlgorithmList ()
  : ::xml_schema::type (),
    algorithm_ (::xml_schema::flags (), this)
  {
  }

  AlgorithmList::
  AlgorithmList (const AlgorithmList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    algorithm_ (x.algorithm_, f, this)
  {
  }

  AlgorithmList::
  AlgorithmList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    algorithm_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AlgorithmList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // algorithm
      //
      if (n.name () == "algorithm" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< algorithm_type > r (
          algorithm_traits::create (i, f, this));

        this->algorithm_.push_back (r);
        continue;
      }

      break;
    }
  }

  AlgorithmList* AlgorithmList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmList (*this, f, c);
  }

  AlgorithmList::
  ~AlgorithmList ()
  {
  }

  // L1TriggerMenu
  //

  L1TriggerMenu::
  L1TriggerMenu (const meta_type& meta,
                 const conditions_type& conditions,
                 const algorithms_type& algorithms)
  : ::xml_schema::type (),
    meta_ (meta, ::xml_schema::flags (), this),
    conditions_ (conditions, ::xml_schema::flags (), this),
    algorithms_ (algorithms, ::xml_schema::flags (), this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (::std::auto_ptr< meta_type >& meta,
                 ::std::auto_ptr< conditions_type >& conditions,
                 ::std::auto_ptr< algorithms_type >& algorithms)
  : ::xml_schema::type (),
    meta_ (meta, ::xml_schema::flags (), this),
    conditions_ (conditions, ::xml_schema::flags (), this),
    algorithms_ (algorithms, ::xml_schema::flags (), this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (const L1TriggerMenu& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    meta_ (x.meta_, f, this),
    conditions_ (x.conditions_, f, this),
    algorithms_ (x.algorithms_, f, this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    meta_ (f, this),
    conditions_ (f, this),
    algorithms_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void L1TriggerMenu::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // meta
      //
      if (n.name () == "meta" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< meta_type > r (
          meta_traits::create (i, f, this));

        if (!meta_.present ())
        {
          this->meta_.set (r);
          continue;
        }
      }

      // conditions
      //
      if (n.name () == "conditions" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< conditions_type > r (
          conditions_traits::create (i, f, this));

        if (!conditions_.present ())
        {
          this->conditions_.set (r);
          continue;
        }
      }

      // algorithms
      //
      if (n.name () == "algorithms" && n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
      {
        ::std::auto_ptr< algorithms_type > r (
          algorithms_traits::create (i, f, this));

        if (!algorithms_.present ())
        {
          this->algorithms_.set (r);
          continue;
        }
      }

      break;
    }

    if (!meta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "meta",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!conditions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "conditions",
        "http://www.cern.ch/l1t/0.7.0");
    }

    if (!algorithms_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "algorithms",
        "http://www.cern.ch/l1t/0.7.0");
    }
  }

  L1TriggerMenu* L1TriggerMenu::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class L1TriggerMenu (*this, f, c);
  }

  L1TriggerMenu::
  ~L1TriggerMenu ()
  {
  }
}

#include <istream>
#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/xml/sax/std-input-source.hxx>
#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/tree/error-handler.hxx>

namespace l1t
{
  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::l1t::l1TriggerMenu (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "l1TriggerMenu" &&
        n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
    {
      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::xsd::cxx::tree::traits< ::l1t::L1TriggerMenu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "l1TriggerMenu",
      "http://www.cern.ch/l1t/0.7.0");
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "l1TriggerMenu" &&
        n.namespace_ () == "http://www.cern.ch/l1t/0.7.0")
    {
      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::xsd::cxx::tree::traits< ::l1t::L1TriggerMenu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "l1TriggerMenu",
      "http://www.cern.ch/l1t/0.7.0");
  }
}

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

