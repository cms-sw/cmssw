#include "FWCore/Framework/interface/one/EDAnalyzer.h"
#include "FWCore/Framework/interface/Run.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/Utilities/interface/EDGetToken.h"
#include "FWCore/Utilities/interface/InputTag.h"
#include "FWCore/Utilities/interface/Exception.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "DataFormats/Common/interface/Handle.h"

#include "SimTracker/TrackTriggerAssociation/interface/StubAssociation.h"
#include "L1Trigger/TrackTrigger/interface/Setup.h"
#include "L1Trigger/TrackerTFP/interface/DataFormats.h"

#include <TProfile.h>
#include <TH1F.h>
#include <TEfficiency.h>

#include <vector>
#include <deque>
#include <set>
#include <cmath>
#include <numeric>
#include <sstream>

namespace trackerTFP {

  /*! \class  trackerTFP::AnalyzerCTB
   *  \brief  Class to analyze hardware like structured TTStub Collection generated by Clean Track Builder
   *  \author Thomas Schuh
   *  \date   2020, April
   */
  class AnalyzerCTB : public edm::one::EDAnalyzer<edm::one::WatchRuns, edm::one::SharedResources> {
  public:
    AnalyzerCTB(const edm::ParameterSet& iConfig);
    void beginJob() override {}
    void beginRun(const edm::Run& iEvent, const edm::EventSetup& iSetup) override;
    void analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) override;
    void endRun(const edm::Run& iEvent, const edm::EventSetup& iSetup) override {}
    void endJob() override;

  private:
    //
    void formTracks(const tt::StreamsTrack& streamsTrack,
                    const tt::StreamsStub& streamsStubs,
                    std::vector<std::vector<TTStubRef>>& tracks,
                    int channel) const;
    //
    void associate(const std::vector<std::vector<TTStubRef>>& tracks,
                   const tt::StubAssociation* ass,
                   std::set<TPPtr>& tps,
                   int& sum) const;
    // ED input token of stubs
    edm::EDGetTokenT<tt::StreamsStub> edGetTokenStubs_;
    // ED input token of tracks
    edm::EDGetTokenT<tt::StreamsTrack> edGetTokenTracks_;
    // ED input token of TTStubRef to TPPtr association for tracking efficiency
    edm::EDGetTokenT<tt::StubAssociation> edGetTokenSelection_;
    // ED input token of TTStubRef to recontructable TPPtr association
    edm::EDGetTokenT<tt::StubAssociation> edGetTokenReconstructable_;
    // Setup token
    edm::ESGetToken<tt::Setup, tt::SetupRcd> esGetTokenSetup_;
    // DataFormats token
    edm::ESGetToken<DataFormats, DataFormatsRcd> esGetTokenDataFormats_;
    // stores, calculates and provides run-time constants
    const tt::Setup* setup_ = nullptr;
    // helper class to extract structured data from tt::Frames
    const DataFormats* dataFormats_ = nullptr;
    // enables analyze of TPs
    bool useMCTruth_;
    //
    int nEvents_ = 0;

    // Histograms

    TProfile* prof_;
    TProfile* profChan_;
    TProfile* profStubs_;
    TProfile* profTracks_;
    TH1F* hisChan_;
    TH1F* hisStubs_;
    TH1F* hisTracks_;
    TH1F* hisLayers_;
    TH1F* hisNumLayers_;
    TProfile* profNumLayers_;
    TH1F* hisEffZT_;
    TH1F* hisEffZTTotal_;
    TEfficiency* effZT_;
    TH1F* hisEffInv2R_;
    TH1F* hisEffInv2RTotal_;
    TEfficiency* effInv2R_;

    // printout
    std::stringstream log_;
  };

  AnalyzerCTB::AnalyzerCTB(const edm::ParameterSet& iConfig) : useMCTruth_(iConfig.getParameter<bool>("UseMCTruth")) {
    usesResource("TFileService");
    // book in- and output ED products
    const std::string& label = iConfig.getParameter<std::string>("OutputLabelCTB");
    const std::string& branchStubs = iConfig.getParameter<std::string>("BranchStubs");
    const std::string& branchTracks = iConfig.getParameter<std::string>("BranchTracks");
    edGetTokenStubs_ = consumes<tt::StreamsStub>(edm::InputTag(label, branchStubs));
    edGetTokenTracks_ = consumes<tt::StreamsTrack>(edm::InputTag(label, branchTracks));
    if (useMCTruth_) {
      const auto& inputTagSelecttion = iConfig.getParameter<edm::InputTag>("InputTagSelection");
      const auto& inputTagReconstructable = iConfig.getParameter<edm::InputTag>("InputTagReconstructable");
      edGetTokenSelection_ = consumes<tt::StubAssociation>(inputTagSelecttion);
      edGetTokenReconstructable_ = consumes<tt::StubAssociation>(inputTagReconstructable);
    }
    // book ES products
    esGetTokenSetup_ = esConsumes<edm::Transition::BeginRun>();
    esGetTokenDataFormats_ = esConsumes<edm::Transition::BeginRun>();
    // log config
    log_.setf(std::ios::fixed, std::ios::floatfield);
    log_.precision(4);
  }

  void AnalyzerCTB::beginRun(const edm::Run& iEvent, const edm::EventSetup& iSetup) {
    // helper class to store configurations
    setup_ = &iSetup.getData(esGetTokenSetup_);
    // helper class to extract structured data from tt::Frames
    dataFormats_ = &iSetup.getData(esGetTokenDataFormats_);
    // book histograms
    edm::Service<TFileService> fs;
    TFileDirectory dir;
    dir = fs->mkdir("CTB");
    prof_ = dir.make<TProfile>("Counts", ";", 9, 0.5, 9.5);
    prof_->GetXaxis()->SetBinLabel(1, "Stubs");
    prof_->GetXaxis()->SetBinLabel(2, "Tracks");
    prof_->GetXaxis()->SetBinLabel(4, "Matched Tracks");
    prof_->GetXaxis()->SetBinLabel(5, "All Tracks");
    prof_->GetXaxis()->SetBinLabel(6, "Found TPs");
    prof_->GetXaxis()->SetBinLabel(7, "Found selected TPs");
    prof_->GetXaxis()->SetBinLabel(9, "All TPs");
    // channel occupancy
    constexpr int maxOcc = 180;
    const int numChannelsTracks = dataFormats_->numChannel(Process::ctb);
    const int numChannelsStubs = numChannelsTracks * setup_->numLayers();
    hisChan_ = dir.make<TH1F>("His Channel Occupancy", ";", maxOcc, -.5, maxOcc - .5);
    profChan_ = dir.make<TProfile>("Prof Channel Occupancy", ";", numChannelsTracks, -.5, numChannelsTracks - .5);
    // stub occupancy
    hisStubs_ = dir.make<TH1F>("His Channel Occupancy", ";", maxOcc, -.5, maxOcc - .5);
    profStubs_ = dir.make<TProfile>("Prof Channel Occupancy", ";", numChannelsStubs, -.5, numChannelsStubs - .5);
    // track occupancy
    hisTracks_ = dir.make<TH1F>("His Track Occupancy", ";", maxOcc, -.5, maxOcc - .5);
    profTracks_ = dir.make<TProfile>("Prof Track Occupancy", ";", numChannelsTracks, -.5, numChannelsTracks - .5);
    // layers
    hisLayers_ = dir.make<TH1F>("HisLayers", ";", 8, 0, 8);
    hisNumLayers_ = dir.make<TH1F>("HisNumLayers", ";", 9, 0, 9);
    profNumLayers_ = dir.make<TProfile>("Prof NumLayers", ";", 32, 0, 2.4);
    // Efficiencies
    const double rangeZT = dataFormats_->format(Variable::zT, Process::dr).range();
    const int zTBins = setup_->gpNumBinsZT();
    hisEffZTTotal_ = dir.make<TH1F>("HisTPZTTotal", ";", zTBins, -rangeZT / 2, rangeZT / 2);
    hisEffZT_ = dir.make<TH1F>("HisTPZT", ";", zTBins, -rangeZT / 2, rangeZT / 2);
    effZT_ = dir.make<TEfficiency>("EffZT", ";", zTBins, -rangeZT / 2, rangeZT / 2);
    const double rangeInv2R = dataFormats_->format(Variable::inv2R, Process::dr).range();
    const int inv2RBins = (setup_->htNumBinsInv2R() + 2) * 2;
    hisEffInv2R_ = dir.make<TH1F>("HisTPInv2R", ";", inv2RBins, -rangeInv2R / 2., rangeInv2R / 2.);
    hisEffInv2RTotal_ = dir.make<TH1F>("HisTPInv2RTotal", ";", inv2RBins, -rangeInv2R / 2., rangeInv2R / 2.);
    effInv2R_ = dir.make<TEfficiency>("EffInv2R", ";", inv2RBins, -rangeInv2R / 2., rangeInv2R / 2.);
  }

  void AnalyzerCTB::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {
    auto fill = [this](const TPPtr& tpPtr, TH1F* hisZT, TH1F* hisInv2R) {
      const double tpPhi0 = tpPtr->phi();
      const double tpCot = sinh(tpPtr->eta());
      const math::XYZPointD& v = tpPtr->vertex();
      const double tpZ0 = v.z() - tpCot * (v.x() * cos(tpPhi0) + v.y() * sin(tpPhi0));
      const double tpZT = tpZ0 + tpCot * setup_->chosenRofZ();
      const double tpInv2R = tpPtr->charge() / tpPtr->pt() * setup_->invPtToDphi();
      hisZT->Fill(tpZT);
      hisInv2R->Fill(tpInv2R);
    };
    // read in ht products
    edm::Handle<tt::StreamsStub> handleStubs;
    iEvent.getByToken<tt::StreamsStub>(edGetTokenStubs_, handleStubs);
    const tt::StreamsStub& acceptedStubs = *handleStubs;
    edm::Handle<tt::StreamsTrack> handleTracks;
    iEvent.getByToken<tt::StreamsTrack>(edGetTokenTracks_, handleTracks);
    const tt::StreamsTrack& acceptedTracks = *handleTracks;
    // read in MCTruth
    const tt::StubAssociation* selection = nullptr;
    const tt::StubAssociation* reconstructable = nullptr;
    if (useMCTruth_) {
      edm::Handle<tt::StubAssociation> handleSelection;
      iEvent.getByToken<tt::StubAssociation>(edGetTokenSelection_, handleSelection);
      selection = handleSelection.product();
      prof_->Fill(9, selection->numTPs());
      edm::Handle<tt::StubAssociation> handleReconstructable;
      iEvent.getByToken<tt::StubAssociation>(edGetTokenReconstructable_, handleReconstructable);
      reconstructable = handleReconstructable.product();
      for (const auto& p : selection->getTrackingParticleToTTStubsMap())
        fill(p.first, hisEffZTTotal_, hisEffInv2RTotal_);
    }
    // analyze ht products and associate found tracks with reconstrucable TrackingParticles
    std::set<TPPtr> tpPtrs;
    std::set<TPPtr> tpPtrsSelection;
    int allMatched(0);
    int allTracks(0);
    for (int region = 0; region < setup_->numRegions(); region++) {
      const int offsetTrack = region * dataFormats_->numChannel(Process::ctb);
      int nStubs(0);
      int nTracks(0);
      for (int channel = 0; channel < dataFormats_->numChannel(Process::ctb); channel++) {
        const int indexTrack = offsetTrack + channel;
        const int size = acceptedTracks[indexTrack].size();
        hisChan_->Fill(size);
        profChan_->Fill(channel, size);
        const int offsetStub = indexTrack * setup_->numLayers();
        for (int layer = 0; layer < setup_->numLayers(); layer++) {
          const tt::StreamStub& stream = acceptedStubs[offsetStub + layer];
          const int nStubs = std::accumulate(stream.begin(), stream.end(), 0, [](int sum, const tt::FrameStub& frame) {
            return sum + (frame.first.isNonnull() ? 1 : 0);
          });
          hisStubs_->Fill(nStubs);
          profStubs_->Fill(channel * setup_->numLayers() + layer, nStubs);
        }
        std::vector<std::vector<TTStubRef>> tracks;
        formTracks(acceptedTracks, acceptedStubs, tracks, indexTrack);
        hisTracks_->Fill(tracks.size());
        profTracks_->Fill(channel, tracks.size());
        nTracks += tracks.size();
        nStubs += std::accumulate(tracks.begin(), tracks.end(), 0, [](int sum, const std::vector<TTStubRef>& track) {
          return sum + track.size();
        });
        allTracks += tracks.size();
        if (!useMCTruth_)
          continue;
        int tmp(0);
        associate(tracks, selection, tpPtrsSelection, tmp);
        associate(tracks, reconstructable, tpPtrs, allMatched);
      }
      prof_->Fill(1, nStubs);
      prof_->Fill(2, nTracks);
    }
    for (const TPPtr& tpPtr : tpPtrsSelection)
      fill(tpPtr, hisEffZT_, hisEffInv2R_);
    prof_->Fill(4, allMatched);
    prof_->Fill(5, allTracks);
    prof_->Fill(6, tpPtrs.size());
    prof_->Fill(7, tpPtrsSelection.size());
    nEvents_++;
  }

  void AnalyzerCTB::endJob() {
    if (nEvents_ == 0)
      return;
    // effi
    effZT_->SetPassedHistogram(*hisEffZT_, "f");
    effZT_->SetTotalHistogram(*hisEffZTTotal_, "f");
    effInv2R_->SetPassedHistogram(*hisEffInv2R_, "f");
    effInv2R_->SetTotalHistogram(*hisEffInv2RTotal_, "f");
    // printout TB summary
    const double totalTPs = prof_->GetBinContent(9);
    const double numStubs = prof_->GetBinContent(1);
    const double numTracks = prof_->GetBinContent(2);
    const double totalTracks = prof_->GetBinContent(5);
    const double numTracksMatched = prof_->GetBinContent(4);
    const double numTPsAll = prof_->GetBinContent(6);
    const double numTPsEff = prof_->GetBinContent(7);
    const double errStubs = prof_->GetBinError(1);
    const double errTracks = prof_->GetBinError(2);
    const double fracFake = (totalTracks - numTracksMatched) / totalTracks;
    const double fracDup = (numTracksMatched - numTPsAll) / totalTracks;
    const double eff = numTPsEff / totalTPs;
    const double errEff = sqrt(eff * (1. - eff) / totalTPs / nEvents_);
    const std::vector<double> nums = {numStubs, numTracks};
    const std::vector<double> errs = {errStubs, errTracks};
    const int wNums = std::ceil(std::log10(*std::max_element(nums.begin(), nums.end()))) + 5;
    const int wErrs = std::ceil(std::log10(*std::max_element(errs.begin(), errs.end()))) + 5;
    log_ << "                         CTB SUMMARY                         " << std::endl;
    log_ << "number of stubs       per TFP = " << std::setw(wNums) << numStubs << " +- " << std::setw(wErrs) << errStubs
         << std::endl;
    log_ << "number of tracks      per TFP = " << std::setw(wNums) << numTracks << " +- " << std::setw(wErrs)
         << errTracks << std::endl;
    log_ << "     max  tracking efficiency = " << std::setw(wNums) << eff << " +- " << std::setw(wErrs) << errEff
         << std::endl;
    log_ << "                    fake rate = " << std::setw(wNums) << fracFake << std::endl;
    log_ << "               duplicate rate = " << std::setw(wNums) << fracDup << std::endl;
    log_ << "=============================================================";
    edm::LogPrint(moduleDescription().moduleName()) << log_.str();
  }

  //
  void AnalyzerCTB::formTracks(const tt::StreamsTrack& streamsTrack,
                               const tt::StreamsStub& streamsStubs,
                               std::vector<std::vector<TTStubRef>>& tracks,
                               int channel) const {
    const int offset = channel * setup_->numLayers();
    const tt::StreamTrack& streamTrack = streamsTrack[channel];
    const int numTracks =
        std::accumulate(streamTrack.begin(), streamTrack.end(), 0, [](int sum, const tt::FrameTrack& frame) {
          return sum + (frame.first.isNonnull() ? 1 : 0);
        });
    tracks.reserve(numTracks);
    for (int frame = 0; frame < static_cast<int>(streamTrack.size()); frame++) {
      const tt::FrameTrack& frameTrack = streamTrack[frame];
      if (frameTrack.first.isNull())
        continue;
      const auto end = std::find_if(std::next(streamTrack.begin(), frame + 1),
                                    streamTrack.end(),
                                    [](const tt::FrameTrack& frame) { return frame.first.isNonnull(); });
      const int size = std::distance(std::next(streamTrack.begin(), frame), end);
      int numStubs(0);
      for (int layer = 0; layer < setup_->numLayers(); layer++) {
        const tt::StreamStub& stream = streamsStubs[offset + layer];
        numStubs += std::accumulate(
            stream.begin() + frame, stream.begin() + frame + size, 0, [](int sum, const tt::FrameStub& frame) {
              return sum + (frame.first.isNonnull() ? 1 : 0);
            });
      }
      std::vector<TTStubRef> stubs;
      stubs.reserve(numStubs);
      int numLayers(0);
      for (int layer = 0; layer < setup_->numLayers(); layer++) {
        bool any(false);
        for (int f = frame; f < frame + size; f++) {
          const tt::FrameStub& stub = streamsStubs[offset + layer][f];
          if (stub.first.isNonnull()) {
            any = true;
            stubs.push_back(stub.first);
          }
        }
        if (any) {
          hisLayers_->Fill(layer);
          numLayers++;
        }
      }
      const double cot = TrackCTB(frameTrack, dataFormats_).zT() / setup_->chosenRofZ();
      hisNumLayers_->Fill(numLayers);
      profNumLayers_->Fill(abs(sinh(cot)), numLayers);
      tracks.push_back(stubs);
    }
  }

  //
  void AnalyzerCTB::associate(const std::vector<std::vector<TTStubRef>>& tracks,
                              const tt::StubAssociation* ass,
                              std::set<TPPtr>& tps,
                              int& sum) const {
    for (const std::vector<TTStubRef>& ttStubRefs : tracks) {
      const std::vector<TPPtr>& tpPtrs = ass->associate(ttStubRefs);
      if (tpPtrs.empty())
        continue;
      sum++;
      std::copy(tpPtrs.begin(), tpPtrs.end(), std::inserter(tps, tps.begin()));
    }
  }

}  // namespace trackerTFP

DEFINE_FWK_MODULE(trackerTFP::AnalyzerCTB);
