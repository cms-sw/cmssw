#include "Calibration/IsolatedParticles/interface/MatchingSimTrack.h"
#include "Calibration/IsolatedParticles/interface/eHCALMatrix.h"
#include "Calibration/IsolatedParticles/interface/eECALMatrix.h"
#include "Calibration/IsolatedParticles/interface/FindCaloHitCone.h"
#include "DataFormats/HcalDetId/interface/HcalSubdetector.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include <algorithm>
#include <sstream>

namespace spr {

  template <typename T>
  std::map<std::string, double> eECALSimInfo(const edm::Event& iEvent,
                                             const DetId& det,
                                             const CaloGeometry* geo,
                                             const CaloTopology* caloTopology,
                                             edm::Handle<T>& hitsEB,
                                             edm::Handle<T>& hitsEE,
                                             edm::Handle<edm::SimTrackContainer>& SimTk,
                                             edm::Handle<edm::SimVertexContainer>& SimVtx,
                                             const reco::Track* pTrack,
                                             TrackerHitAssociator& associate,
                                             int ieta,
                                             int iphi,
                                             double timeCut,
                                             bool debug) {
    spr::caloSimInfo info;
    spr::eECALSimInfo(iEvent,
                      det,
                      geo,
                      caloTopology,
                      hitsEB,
                      hitsEE,
                      SimTk,
                      SimVtx,
                      pTrack,
                      associate,
                      ieta,
                      iphi,
                      info,
                      timeCut,
                      debug);
    // return a map of matching type and energy of SimHits
    return spr::eCaloSimInfo(info);
  }

  template <typename T>
  void eECALSimInfo(const edm::Event& iEvent,
                    const DetId& det,
                    const CaloGeometry* geo,
                    const CaloTopology* caloTopology,
                    edm::Handle<T>& hitsEB,
                    edm::Handle<T>& hitsEE,
                    edm::Handle<edm::SimTrackContainer>& SimTk,
                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                    const reco::Track* pTrack,
                    TrackerHitAssociator& associate,
                    int ieta,
                    int iphi,
                    spr::caloSimInfo& info,
                    double timeCut,
                    bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eECALSimInfo " << 2 * ieta + 1 << "x" << 2 * iphi + 1 << "\ntrkMom "
                                   << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    //vector of Ecal cells in NxN
    std::vector<DetId> vdets = spr::matrixECALIds(det, ieta, iphi, geo, caloTopology, debug);

    //Construct a struct with matching type and energy of SimHits
    spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, info, timeCut, debug);
  }

  template <typename T>
  void eECALSimInfo(const edm::Event& iEvent,
                    const DetId& det,
                    const CaloGeometry* geo,
                    const CaloTopology* caloTopology,
                    edm::Handle<T>& hitsEB,
                    edm::Handle<T>& hitsEE,
                    edm::Handle<edm::SimTrackContainer>& SimTk,
                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                    const reco::Track* pTrack,
                    TrackerHitAssociator& associate,
                    int ietaE,
                    int ietaW,
                    int iphiN,
                    int iphiS,
                    spr::caloSimInfo& info,
                    double timeCut,
                    bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eECALSimInfo " << ietaE + ietaW + 1 << "x" << iphiN + iphiS + 1
                                   << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    //vector of Ecal cells in NxN
    std::vector<DetId> vdets = spr::matrixECALIds(det, ietaE, ietaW, iphiN, iphiS, geo, caloTopology, debug);

    // return a map of matching type and energy of SimHits
    spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, info, timeCut, debug);
  }

  template <typename T>
  std::map<std::string, double> eHCALSimInfo(const edm::Event& iEvent,
                                             const HcalTopology* topology,
                                             const DetId& det,
                                             const CaloGeometry* geo,
                                             edm::Handle<T>& hits,
                                             edm::Handle<edm::SimTrackContainer>& SimTk,
                                             edm::Handle<edm::SimVertexContainer>& SimVtx,
                                             const reco::Track* pTrack,
                                             TrackerHitAssociator& associate,
                                             int ieta,
                                             int iphi,
                                             double timeCut,
                                             bool includeHO,
                                             bool debug) {
    spr::caloSimInfo info;
    spr::eHCALSimInfo(
        iEvent, topology, det, geo, hits, SimTk, SimVtx, pTrack, associate, ieta, iphi, info, timeCut, includeHO, debug);
    // return a map of matching type and energy of SimHits
    return spr::eCaloSimInfo(info);
  }

  template <typename T>
  void eHCALSimInfo(const edm::Event& iEvent,
                    const HcalTopology* topology,
                    const DetId& det,
                    const CaloGeometry* geo,
                    edm::Handle<T>& hits,
                    edm::Handle<edm::SimTrackContainer>& SimTk,
                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                    const reco::Track* pTrack,
                    TrackerHitAssociator& associate,
                    int ieta,
                    int iphi,
                    spr::caloSimInfo& info,
                    double timeCut,
                    bool includeHO,
                    bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eHCALSimInfo " << 2 * ieta + 1 << "x" << 2 * iphi + 1 << "\ntrkMom "
                                   << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    // get the hits in Hcal in NxN around det
    std::vector<typename T::const_iterator> hit;
    spr::hitHCALmatrix(topology, det, hits, ieta, iphi, hit, includeHO, debug);

    spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, info, timeCut, includeHO, debug);
  }

  template <typename T>
  void eHCALSimInfo(const edm::Event& iEvent,
                    const HcalTopology* topology,
                    const DetId& det,
                    const CaloGeometry* geo,
                    edm::Handle<T>& hits,
                    edm::Handle<edm::SimTrackContainer>& SimTk,
                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                    const reco::Track* pTrack,
                    TrackerHitAssociator& associate,
                    int ietaE,
                    int ietaW,
                    int iphiN,
                    int iphiS,
                    spr::caloSimInfo& info,
                    double timeCut,
                    bool includeHO,
                    bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eHCALSimInfo " << ietaE + ietaW + 1 << "x" << iphiN + iphiS + 1
                                   << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    // get the hits in Hcal in NxN around det
    std::vector<typename T::const_iterator> hit;
    spr::hitHCALmatrixTotal(topology, det, hits, ietaE, ietaW, iphiN, iphiS, hit, includeHO, debug);

    spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, info, timeCut, includeHO, debug);
  }

  // NxN method modified to return vector of
  // simhit multiplicities by type of particle
  template <typename T>
  std::map<std::string, double> eHCALSimInfo(const edm::Event& iEvent,
                                             const HcalTopology* topology,
                                             const DetId& det,
                                             edm::Handle<T>& hits,
                                             edm::Handle<edm::SimTrackContainer>& SimTk,
                                             edm::Handle<edm::SimVertexContainer>& SimVtx,
                                             const reco::Track* pTrack,
                                             TrackerHitAssociator& associate,
                                             int ieta,
                                             int iphi,
                                             std::vector<int>& multiplicityVector,
                                             bool debug) {
    if (debug) {
      edm::LogVerbatim("IsoTrack") << "Processing HcalSimInfo " << 2 * ieta + 1 << "x" << 2 * iphi + 1;
      edm::LogVerbatim("IsoTrack") << "trkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();
    }

    // Get SimTrack matched to RecoTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    // Get list of simhits in matrix ("hits" is list of pcalo simhits)
    std::vector<typename T::const_iterator> hit;
    spr::hitHCALmatrix(topology, det, hits, ieta, iphi, hit, false, debug);

    return eCaloSimInfo(hits, SimTk, SimVtx, hit, trkInfo, multiplicityVector, debug);
  }

  // eHCALSimInfo for Cone
  template <typename T>
  std::map<std::string, double> eHCALSimInfoCone(const edm::Event& iEvent,
                                                 edm::Handle<T>& hits,
                                                 edm::Handle<edm::SimTrackContainer>& SimTk,
                                                 edm::Handle<edm::SimVertexContainer>& SimVtx,
                                                 const reco::Track* pTrack,
                                                 TrackerHitAssociator& associate,
                                                 const CaloGeometry* geo,
                                                 const GlobalPoint& hpoint1,
                                                 const GlobalPoint& point1,
                                                 double dR,
                                                 const GlobalVector& trackMom,
                                                 std::vector<int>& multiplicityVector) {
    bool debug_dummy = false;

    // Get SimTrack matched to RecoTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug_dummy);

    //    spr::hitHCALmatrix(topology,det,hits,ieta,iphi,debug);

    // Get list of simhits in matrix ("hits" is list of pcalo simhits)
    std::vector<typename T::const_iterator> hit = spr::findHitCone(geo, hits, hpoint1, point1, dR, trackMom);

    return eCaloSimInfo(hits, SimTk, SimVtx, hit, trkInfo, multiplicityVector, debug_dummy);
  }

  // eHCALSimInfo for Cone that only clusters simhits in Hcal cells
  // that contained a rechit
  template <typename T>
  std::map<std::string, double> eHCALSimInfoCone(const edm::Event& iEvent,
                                                 edm::Handle<T>& hits,
                                                 edm::Handle<edm::SimTrackContainer>& SimTk,
                                                 edm::Handle<edm::SimVertexContainer>& SimVtx,
                                                 const reco::Track* pTrack,
                                                 TrackerHitAssociator& associate,
                                                 const CaloGeometry* geo,
                                                 const GlobalPoint& hpoint1,
                                                 const GlobalPoint& point1,
                                                 double dR,
                                                 const GlobalVector& trackMom,
                                                 std::vector<int>& multiplicityVector,
                                                 std::vector<DetId>& coneRecHitDetIds) {
    bool debug_dummy = false;

    // Get SimTrack matched to RecoTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug_dummy);

    //    spr::hitHCALmatrix(topology,det,hits,ieta,iphi,debug);

    // Get list of simhits in matrix ("hits" is list of pcalo simhits)
    std::vector<typename T::const_iterator> hit = spr::findHitCone(geo, hits, hpoint1, point1, dR, trackMom);

    // Loop over hits and only keep those whose detid matches a detid in
    // coneRecHitDetIds:

    std::vector<typename T::const_iterator> matchedhit;
    for (int ihit = 0; ihit < hit.size(); ihit++) {
      bool keephit = false;
      for (size_t idetid = 0; idetid < coneRecHitDetIds.size(); idetid++) {
        if (hit.at(ihit)->id() == coneRecHitDetIds.at(idetid)) {
          keephit = true;
          break;
        }
      }
      if (keephit)
        matchedhit.push_back(hit.at(ihit));
    }

    return eCaloSimInfo(hits, SimTk, SimVtx, matchedhit, trkInfo, multiplicityVector, debug_dummy);
  }

  template <typename T>
  void eCaloSimInfo(std::vector<DetId> vdets,
                    const CaloGeometry* geo,
                    edm::Handle<T>& hitsEB,
                    edm::Handle<T>& hitsEE,
                    edm::Handle<edm::SimTrackContainer>& SimTk,
                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                    edm::SimTrackContainer::const_iterator trkInfo,
                    spr::caloSimInfo& info,
                    double timeCut,
                    bool debug) {
    std::vector<typename T::const_iterator> hitEB, hitEE, hit;
    for (unsigned int i1 = 0; i1 < vdets.size(); i1++) {
      if (vdets[i1] != DetId(0)) {
        if (vdets[i1].subdetId() == EcalBarrel) {
          hit = spr::findHit(hitsEB, vdets[i1]);
          for (unsigned int i2 = 0; i2 < hit.size(); i2++) {
            if (std::count(hitEB.begin(), hitEB.end(), hit[i2]) == 0)
              hitEB.push_back(hit[i2]);
          }
        } else if (vdets[i1].subdetId() == EcalEndcap) {
          hit = spr::findHit(hitsEE, vdets[i1]);
          for (unsigned int i2 = 0; i2 < hit.size(); i2++) {
            if (std::count(hitEE.begin(), hitEE.end(), hit[i2]) == 0)
              hitEE.push_back(hit[i2]);
          }
        }
      }
    }

    spr::caloSimInfo eeInfo;
    spr::eCaloSimInfo(geo, hitsEB, SimTk, SimVtx, hitEB, trkInfo, info, timeCut, false, debug);
    spr::eCaloSimInfo(geo, hitsEE, SimTk, SimVtx, hitEE, trkInfo, eeInfo, timeCut, false, debug);

    if (info.pdgMatched == 0)
      info.pdgMatched = eeInfo.pdgMatched;
    info.eMatched += eeInfo.eMatched;
    info.eGamma += eeInfo.eGamma;
    info.eNeutralHad += eeInfo.eNeutralHad;
    info.eChargedHad += eeInfo.eChargedHad;
    info.eRest += eeInfo.eRest;
    info.eTotal += eeInfo.eTotal;
    if (debug) {
      edm::LogVerbatim("IsoTrack") << " energyMatched " << info.eMatched << " energyGamma   " << info.eGamma
                                   << " energyNeutral " << info.eNeutralHad << " energyCharged " << info.eChargedHad
                                   << " energyRest    " << info.eRest << " energyTotal   " << info.eTotal;
    }
  }

  template <typename T>
  void eCaloSimInfo(const CaloGeometry* geo,
                    edm::Handle<T>& hits,
                    edm::Handle<edm::SimTrackContainer>& SimTk,
                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                    std::vector<typename T::const_iterator> hit,
                    edm::SimTrackContainer::const_iterator trkInfo,
                    spr::caloSimInfo& info,
                    double timeCut,
                    bool includeHO,
                    bool debug) {
    int matchedId = 0;  //pdgid
    if (debug) {
      if (trkInfo != SimTk->end())
        edm::LogVerbatim("IsoTrack") << "In eCaloSimInfo::  matchSimTrk:" << trkInfo->trackId() << " matchedId "
                                     << trkInfo->type();
      else
        edm::LogVerbatim("IsoTrack") << "In eCaloSimInfo::  not valid track pointer";
    }

    if (trkInfo != SimTk->end()) {
      unsigned int matchSimTrk = trkInfo->trackId();
      matchedId = trkInfo->type();  //pdgid

      for (unsigned int ihit = 0; ihit < hit.size(); ihit++) {
        DetId id_ = (DetId)(hit[ihit]->id());
        double tof = timeOfFlight(id_, geo, debug);
        bool ok = true;
        if (((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalForward)))
          ok = false;
        if ((!includeHO) && ((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalOuter)))
          ok = false;
        if ((hit[ihit]->time() <= (tof + timeCut)) && ok) {
          // if the hitId matches with matching trackId
          if (hit[ihit]->geantTrackId() == (int)matchSimTrk) {
            info.eMatched += hit[ihit]->energy();
          } else {
            // trace back the history and check the pdgId of origin SimTrack of SimHit
            bool found = false;
            for (auto simTrkItr = SimTk->begin(); simTrkItr != SimTk->end(); simTrkItr++) {
              if (hit[ihit]->geantTrackId() == (int)simTrkItr->trackId()) {
                found = true;
                bool match = spr::validSimTrack(matchSimTrk, simTrkItr, SimTk, SimVtx, debug);
                if (match) {
                  info.eMatched += hit[ihit]->energy();
                } else {
                  edm::SimTrackContainer::const_iterator parentItr =
                      spr::parentSimTrack(simTrkItr, SimTk, SimVtx, debug);
                  if (debug) {
                    if (parentItr != SimTk->end())
                      edm::LogVerbatim("IsoTrack")
                          << "original parent of " << simTrkItr->trackId() << " " << parentItr->trackId() << ", "
                          << parentItr->type() << " Energy " << hit[ihit]->energy();
                    else
                      edm::LogVerbatim("IsoTrack") << "original parent of " << simTrkItr->trackId()
                                                   << " not found; Energy " << hit[ihit]->energy();
                  }
                  if (parentItr == SimTk->end()) {
                    info.eRest += hit[ihit]->energy();
                  } else if (parentItr->type() == 22) {
                    info.eGamma += hit[ihit]->energy();
                  } else if ((int)parentItr->charge() == 0) {
                    info.eNeutralHad += hit[ihit]->energy();
                  } else
                    info.eChargedHad += hit[ihit]->energy();
                }
                break;
              }
            }
            if (!found)
              info.eRest += hit[ihit]->energy();
            if (debug)
              edm::LogVerbatim("IsoTrack") << "Hit " << ihit << ": " << *hit[ihit];
          }
        }
      }  // loop over hits
    }

    info.eTotal = info.eMatched + info.eGamma + info.eNeutralHad + info.eChargedHad + info.eRest;
    info.pdgMatched = matchedId;
    if (debug) {
      edm::LogVerbatim("IsoTrack") << " Energy (matched) " << info.eMatched << " (gamma) " << info.eGamma
                                   << " (neutral) " << info.eNeutralHad << " (charged) " << info.eChargedHad
                                   << " (rest) " << info.eRest << " (total) " << info.eTotal;
    }
  }

  inline std::map<std::string, double> eCaloSimInfo(spr::caloSimInfo& info) {
    std::map<std::string, double> simInfo;
    simInfo.insert(std::pair<std::string, double>("eMatched", info.eMatched));
    simInfo.insert(std::pair<std::string, double>("pdgMatched", info.pdgMatched));
    simInfo.insert(std::pair<std::string, double>("eGamma", info.eGamma));
    simInfo.insert(std::pair<std::string, double>("eNeutralHad", info.eNeutralHad));
    simInfo.insert(std::pair<std::string, double>("eChargedHad", info.eChargedHad));
    simInfo.insert(std::pair<std::string, double>("eRest", info.eRest));
    simInfo.insert(std::pair<std::string, double>("eTotal", info.eTotal));
    return simInfo;
  }

  // Returns total energy of CaloSimHits which originate from the matching SimTrack
  template <typename T>
  double eCaloSimInfo(const edm::Event& iEvent,
                      const CaloGeometry* geo,
                      edm::Handle<T>& hits,
                      edm::Handle<edm::SimTrackContainer>& SimTk,
                      edm::Handle<edm::SimVertexContainer>& SimVtx,
                      const reco::Track* pTrack,
                      TrackerHitAssociator& associate,
                      double timeCut,
                      bool includeHO,
                      bool debug) {
    //
    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);
    double energySum = 0.0;
    if (debug) {
      std::ostringstream st1;
      for (unsigned int it = 0; it < matchedId.size(); ++it)
        st1 << " " << matchedId[it];
      edm::LogVerbatim("IsoTrack") << "eCaloSimInfo:: Found " << matchedId.size()
                                   << " track IDs originating from the current track" << st1.str();
    }
    if (!matchedId.empty()) {
      typename T::const_iterator ihit;
      for (ihit = hits->begin(); ihit != hits->end(); ihit++) {
        //cut on time
        DetId id_ = (DetId)(ihit->id());
        double tof = timeOfFlight(id_, geo, debug);
        bool ok = true;
        if (((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalForward)))
          ok = false;
        if ((!includeHO) && ((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalOuter)))
          ok = false;
        if ((ihit->time() <= (tof + timeCut)) && ok) {
          int id = ihit->geantTrackId();
          bool found = false;
          for (unsigned int it = 0; it < matchedId.size(); ++it) {
            if (id == matchedId[it]) {
              found = true;
              break;
            }
          }
          if (found) {
            energySum += ihit->energy();
            if (debug)
              edm::LogVerbatim("IsoTrack") << "Hit " << *ihit;
          }
        }
      }
    }
    return energySum;
  }

  template <typename T>
  double eCaloSimInfo(const edm::Event& iEvent,
                      const CaloGeometry* geo,
                      edm::Handle<T>& hitsEB,
                      edm::Handle<T>& hitsEE,
                      edm::Handle<edm::SimTrackContainer>& SimTk,
                      edm::Handle<edm::SimVertexContainer>& SimVtx,
                      const reco::Track* pTrack,
                      TrackerHitAssociator& associate,
                      double timeCut,
                      bool debug) {
    //
    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);
    double energySum = 0.0;
    if (debug) {
      std::ostringstream st1;
      for (unsigned int it = 0; it < matchedId.size(); ++it)
        st1 << " " << matchedId[it];
      edm::LogVerbatim("IsoTrack") << "eCaloSimInfo:: Found " << matchedId.size()
                                   << " track IDs originating from the current track" << st1.str();
    }
    if (!matchedId.empty()) {
      typename T::const_iterator ihit;
      for (ihit = hitsEB->begin(); ihit != hitsEB->end(); ihit++) {
        //cut on time
        double tof = timeOfFlight((DetId)(ihit->id()), geo, debug);
        if (ihit->time() <= (tof + timeCut)) {
          int id = ihit->geantTrackId();
          bool found = false;
          for (unsigned int it = 0; it < matchedId.size(); ++it) {
            if (id == matchedId[it]) {
              found = true;
              break;
            }
          }
          if (found) {
            energySum += ihit->energy();
            if (debug)
              edm::LogVerbatim("IsoTrack") << "Hit " << *ihit;
          }
        }
      }
      for (ihit = hitsEE->begin(); ihit != hitsEE->end(); ihit++) {
        //cut on time
        double tof = timeOfFlight((DetId)(ihit->id()), geo, debug);
        if (ihit->time() <= (tof + timeCut)) {
          int id = ihit->geantTrackId();
          bool found = false;
          for (unsigned int it = 0; it < matchedId.size(); ++it) {
            if (id == matchedId[it]) {
              found = true;
              break;
            }
          }
          if (found) {
            energySum += ihit->energy();
            if (debug)
              edm::LogVerbatim("IsoTrack") << "Hit " << *ihit;
          }
        }
      }
    }
    return energySum;
  }

  template <typename T>
  std::map<std::string, double> eCaloSimInfo(edm::Handle<T>& hits,
                                             edm::Handle<edm::SimTrackContainer>& SimTk,
                                             edm::Handle<edm::SimVertexContainer>& SimVtx,
                                             std::vector<typename T::const_iterator> hit,
                                             edm::SimTrackContainer::const_iterator trkInfo,
                                             std::vector<int>& multiplicityVector,
                                             bool debug) {
    int matchedId = 0;  //pdgid

    if (debug) {
      if (trkInfo != SimTk->end()) {
        edm::LogVerbatim("IsoTrack") << "In eCaloSimInfo::  matchSimTrk:" << trkInfo->trackId() << " matchedId "
                                     << trkInfo->type();
      } else {
        edm::LogVerbatim("IsoTrack") << "In eCaloSimInfo::  not valid track pointer";
      }
    }

    // Find sets of hcal cells with energy
    // Use std::set to avoid duplicates

    std::set<int> uniqueIds_;
    std::set<int> uniqueIds_matched;
    std::set<int> uniqueIds_total;
    std::set<int> uniqueIds_neut;
    std::set<int> uniqueIds_char;
    std::set<int> uniqueIds_gamma;
    std::set<int> uniqueIds_rest;

    // Counters for SimHits
    double energySum = 0.0;
    double energyGamma = 0.0, energyNeutral = 0.0, energyCharged = 0.0, energyRest = 0.0;

    // What is this checking?
    if (trkInfo != SimTk->end()) {
      unsigned int matchSimTrk = trkInfo->trackId();
      matchedId = trkInfo->type();  //pdgid

      // Loop over hits
      for (unsigned int ihit = 0; ihit < hit.size(); ihit++) {
        // For simhit tower multiplicity, we need to avoid double
        // counting towers with multiple simhits:
        // This will break if called for pcalohits from the ecal!!
        HcalDetId detId(hit[ihit]->id());
        int ieta = detId.ieta();
        int iphi = detId.iphi();
        int uniqueId = 100 * ieta + iphi;

        if (hit[ihit]->time() > 150.0)
          continue;

        if (hit[ihit]->geantTrackId() == (int)matchSimTrk) {
          energySum += spr::getEnergy(hit[ihit]);
          uniqueIds_matched.insert(uniqueId);
          uniqueIds_total.insert(uniqueId);
        } else {
          bool found = false;
          for (auto simTrkItr = SimTk->begin(); simTrkItr != SimTk->end(); simTrkItr++) {
            if (hit[ihit]->geantTrackId() == (int)simTrkItr->trackId()) {
              found = true;
              bool match = spr::validSimTrack(matchSimTrk, simTrkItr, SimTk, SimVtx, debug);
              if (match) {
                energySum += spr::getEnergy(hit[ihit]);
                uniqueIds_matched.insert(uniqueId);
                uniqueIds_total.insert(uniqueId);
              } else {
                edm::SimTrackContainer::const_iterator parentItr = spr::parentSimTrack(simTrkItr, SimTk, SimVtx, debug);
                if (debug) {
                  if (parentItr != SimTk->end()) {
                    edm::LogVerbatim("IsoTrack")
                        << "original parent of " << simTrkItr->trackId() << " " << parentItr->trackId() << ", "
                        << parentItr->type() << " Energy " << spr::getEnergy(hit[ihit]);
                  } else {
                    edm::LogVerbatim("IsoTrack") << "original parent of " << simTrkItr->trackId()
                                                 << " not found; Energy " << spr::getEnergy(hit[ihit]);
                  }
                }
                if (parentItr == SimTk->end()) {
                  energyRest += spr::getEnergy(hit[ihit]);
                  uniqueIds_rest.insert(uniqueId);
                  uniqueIds_total.insert(uniqueId);
                } else if (parentItr->type() == 22) {
                  energyGamma += spr::getEnergy(hit[ihit]);
                  uniqueIds_gamma.insert(uniqueId);
                  uniqueIds_total.insert(uniqueId);
                } else if ((int)parentItr->charge() == 0) {
                  energyNeutral += spr::getEnergy(hit[ihit]);
                  uniqueIds_neut.insert(uniqueId);
                  uniqueIds_total.insert(uniqueId);
                } else {
                  energyCharged += spr::getEnergy(hit[ihit]);
                  uniqueIds_char.insert(uniqueId);
                  uniqueIds_total.insert(uniqueId);
                }
              }
              break;
            }
          }  // for (simTrkItr = ...)

          if (!found) {
            energyRest += spr::getEnergy(hit[ihit]);
            uniqueIds_rest.insert(uniqueId);
            uniqueIds_total.insert(uniqueId);
          }

          if (debug)
            edm::LogVerbatim("IsoTrack") << "Hit " << ihit << ": " << *hit[ihit];
        }  // else condition, i.e. (hit[ihit]->geantTrackId() != (int)matchSimTrk )
      }    // loop over hits
    }      // if (trkInfo != SimTk->end())

    double energyTot = energySum + energyGamma + energyNeutral + energyCharged + energyRest;
    multiplicityVector.push_back(uniqueIds_matched.size());
    multiplicityVector.push_back(uniqueIds_total.size());
    multiplicityVector.push_back(uniqueIds_neut.size());
    multiplicityVector.push_back(uniqueIds_char.size());
    multiplicityVector.push_back(uniqueIds_gamma.size());
    multiplicityVector.push_back(uniqueIds_rest.size());

    std::map<std::string, double> simInfo;
    simInfo.insert(std::pair<std::string, double>("eMatched", energySum));
    simInfo.insert(std::pair<std::string, double>("pdgMatched", matchedId));
    simInfo.insert(std::pair<std::string, double>("eGamma", energyGamma));
    simInfo.insert(std::pair<std::string, double>("eNeutralHad", energyNeutral));
    simInfo.insert(std::pair<std::string, double>("eChargedHad", energyCharged));
    simInfo.insert(std::pair<std::string, double>("eRest", energyRest));
    simInfo.insert(std::pair<std::string, double>("eTotal", energyTot));
    if (debug) {
      edm::LogVerbatim("IsoTrack") << " energySum " << energySum << "  energyGamma " << energyGamma
                                   << "  energyNeutral " << energyNeutral << "  energyCharged " << energyCharged
                                   << "  energyRest " << energyRest << "  energyTot " << energyTot;
    }
    return simInfo;
  }  // eCaloSimInfo

  template <typename T>
  std::map<std::string, double> eECALSimInfo(const edm::Event& iEvent,
                                             CaloNavigator<DetId>& navigator,
                                             const CaloGeometry* geo,
                                             edm::Handle<T>& hits,
                                             edm::Handle<edm::SimTrackContainer>& SimTk,
                                             edm::Handle<edm::SimVertexContainer>& SimVtx,
                                             const reco::Track* pTrack,
                                             TrackerHitAssociator& associate,
                                             int ieta,
                                             int iphi,
                                             double timeCut,
                                             bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eECALSimInfo " << 2 * ieta + 1 << "x" << 2 * iphi + 1 << "\ntrkMom "
                                   << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);
    //vector of Ecal hits in NxN
    std::vector<typename T::const_iterator> ecalHits;
    spr::hitECALmatrix(navigator, hits, ieta, iphi, ecalHits, debug);

    // return a map of matching type and energy of SimHits
    spr::caloSimInfo info;
    spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, ecalHits, trkInfo, info, timeCut, false, debug);
    return spr::eCaloSimInfo(info);
  }

  template <typename T>
  std::map<std::string, double> eECALSimInfoTotal(const edm::Event& iEvent,
                                                  const DetId& det,
                                                  const CaloGeometry* geo,
                                                  const CaloTopology* caloTopology,
                                                  edm::Handle<T>& hitsEB,
                                                  edm::Handle<T>& hitsEE,
                                                  edm::Handle<edm::SimTrackContainer>& SimTk,
                                                  edm::Handle<edm::SimVertexContainer>& SimVtx,
                                                  const reco::Track* pTrack,
                                                  TrackerHitAssociator& associate,
                                                  int ieta,
                                                  int iphi,
                                                  int itry,
                                                  double timeCut,
                                                  bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eECALSimInfo " << 2 * ieta + 1 << "x" << 2 * iphi + 1 << "\ntrkMom "
                                   << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    spr::EtaPhi etaphi = spr::getEtaPhi(ieta, iphi, debug);
    std::map<std::string, double> simInfo;

    if (itry >= 0) {
      //vector of Ecal cells in NxN
      std::vector<DetId> vdets = spr::matrixECALIds(
          det, etaphi.ietaE[itry], etaphi.ietaW[itry], etaphi.iphiN[itry], etaphi.iphiS[itry], geo, caloTopology, debug);
      // get a map of matching type and energy of SimHits
      spr::caloSimInfo info;
      spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, info, timeCut, debug);
      simInfo = spr::eCaloSimInfo(info);
    } else {
      int itrym = 0;
      std::vector<DetId> vdets = spr::matrixECALIds(det,
                                                    etaphi.ietaE[itrym],
                                                    etaphi.ietaW[itrym],
                                                    etaphi.iphiN[itrym],
                                                    etaphi.iphiS[itrym],
                                                    geo,
                                                    caloTopology,
                                                    debug);
      // get a map of matching type and energy of SimHits
      spr::caloSimInfo info;
      spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, info, timeCut, debug);
      simInfo = spr::eCaloSimInfo(info);
      for (int itrys = 1; itrys < etaphi.ntrys; ++itrys) {
        vdets = spr::matrixECALIds(det,
                                   etaphi.ietaE[itrys],
                                   etaphi.ietaW[itrys],
                                   etaphi.iphiN[itrys],
                                   etaphi.iphiS[itrys],
                                   geo,
                                   caloTopology,
                                   debug);
        // get a map of matching type and energy of SimHits
        spr::caloSimInfo infox;
        spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, infox, timeCut, debug);
        std::map<std::string, double> simInfoX = spr::eCaloSimInfo(infox);
        if (simInfoX["eTotal"] > simInfo["eTotal"]) {
          simInfo = simInfoX;
          itrym = itrys;
        }
      }
    }
    return simInfo;
  }

  template <typename T>
  std::map<std::string, double> eHCALSimInfoTotal(const edm::Event& iEvent,
                                                  const HcalTopology* topology,
                                                  const DetId& det,
                                                  const CaloGeometry* geo,
                                                  edm::Handle<T>& hits,
                                                  edm::Handle<edm::SimTrackContainer>& SimTk,
                                                  edm::Handle<edm::SimVertexContainer>& SimVtx,
                                                  const reco::Track* pTrack,
                                                  TrackerHitAssociator& associate,
                                                  int ieta,
                                                  int iphi,
                                                  int itry,
                                                  double timeCut,
                                                  bool includeHO,
                                                  bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eHCALSimInfo " << 2 * ieta + 1 << "x" << 2 * iphi + 1 << "\ntrkMom "
                                   << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    spr::EtaPhi etaphi = spr::getEtaPhi(ieta, iphi, debug);
    std::map<std::string, double> simInfo;

    if (itry >= 0) {
      // get the hits in Hcal in NxN around det
      std::vector<typename T::const_iterator> hit;
      spr::hitHCALmatrixTotal(topology,
                              det,
                              hits,
                              etaphi.ietaE[itry],
                              etaphi.ietaW[itry],
                              etaphi.iphiN[itry],
                              etaphi.iphiS[itry],
                              hit,
                              false,
                              debug);
      spr::caloSimInfo info;
      spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, info, timeCut, includeHO, debug);
      simInfo = spr::eCaloSimInfo(info);
    } else {
      int itrym = 0;
      std::vector<typename T::const_iterator> hit;
      spr::hitHCALmatrixTotal(topology,
                              det,
                              hits,
                              etaphi.ietaE[itrym],
                              etaphi.ietaW[itrym],
                              etaphi.iphiN[itrym],
                              etaphi.iphiS[itrym],
                              hit,
                              includeHO,
                              debug);
      spr::caloSimInfo info;
      spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, info, timeCut, includeHO, debug);
      simInfo = spr::eCaloSimInfo(info);
      for (int itrys = 1; itrys < etaphi.ntrys; ++itrys) {
        hit.clear();
        spr::hitHCALmatrixTotal(topology,
                                det,
                                hits,
                                etaphi.ietaE[itrys],
                                etaphi.ietaW[itrys],
                                etaphi.iphiN[itrys],
                                etaphi.iphiS[itrys],
                                hit,
                                includeHO,
                                debug);
        spr::caloSimInfo infox;
        spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, infox, timeCut, includeHO, debug);
        std::map<std::string, double> simInfoX = spr::eCaloSimInfo(infox);
        if (simInfoX["eTotal"] > simInfo["eTotal"]) {
          simInfo = simInfoX;
          itrym = itrys;
        }
      }
    }
    return simInfo;
  }

  template <typename T>
  spr::energyMap eHCALSimInfoMatrix(const edm::Event& iEvent,
                                    const HcalTopology* topology,
                                    const DetId& det,
                                    const CaloGeometry* geo,
                                    edm::Handle<T>& hits,
                                    edm::Handle<edm::SimTrackContainer>& SimTk,
                                    edm::Handle<edm::SimVertexContainer>& SimVtx,
                                    const reco::Track* pTrack,
                                    TrackerHitAssociator& associate,
                                    int ieta,
                                    int iphi,
                                    double timeCut,
                                    bool includeHO,
                                    bool debug) {
    if (debug)
      edm::LogVerbatim("IsoTrack") << "Processing eHCALSimInfoMatrix " << 2 * ieta + 1 << "x" << 2 * iphi + 1
                                   << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo =
        spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    // get the hits in Hcal in NxN around det
    std::vector<typename T::const_iterator> hit;
    spr::hitHCALmatrix(topology, det, hits, ieta, iphi, hit, includeHO, debug);

    return spr::caloSimInfoMatrix(geo, hits, SimTk, SimVtx, hit, trkInfo, timeCut, includeHO, debug);
  }

  template <typename T>
  spr::energyMap caloSimInfoMatrix(const CaloGeometry* geo,
                                   edm::Handle<T>& hits,
                                   edm::Handle<edm::SimTrackContainer>& SimTk,
                                   edm::Handle<edm::SimVertexContainer>& SimVtx,
                                   std::vector<typename T::const_iterator> hit,
                                   edm::SimTrackContainer::const_iterator trkInfo,
                                   double timeCut,
                                   bool includeHO,
                                   bool debug) {
    int matchedId = 0;  //pdgid

    if (debug) {
      if (trkInfo != SimTk->end())
        edm::LogVerbatim("IsoTrack") << "In eCaloSimInfo::  matchSimTrk:" << trkInfo->trackId() << " matchedId "
                                     << trkInfo->type();
      else
        edm::LogVerbatim("IsoTrack") << "In eCaloSimInfo::  not valid track pointer";
    }

    std::vector<std::pair<DetId, double> > detSum, detGamma, detCharged, detNeutral, detRest, detAll;

    if (trkInfo != SimTk->end()) {
      unsigned int matchSimTrk = trkInfo->trackId();
      matchedId = trkInfo->type();  //pdgid

      edm::SimTrackContainer::const_iterator simTrkItr;

      for (unsigned int ihit = 0; ihit < hit.size(); ihit++) {
        DetId id_ = (DetId)(hit[ihit]->id());
        double tof = timeOfFlight(id_, geo, debug);
        double energySum = 0, energyRest = 0;
        double energyGamma = 0, energyNeutral = 0, energyCharged = 0;
        bool ok = true;
        if (((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalForward)))
          ok = false;
        if ((!includeHO) && ((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalOuter)))
          ok = false;
        if ((hit[ihit]->time() <= (tof + timeCut)) && ok) {
          // if the hitId matches with matching trackId
          if (hit[ihit]->geantTrackId() == (int)matchSimTrk) {
            energySum = hit[ihit]->energy();
          } else {
            // trace back the history and check the pdgId of origin SimTrack of SimHit
            bool found = false;
            for (simTrkItr = SimTk->begin(); simTrkItr != SimTk->end(); simTrkItr++) {
              if (hit[ihit]->geantTrackId() == (int)simTrkItr->trackId()) {
                found = true;
                bool match = spr::validSimTrack(matchSimTrk, simTrkItr, SimTk, SimVtx, debug);
                if (match) {
                  energySum = hit[ihit]->energy();
                } else {
                  edm::SimTrackContainer::const_iterator parentItr =
                      spr::parentSimTrack(simTrkItr, SimTk, SimVtx, debug);
                  if (debug) {
                    if (parentItr != SimTk->end())
                      edm::LogVerbatim("IsoTrack")
                          << "original parent of " << simTrkItr->trackId() << " " << parentItr->trackId() << ", "
                          << parentItr->type() << " Energy " << hit[ihit]->energy();
                    else
                      edm::LogVerbatim("IsoTrack") << "original parent of " << simTrkItr->trackId()
                                                   << " not found; Energy " << hit[ihit]->energy();
                  }
                  if (parentItr == SimTk->end()) {
                    energyRest = hit[ihit]->energy();
                  } else if (parentItr->type() == 22) {
                    energyGamma = hit[ihit]->energy();
                  } else if ((int)parentItr->charge() == 0) {
                    energyNeutral = hit[ihit]->energy();
                  } else
                    energyCharged = hit[ihit]->energy();
                }
                break;
              }
            }
            if (!found)
              energyRest = hit[ihit]->energy();
            if (debug)
              edm::LogVerbatim("IsoTrack") << "Hit " << ihit << ": " << *hit[ihit];
            found = false;
            if (energySum > 0) {
              for (unsigned int k = 0; k < detSum.size(); k++) {
                if (id_ == detSum[k].first) {
                  found = true;
                  detSum[k].second += energySum;
                  break;
                }
              }
              if (!found)
                detSum.push_back(std::pair<DetId, double>(id_, energySum));
            } else if (energyRest > 0) {
              for (unsigned int k = 0; k < detRest.size(); k++) {
                if (id_ == detRest[k].first) {
                  found = true;
                  detRest[k].second += energyRest;
                  break;
                }
              }
              if (!found)
                detRest.push_back(std::pair<DetId, double>(id_, energyRest));
            } else if (energyGamma > 0) {
              for (unsigned int k = 0; k < detGamma.size(); k++) {
                if (id_ == detGamma[k].first) {
                  found = true;
                  detGamma[k].second += energyGamma;
                  break;
                }
              }
              if (!found)
                detGamma.push_back(std::pair<DetId, double>(id_, energyGamma));
            } else if (energyCharged > 0) {
              for (unsigned int k = 0; k < detCharged.size(); k++) {
                if (id_ == detCharged[k].first) {
                  found = true;
                  detCharged[k].second += energyCharged;
                  break;
                }
              }
              if (!found)
                detCharged.push_back(std::pair<DetId, double>(id_, energyCharged));
            } else if (energyNeutral > 0) {
              for (unsigned int k = 0; k < detNeutral.size(); k++) {
                if (id_ == detNeutral[k].first) {
                  found = true;
                  detNeutral[k].second += energyNeutral;
                  break;
                }
              }
              if (!found)
                detNeutral.push_back(std::pair<DetId, double>(id_, energyNeutral));
            }
            found = false;
            double energyTot = energySum + energyGamma + energyNeutral + energyCharged + energyRest;
            for (unsigned int k = 0; k < detAll.size(); k++) {
              if (id_ == detAll[k].first) {
                found = true;
                detAll[k].second += energyTot;
                break;
              }
            }
            if (!found)
              detAll.push_back(std::pair<DetId, double>(id_, energyTot));
          }
        }
      }  // loop over hits
    }

    spr::energyMap simInfo;
    simInfo.pdgId = matchedId;
    simInfo.matched = detSum;
    simInfo.gamma = detGamma;
    simInfo.charged = detCharged;
    simInfo.neutral = detNeutral;
    simInfo.rest = detRest;
    simInfo.all = detAll;
    if (debug) {
      edm::LogVerbatim("IsoTrack") << "CaloSimInfo:: for particle " << simInfo.pdgId << "\n"
                                   << "All detIds " << detAll.size();
      for (unsigned int k = 0; k < detAll.size(); ++k)
        edm::LogVerbatim("IsoTrack") << k << " detId 0x" << std::hex << detAll[k].first.rawId() << std::dec
                                     << detAll[k].second;
      edm::LogVerbatim("IsoTrack") << "Matched detIds" << detSum.size();
      for (unsigned int k = 0; k < detSum.size(); ++k)
        edm::LogVerbatim("IsoTrack") << k << " detId 0x" << std::hex << detSum[k].first.rawId() << std::dec
                                     << detSum[k].second;
      edm::LogVerbatim("IsoTrack") << "Gamma detIds" << detGamma.size();
      for (unsigned int k = 0; k < detGamma.size(); ++k)
        edm::LogVerbatim("IsoTrack") << k << " detId 0x" << std::hex << detGamma[k].first.rawId() << std::dec
                                     << detGamma[k].second;
      edm::LogVerbatim("IsoTrack") << "Charged detIds" << detSum.size();
      for (unsigned int k = 0; k < detCharged.size(); ++k)
        edm::LogVerbatim("IsoTrack") << k << " detId 0x" << std::hex << detCharged[k].first.rawId() << std::dec
                                     << detCharged[k].second;
      edm::LogVerbatim("IsoTrack") << "Neutral detIds" << detNeutral.size();
      for (unsigned int k = 0; k < detNeutral.size(); ++k)
        edm::LogVerbatim("IsoTrack") << k << " detId 0x" << std::hex << detNeutral[k].first.rawId() << std::dec
                                     << detNeutral[k].second;
      edm::LogVerbatim("IsoTrack") << "Rest detIds" << detRest.size();
      for (unsigned int k = 0; k < detRest.size(); ++k)
        edm::LogVerbatim("IsoTrack") << k << " detId 0x" << std::hex << detRest[k].first.rawId() << std::dec
                                     << detRest[k].second;
    }
    return simInfo;
  }

  template <typename T>
  std::vector<typename T::const_iterator> missedECALHits(const edm::Event& iEvent,
                                                         CaloNavigator<DetId>& navigator,
                                                         edm::Handle<T>& hits,
                                                         edm::Handle<edm::SimTrackContainer>& SimTk,
                                                         edm::Handle<edm::SimVertexContainer>& SimVtx,
                                                         const reco::Track* pTrack,
                                                         TrackerHitAssociator& associate,
                                                         int ieta,
                                                         int iphi,
                                                         bool flag,
                                                         bool debug) {
    if (debug) {
      edm::LogVerbatim("IsoTrack") << "Processing missedECALHits " << 2 * ieta + 1 << "x" << 2 * iphi + 1
                                   << " and Flag " << flag;
      edm::LogVerbatim("IsoTrack") << "trkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();
    }

    std::vector<typename T::const_iterator> ecalHits;
    spr::hitECALmatrix(navigator, hits, ieta, iphi, ecalHits, debug);

    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    return spr::missedCaloHits(hits, matchedId, ecalHits, flag, false, debug);
  }

  template <typename T>
  std::vector<typename T::const_iterator> missedHCALHits(const edm::Event& iEvent,
                                                         const HcalTopology* topology,
                                                         const DetId& det,
                                                         edm::Handle<T>& hits,
                                                         edm::Handle<edm::SimTrackContainer>& SimTk,
                                                         edm::Handle<edm::SimVertexContainer>& SimVtx,
                                                         const reco::Track* pTrack,
                                                         TrackerHitAssociator& associate,
                                                         int ieta,
                                                         int iphi,
                                                         bool flag,
                                                         bool includeHO,
                                                         bool debug) {
    if (debug) {
      edm::LogVerbatim("IsoTrack") << "Processing missedHCALHits " << 2 * ieta + 1 << "x" << 2 * iphi + 1
                                   << " and Flag " << flag;
      edm::LogVerbatim("IsoTrack") << "trkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits "
                                   << pTrack->recHitsSize();
    }

    std::vector<typename T::const_iterator> hit;
    spr::hitHCALmatrix(topology, det, hits, ieta, iphi, hit, includeHO, debug);

    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    return spr::missedCaloHits(hits, matchedId, hit, flag, includeHO, debug);
  }

  template <typename T>
  std::vector<typename T::const_iterator> missedCaloHits(edm::Handle<T>& hits,
                                                         std::vector<int> matchedId,
                                                         std::vector<typename T::const_iterator> caloHits,
                                                         bool flag,
                                                         bool includeHO,
                                                         bool debug) {
    std::vector<typename T::const_iterator> missedHits;
    std::vector<typename T::const_iterator> usedHits;
    if (!matchedId.empty()) {
      typename T::const_iterator ihit;
      for (ihit = hits->begin(); ihit != hits->end(); ihit++) {
        int id = ihit->geantTrackId();
        bool found = false;
        for (unsigned int it = 0; it < matchedId.size(); ++it) {
          if (id == matchedId[it]) {
            found = true;
            break;
          }
        }
        DetId id_ = (DetId)(ihit->id());
        bool ok = true;
        if (((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalForward)))
          ok = false;
        if ((!includeHO) && ((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalOuter)))
          ok = false;
        if (found && ok) {
          if (flag) {
            if (count(caloHits.begin(), caloHits.end(), ihit) == 0)
              missedHits.push_back(ihit);
          } else {
            usedHits.push_back(ihit);
          }
        }
      }
    }
    if (!flag) {
      for (unsigned int ii = 0; ii < caloHits.size(); ii++) {
        DetId id_ = (DetId)(caloHits[ii]->id());
        bool ok = true;
        if (((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalForward)))
          ok = false;
        if ((!includeHO) && ((int)(id_.det()) == 4) && (id_.subdetId() == (int)(HcalOuter)))
          ok = false;
        if (count(usedHits.begin(), usedHits.end(), caloHits[ii]) == 0 && ok)
          missedHits.push_back(caloHits[ii]);
      }
    }
    if (debug) {
      edm::LogVerbatim("IsoTrack") << "missedCaloHits finds " << missedHits.size() << " missed hits";
      for (unsigned int i = 0; i < missedHits.size(); i++)
        edm::LogVerbatim("IsoTrack") << "Hit " << i << " " << *missedHits[i];
    }
    return missedHits;
  }

}  // namespace spr
