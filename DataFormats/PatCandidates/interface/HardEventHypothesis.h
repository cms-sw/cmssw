#ifndef DataFormats_PatCandidates_interface_HardEventHypothesis_h
#define DataFormats_PatCandidates_interface_HardEventHypothesis_h



// -*- C++ -*-
//// -*- C++ -*-
//
// Package:    HardEventHypothesis
// Class:      HardEventHypothesis
//
/**


*/
//-------------------------------------------------------------------------------------
//!\class pat::HardEventHypothesis HardEventHypothesis.cc DataFormats/PatCandidates/interface/HardEventHypothesis.h
//!\brief HardEventHypothesis is a pure virtual base class to implement a "hard" event hypothesis class.
//!
//! The idea of HardEventHypothesis is to act as the definition of the interface of a user-defined 
//! event hypothesis class. This class is what generic plotting utilities like the StarterKit
//! will be using to interface with all of the plethora of derived classes that are forseen to
//! exist inheriting from this class. 
//! 
//! Ultimately the interface to the StarterKit is defined by the two virtual functions
//!
//!    virtual Candidate *                getCandidate       (std::string name) = 0;
//!    virtual std::vector<Candidate *> & getCandidateVector (std::string name) = 0;
//!
//! The specific implementation of the concrete derived class must overload these operators
//! with logic that gives the right role<--->candidate mapping.
//! 
//! As a concrete example, examine
//!
//!    class ZPlusJetsHypothesis : public UserEventHypothesis {
//!    public:
//!       pat::Muon &                 getMuon1();
//!       pat::Muon &                 getMuon2();
//!       std::vector<pat::Jet> &     getJets();
//!    
//!       void setMuon1( const pat::Muon & muon1, std::string sMuon1);
//!       void setMuon2( const pat::Muon & muon2, std::string sMuon2);
//!       void setJets ( const std::vector<pat::Jet> & jets, std::string sJets);
//!    
//!    virtual Candidate *                getCandidate       (std::string name);
//!    virtual std::vector<Candidate*>  & getCandidateVector (std::string name);
//!    
//!    protected:
//!       pat::Muon              muon1_;
//!       pat::Muon              muon2_;
//!       std::vector<pat::Jet>  jets_;
//!    
//!    };
//!
//! The user must overload getCandidate and getCandidateVector as:
//! 
//! Candidate * getCandidate( std::string name ) {
//!   if      ( name == "muon1" ) return muon1_;
//!   else if ( name == "muon2" ) return muon2_;
//!   else return 0;
//! }
//!
//! vector<Candidate*> & getCandidateVector( std::string name ) {
//!   if      ( name == "jets" ) return jets_;
//!   else return 0;
//! }
//! 
//! The StarterKit and it's derived classes will then be implementing decision logic based
//! on dynamic type casting. This will be hidden from the user. 
//! 
//! The user code will have a skeleton generated by a perl script which will
//! create "specific" get functions that the users should be using to access internal information.
//!
//! For example,
//! 
//!      Muon &        getMuon1() { return *(dynamic_cast<Muon *>( & getCandidate("muon1") )); }
//!      Muon &        getMuon2() { return *(dynamic_cast<Muon *>( & getCandidate("muon2") )); }
//!      Jet &         getJet  (int i = 0)  { return *(dynamic_cast<Jet *> (& getCandidateVector("jets").at(i))); }
//! 
//! This obviates the need for users to deal with dynamic type casting while retaining full capability for
//! polymorphism in the friend classes derived from StarterKit. Ideally, the user will be implementing
//! a "Kit" to go along with their hypothesis formation that will rely on the public "hypothesis-specific" methods,
//! while only the actual StarterKit will be using the generic interface from the base class. 
//!
//-------------------------------------------------------------------------------------
//
// Original Author:  Salvatore Rappoccio
//         Created:  Tue Feb 12 14:42:17 CST 2008
//
// Revision History:
//




#include "DataFormats/Candidate/interface/Candidate.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/PatCandidates/interface/Photon.h"
#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/Candidate/interface/CompositeCandidate.h"
#include <vector>

class StarterKit;

namespace pat {

  class HardEventHypothesis {
  public:

    // Allow StarterKit to access the internal members of this class
    friend class StarterKit;

    // Setting quality member
    inline void           setQuality( float q ) { quality_ = q;}

    // Getting quality member
    inline float          getQuality() const { return quality_; }

    // This will return static event-wide definitions of the candidate roles.
    virtual const char *  getCandidateRole ( int i = 0 ) const = 0;
    // This will return static event-wide boolean to see if the role is a vector or not
    virtual bool          getIsVector(int i = 0) const = 0;

  protected:

    // Pure virtual function to access members polymorphically in the StarterKit, etc.
    // The user should not use these classes.
    // If irole == -1, then there is no vector access. If it is >= 0, then that corresponds
    // to the role index (for instance, in Z+jets,  getCandidate("jets", 2) would return the 3rd
    // jet in the jet list. 
    virtual reco::Candidate &                getCandidate       (std::string name, int irole = -1) = 0;

    float              quality_;
  };

}

#endif
