<lcgdict>
  <class name="reco::HitPattern" ClassVersion="12">
      <version ClassVersion="12" checksum="1612429001"/>
      <version ClassVersion="11" checksum="1621684703"/>
  </class>

  <class name="reco::HitPatternConversorHitProxy" ClassVersion="0">
      <version ClassVersion="0" checksum="1389560278"/>
  </class>
 

  <class name="reco::TrackBase" ClassVersion="13">
  <!-- I think there should only one copy of those <field /> since they are not nested. -->
   <version ClassVersion="13" checksum="1244921154"/>
    <field name="vertex_" iotype="ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
    <field name="momentum_" iotype="ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
   
   <version ClassVersion="12" checksum="2704717983"/>
    <field name="vertex_" iotype="ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
    <field name="momentum_" iotype="ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 

   <version ClassVersion="10" checksum="3019978065"/>
    <field name="vertex_" iotype="ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
    <field name="momentum_" iotype="ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
  </class>

 <ioread
      sourceClass="reco::HitPattern"
      source="uint32_t hitPattern_[25]"
      targetClass="reco::HitPattern"
      target="hitPattern"
      version="[-11]"
      include="iomanip; iostream; utility;
        DataFormats/SiPixelDetId/interface/PXBDetId.h;
        DataFormats/SiPixelDetId/interface/PXFDetId.h;
        DataFormats/SiStripDetId/interface/TIBDetId.h;
        DataFormats/SiStripDetId/interface/TIDDetId.h;
        DataFormats/SiStripDetId/interface/TOBDetId.h;
        DataFormats/SiStripDetId/interface/TECDetId.h;
        DataFormats/MuonDetId/interface/DTLayerId.h;
        DataFormats/MuonDetId/interface/CSCDetId.h;
        DataFormats/MuonDetId/interface/RPCDetId.h"
      >
      <![CDATA[
        using namespace reco;
        using namespace std;
        const unsigned short HitSize = 11;
        const unsigned short PatternSize = 25;
        const int MaxHits = (PatternSize * sizeof(uint32_t) * 8) / HitSize;

        auto getHitFromOldHitPattern = [HitSize] (const uint32_t hitPattern[], const int position)
        {
            uint16_t bitEndOffset = (position + 1) * HitSize;
            uint8_t secondWord   = (bitEndOffset >> 5);
            uint8_t secondWordBits = bitEndOffset & (32 - 1); // that is, bitEndOffset % 32
            if (secondWordBits >= HitSize) { // full block is in this word
                uint8_t lowBitsToTrash = secondWordBits - HitSize;
                return (hitPattern[secondWord] >> lowBitsToTrash) & ((1 << HitSize) - 1);
            } else {
                uint8_t  firstWordBits   = HitSize - secondWordBits;
                uint32_t firstWordBlock  = hitPattern[secondWord - 1] >> (32 - firstWordBits);
                uint32_t secondWordBlock = hitPattern[secondWord] & ((1 << secondWordBits) - 1);
                return firstWordBlock + (secondWordBlock << firstWordBits);
            }
        };

        auto oldHitPatternToTrackingRecHitProxy = [&] (const uint32_t pattern)
        {
            //value used for those parameters needed by XXXDetId constructors
            //but that we do not care about becuase they are not stored in the
            //HitPattern.
            const uint8_t DONT_CARE = 1;
            const static unsigned short HitTypeMask = 0x3;
            const static unsigned short HitTypeOffset = 0;

            const static unsigned short LayerMask = 0xF;
            const static unsigned short LayerOffset = 3; 
            
            const static unsigned short SubstrMask = 0x7;
            const static unsigned short SubstrOffset = 7;
            
            const static unsigned short SubDetectorMask = 0x1;
            const static unsigned short SubDetectorOffset = 10;
            
            const uint32_t VALID_CONST = (uint32_t) TrackingRecHit::valid;
            const uint32_t MISSING_CONST = (uint32_t) TrackingRecHit::missing;
            const uint32_t INACTIVE_CONST = (uint32_t) TrackingRecHit::inactive;
            const uint32_t BAD_CONST = (uint32_t) TrackingRecHit::bad;

            uint32_t rawHitType = (pattern >> HitTypeOffset) & HitTypeMask;
            uint32_t layer = (pattern >> LayerOffset) & LayerMask;
            uint32_t subdet = (pattern >> SubstrOffset) & SubstrMask;
            
            uint32_t detector = ((pattern >> SubDetectorOffset) & SubDetectorMask);
            // DetId::Tracker = 1 and DetId::Muon = 2 but
            // in HitPattern Tracker = 1 and Muon = 0 so a conversion is needed:
            if (detector == 0){
              detector = 2;
            }

            TrackingRecHit::Type hitType = TrackingRecHit::valid;
            switch (rawHitType){
              case VALID_CONST:
                hitType = TrackingRecHit::valid;
              break;
              case MISSING_CONST:
                hitType = TrackingRecHit::missing;
              break;
              case INACTIVE_CONST:
                hitType = TrackingRecHit::inactive;
              break;
              case BAD_CONST:
                hitType = TrackingRecHit::bad;
              break;
            }

            DetId detId;
            if (detector == DetId::Tracker) {
              switch (subdet) {
              case PixelSubdetector::PixelBarrel:
                  detId = PXBDetId(layer, 0, 0);
                  break;
              case PixelSubdetector::PixelEndcap:
                  detId = PXFDetId(0, layer, 0, 0, 0);
                  break;
              case StripSubdetector::TIB:
                  detId = TIBDetId(layer, 0, 0, 0, 0, 0);
                  break;
              case StripSubdetector::TID:
                  detId = TIDDetId(0, layer, 0, 0, 0, 0);
                  break;
              case StripSubdetector::TOB:
                  detId = TOBDetId(layer, 0, 0, 0, 0);
                  break;
              case StripSubdetector::TEC:
                  detId = TECDetId(0, layer, 0, 0, 0, 0, 0);
                  break;
              }
            } else if (detector == DetId::Muon) {
                switch (subdet) {
                  case MuonSubdetId::DT: {
                    uint32_t station = 1 + ((layer >> 2) & 0x3);
                    uint32_t superLayer = (layer & 0x3);
                    detId = DTLayerId(1, station, 1, superLayer, 1);
                  }
                  break;
                  case MuonSubdetId::CSC: {
                    uint32_t station = 1 + ((layer >> 2) & 0x3);
                    uint32_t ring = 1 + (layer & 0x3);
                    detId = CSCDetId(1, station, ring, 1, 1);
                  }
                  break;
                  case MuonSubdetId::RPC: {
                    uint32_t station =  1 + ((layer >> 2) & 0x3);
                    uint32_t region  = layer & 0x1;
                    uint32_t layer_muon = 1 + ((station <= 2) ? ((layer >> 1) & 0x1) : 0);
                    detId = RPCDetId(region, 1, station, 1, layer_muon, 1, 1);
                  }
                  break;
                }
            }
            return std::pair<DetId, TrackingRecHit::Type>(detId, hitType);
        };

        auto fillNewHitPatternWithOldHitPattern = [&] (const uint32_t oldHitPattern[])
        {
            for (int i = 0; i < MaxHits; i++) {
                uint32_t pattern = getHitFromOldHitPattern(oldHitPattern, i);
                if (pattern == 0){
                    break;
                }
                std::pair<DetId, TrackingRecHit::Type> hitInfo = oldHitPatternToTrackingRecHitProxy(pattern);
                if(!newObj->appendHit(hitInfo.first, hitInfo.second)){
                    return false;
                }
            }
            return true;
        };

        fillNewHitPatternWithOldHitPattern(onfile.hitPattern_);
      ]]>
 </ioread>

<!-- TrackBase to TrackBase conversion rule. Reads and merges the tree into one. --> 
<ioread
      sourceClass="reco::TrackBase"
      source="reco::HitPattern hitPattern_; reco::HitPattern trackerExpectedHitsInner_; reco::HitPattern trackerExpectedHitsOuter_"
      targetClass="reco::TrackBase"
      target="hitPattern_" 
      version="[-12]"
      include="iostream;
              DataFormats/TrackReco/interface/HitPattern.h"
      >
      <![CDATA[
        using namespace reco;
        using namespace std;

        auto newHitPatternToTrackingRecHitProxy = [&] (const uint16_t pattern, const HitPattern::HitCategory category)
        {
           //value used for those parameters needed by XXXDetId constructors
            //but that we do not care about.
            const uint8_t DONT_CARE = 1;

            const uint16_t VALID_CONST = (uint16_t) TrackingRecHit::valid;
            const uint16_t MISSING_CONST = (uint16_t) TrackingRecHit::missing;
            const uint16_t INACTIVE_CONST = (uint16_t) TrackingRecHit::inactive;
            const uint16_t BAD_CONST = (uint16_t) TrackingRecHit::bad;

            // 3 bits for hit type
            const static unsigned short HitTypeOffset = 0;
            const static unsigned short HitTypeMask = 0x7;

            // 4 bits to identify the layer/disk/wheel within the substructure
            const static unsigned short LayerOffset = 4;
            const static unsigned short LayerMask = 0xF;

            // 3 bits to identify the tracker/muon detector substructure
            const static unsigned short SubstrOffset = 8;
            const static unsigned short SubstrMask = 0x7;

            // 1 bit to distinguish tracker and muon subsystems
            const static unsigned short SubDetectorOffset = 11;
            const static unsigned short SubDetectorMask = 0x1;

            uint16_t rawHitType = (pattern >> HitTypeOffset) & HitTypeMask;
            uint16_t layer = (pattern >> LayerOffset) & LayerMask;
            uint16_t subdet = (pattern >> SubstrOffset) & SubstrMask;
            uint16_t detector = ((pattern >> SubDetectorOffset) & SubDetectorMask);
            
            // DetId::Tracker = 1 and DetId::Muon = 2 but
            // in HitPattern Tracker = 1 and Muon = 0 so a conversion is needed:
            if (detector == 0){
              detector = DetId::Muon;
            }

            TrackingRecHit::Type hitType = TrackingRecHit::valid;
            switch (rawHitType){
              case VALID_CONST:
                hitType = TrackingRecHit::valid;
              break;
              case MISSING_CONST:
                hitType = TrackingRecHit::missing;
              break;
              case INACTIVE_CONST:
                hitType = TrackingRecHit::inactive;
              break;
              case BAD_CONST:
                hitType = TrackingRecHit::bad;
              break;
            }

            DetId detId;
            if (detector == DetId::Tracker) {
              switch (subdet) {
              case PixelSubdetector::PixelBarrel:
                  detId = PXBDetId(layer, 0, 0);
                  break;
              case PixelSubdetector::PixelEndcap:
                  detId = PXFDetId(0, layer, 0, 0, 0);
                  break;
              case StripSubdetector::TIB:
                  detId = TIBDetId(layer, 0, 0, 0, 0, 0);
                  break;
              case StripSubdetector::TID:
                  detId = TIDDetId(0, layer, 0, 0, 0, 0);
                  break;
              case StripSubdetector::TOB:
                  detId = TOBDetId(layer, 0, 0, 0, 0);
                  break;
              case StripSubdetector::TEC:
                  detId = TECDetId(0, layer, 0, 0, 0, 0, 0);
                  break;
              }
            } else if (detector == DetId::Muon) {
              switch (subdet) {
                case MuonSubdetId::DT: {
                  uint16_t station = 1 + (layer >> 2);
                  uint16_t superLayer = (layer & 0x3);
                  detId = DTLayerId(1, station, 1, superLayer, 1);
                }
                break;
                case MuonSubdetId::CSC: {
                  uint16_t station = 1 + (layer >> 2);
                  uint16_t ring = 1 + (layer & 0x3);
                  detId = CSCDetId(1, station, ring, 1, 1);
                }
                break;
                case MuonSubdetId::RPC: {
                  uint16_t station = 1 + ((layer >> 2) & 0x3);
                  uint16_t region  = layer & 0x1;
                  uint16_t layer_muon = 1 + ((station <= 2) ? ((layer >> 1) & 0x1) : 0);
                  detId = RPCDetId(region, 1, station, 1, layer_muon, 1, 1);
                }
                break;
              }
            }
            
            if (category == HitPattern::MISSING_INNER_HITS){
                hitType = TrackingRecHit::missing_inner;
            }else if (category == HitPattern::MISSING_OUTER_HITS){
                hitType = TrackingRecHit::missing_outer;
            }

            return std::pair<DetId, TrackingRecHit::Type>(detId, hitType);
            //return reco::HitPatternConversorHitProxy(detId, hitType);
        };

        auto fillNewHitPatternFromNewHitPattern = [&] (const HitPattern hitPattern, const HitPattern::HitCategory category)
        {
            uint8_t hitCount = hitPattern.numberOfHits(HitPattern::ALL_HITS);
            for (int i = 0; i < hitCount; i++) {
                uint16_t pattern = hitPattern.getHitPattern(HitPattern::ALL_HITS, i);
                std::pair<DetId, TrackingRecHit::Type> hitInfo = newHitPatternToTrackingRecHitProxy(pattern, category);
                //if(!newObj->appendHitPattern(newHitPatternToTrackingRecHitProxy(pattern, category))){
                if(!newObj->appendHitPattern(hitInfo.first, hitInfo.second)){
                    return false;
                }
            }
            return true;
        };
        
        auto mergeNewHitPatternsIntoOneNewHitPattern = [&] (void)
        {
          fillNewHitPatternFromNewHitPattern(onfile.hitPattern_, HitPattern::TRACK_HITS);
          fillNewHitPatternFromNewHitPattern(onfile.trackerExpectedHitsInner_, HitPattern::MISSING_INNER_HITS);
          fillNewHitPatternFromNewHitPattern(onfile.trackerExpectedHitsOuter_, HitPattern::MISSING_OUTER_HITS);
        };
        
        mergeNewHitPatternsIntoOneNewHitPattern();
      ]]>
 </ioread>

  <class name="reco::TrackResiduals" ClassVersion="10">
   <version ClassVersion="10" checksum="2022291691"/>
  </class>
  <class name="reco::TrackExtraBase" ClassVersion="10">
   <version ClassVersion="10" checksum="3548207838"/>
  </class>

  <class name="reco::TrackExtra" ClassVersion="10">
   <version ClassVersion="10" checksum="1613098482"/>
    <field name="outerPosition_" iotype="ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
    <field name="outerMomentum_" iotype="ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
    <field name="innerPosition_" iotype="ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
    <field name="innerMomentum_" iotype="ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" /> 
  </class>
  <class name="std::vector<reco::TrackExtra>"/>
  <class name="edm::Wrapper<std::vector<reco::TrackExtra> >"/>
  <class name="edm::RefProd<std::vector<reco::TrackExtra> >"/>
  <class name="edm::Ref<std::vector<reco::TrackExtra>,reco::TrackExtra,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtra>,reco::TrackExtra> >"/>
  <class name="edm::RefVector<std::vector<reco::TrackExtra>,reco::TrackExtra,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtra>,reco::TrackExtra> >"/>

  <class name="reco::Track" ClassVersion="12">
   <version ClassVersion="12" checksum="1190637787"/>
   <version ClassVersion="11" checksum="1190637787"/>
   <version ClassVersion="10" checksum="1190637787"/>
  </class>
  <class name="std::vector<reco::Track>"/>
  <class name="edm::Wrapper<std::vector<reco::Track> >"/>
  <class name="edm::RefProd<std::vector<reco::Track> >"/>
  <class name="edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >"/>
  <class name="edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >"/>
  <class name="std::vector<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"/>
  <class name="edm::Wrapper<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"/>
  <class name="std::vector<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"/>
  <class name="edm::Ptr<reco::Track>" />
  <class name="std::vector<edm::Ptr<reco::Track> >" />

  <class pattern="edm::KeyVal<*>" />
  <class pattern="edm::Wrapper<edm::AssociationMap<*>" />
  <class pattern="edm::Ref<edm::AssociationMap<*>" />
  <class pattern="edm::RefProd<edm::AssociationMap<*>" />
  <class pattern="edm::RefVector<edm::AssociationMap<*>" />

  <class name="edm::helpers::Key<edm::RefProd <std::vector <reco::Track> > >" />

  <class name="edm::AssociationMap<edm::OneToValue<std::vector<reco::Track>,double,unsigned int> >">
    <field name="transientMap_" transient="true" /> 
  </class>

  <class name="edm::AssociationMap<edm::OneToValue<std::vector<reco::Track>,bool,unsigned int> >">
    <field name="transientMap_" transient="true" />
  </class>

  <class name="edm::AssociationMap<edm::OneToValue<std::vector<reco::Track>,int,unsigned int> >">
    <field name="transientMap_" transient="true" />
  </class>

  <class name="edm::AssociationMap<edm::OneToValue<std::vector<reco::Track>,float,unsigned int> >">
    <field name="transientMap_" transient="true" />
  </class>

  <class name="edm::helpers::KeyVal<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >" />
 
  <class name="edm::helpers::KeyVal<edm::RefProd<std::vector<reco::Track> >,edm::RefProd<std::vector<reco::Track> > >" />

  <class name="edm::AssociationMap<edm::OneToOne<std::vector<reco::Track>,std::vector<reco::Track>,unsigned int> >">
    <field name="transientMap_" transient="true" />
  </class>


      <class name="reco::DeDxHit"  ClassVersion="10">
       <version ClassVersion="10" checksum="2553084991"/>
      </class>
      <class name="reco::DeDxHitCollection" />

  <class pattern="edm::AssociationVector<*>">
    <field name="transientVector_" transient="true"/>
  </class>

     <!--   <class name="reco::DeDxDataCollection"/> -->
     <class name="reco::DeDxData" ClassVersion="10">
      <version ClassVersion="10" checksum="204721063"/>
     </class>
     <class name="reco::DeDxDataCollection"/>
     <class name="reco::DeDxDataValueMap"/>
      
     <class name="edm::Wrapper<reco::TrackDeDxHitsCollection>"/>
     <class name="edm::Wrapper<reco::DeDxDataValueMap>"/>
     <class name="edm::Wrapper<reco::DeDxDataCollection>"/>



     <!-- RefToBase<reco::Track> -->
     <class name="edm::RefToBase<reco::Track>"/>
     <class name="edm::reftobase::IndirectHolder<reco::Track>"/>
     <class name="edm::reftobase::BaseHolder<reco::Track>"/>
     <class name="edm::reftobase::RefHolder<reco::TrackRef>"/>
     <class name="edm::reftobase::Holder<reco::Track, reco::TrackRef>"/>

     <class name="std::vector<edm::RefToBase<reco::Track> >" />

     <class name="std::pair<edm::RefToBase<reco::Track>,double>" />
     <class name="std::vector<std::pair<edm::RefToBase<reco::Track>,double> >" />

     <!-- RefToBaseProd<reco::Track> -->
     <class name="edm::RefToBaseProd<reco::Track>" />

     <!-- ValueMap<reco::Track> -->
     <class name="edm::ValueMap<reco::TrackRefVector>" />
     <class name="edm::Wrapper<edm::ValueMap<reco::TrackRefVector> >" />


     <class name="edm::helpers::KeyVal<edm::RefProd<std::vector<reco::Track> >,edm::RefProd<std::vector<TrajectorySeed> > >"/>
     <class name="edm::AssociationMap<edm::OneToMany<std::vector<reco::Track>,std::vector<TrajectorySeed>,unsigned int> >">
       <field name="transientMap_" transient="true"/>
     </class>

     <class name="std::vector<std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,float> >" />
     <class name="std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,float>" />


     <class name="std::vector<std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,int> >" />
     <class name="std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,int>" />


     <class name="std::pair<reco::Track,reco::Track>"/>
     <class name="edm::Wrapper<std::pair<reco::Track,reco::Track> > "/>
     <class name="std::pair<TrackCandidate,std::pair<reco::Track,reco::Track> >" />
     <class name="edm::Wrapper<std::pair<TrackCandidate,std::pair<reco::Track,reco::Track> > >" />
     <class name="std::vector<std::pair<TrackCandidate,std::pair<reco::Track,reco::Track> > >"/>
     <class name="edm::Wrapper<std::vector<std::pair<TrackCandidate,std::pair<reco::Track,reco::Track> > > >"/>

     <class name="std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"/>
     <class name="edm::Wrapper<std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > > "/>
     <class name="std::pair<TrackCandidate,std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > >" />
     <class name="edm::Wrapper<std::pair<TrackCandidate,std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > > >" />
     <class name="std::vector<std::pair<TrackCandidate,std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > > >"/>
     <class name="edm::Wrapper<std::vector<std::pair<TrackCandidate,std::pair<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >,edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > > > >"/>


  </lcgdict>
