// -*- C++ -*-
//
// Package:    DataFormats/FEDRawData
// Class:      TestWriteRawDataBuffer
//
/**\class edmtest::TestWriteRawDataBuffer
  Description: Used as part of tests that ensure the RawDataBuffer
  data format can be persistently written and in a subsequent process
  read. First, this is done using the current release version for writing
  and reading. In addition, the output file of the write process should
  be saved permanently each time the RawDataBuffer persistent data
  format changes. In unit tests, we read each of those saved files to verify
  that the current releases can read older versions of the data format.
*/
// Original Author:  W. David Dagenhart
//         Created:  1 May 2023

#include "DataFormats/FEDRawData/interface/RawDataBuffer.h"
#include "DataFormats/FEDRawData/interface/SLinkRocketHeaders.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/global/EDProducer.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
#include "FWCore/Utilities/interface/EDPutToken.h"
#include "FWCore/Utilities/interface/StreamID.h"

#include <memory>
#include <utility>
#include <vector>

namespace edmtest {

  class TestWriteRawDataBuffer : public edm::global::EDProducer<> {
  public:
    TestWriteRawDataBuffer(edm::ParameterSet const&);
    void produce(edm::StreamID, edm::Event&, edm::EventSetup const&) const override;
    static void fillDescriptions(edm::ConfigurationDescriptions&);

  private:
    std::vector<unsigned int> dataPattern1_;
    std::vector<unsigned int> dataPattern2_;
    edm::EDPutTokenT<RawDataBuffer> rawDataBufferPutToken_;
  };

  TestWriteRawDataBuffer::TestWriteRawDataBuffer(edm::ParameterSet const& iPSet)
      : dataPattern1_(iPSet.getParameter<std::vector<unsigned int>>("dataPattern1")),
        dataPattern2_(iPSet.getParameter<std::vector<unsigned int>>("dataPattern2")),
        rawDataBufferPutToken_(produces()) {}

  void TestWriteRawDataBuffer::produce(edm::StreamID, edm::Event& iEvent, edm::EventSetup const&) const {
    unsigned int size0 = 48;
    unsigned int size1 = 2048;
    unsigned int size2 = 4768;
    unsigned int sizeHigh = 25504;
    uint64_t sid0 = 0;
    uint64_t sid1 = 1;
    uint64_t sid2 = 30;
    uint64_t sidHigh = 298457834;

    uint8_t emu_status = 2;  //set 2 indicating fragment generated by DTH (emulator)
    uint16_t l1a_types = 1;  //set provisionally to 1, to be revised later
    uint8_t l1a_phys = 0;

    unsigned char src0data[size0];
    unsigned char src1data[size1];
    unsigned char src2data[size2];
    unsigned char srcHighdata[sizeHigh];

    //fill headers and trailers
    auto sh0 = new ((void*)src0data) SLinkRocketHeader_v3(sid0, l1a_types, l1a_phys, emu_status, 0x398398393fead);
    auto sh1 = new ((void*)src1data) SLinkRocketHeader_v3(sid1, l1a_types, l1a_phys, emu_status, 0x8478470);
    auto sh2 = new ((void*)src2data) SLinkRocketHeader_v3(sid2, l1a_types, l1a_phys, emu_status, 0x09a83fa);
    auto shHigh = new ((void*)srcHighdata) SLinkRocketHeader_v3(sidHigh, l1a_types, l1a_phys, emu_status, 0x33E);

    auto st0 = new ((void*)(src0data + size0 - sizeof(SLinkRocketTrailer_v3)))
        SLinkRocketTrailer_v3(0, 0, 0x3989, 2200, size0 >> SLR_WORD_NUM_BYTES_SHIFT, 0);

    auto st1 = new ((void*)(src1data + size1 - sizeof(SLinkRocketTrailer_v3)))
        SLinkRocketTrailer_v3(0, 0, 0x3989, 44, size1 >> SLR_WORD_NUM_BYTES_SHIFT, 0);

    auto st2 = new ((void*)(src2data + size2 - sizeof(SLinkRocketTrailer_v3)))
        SLinkRocketTrailer_v3(0, 0, 0x3989, 88, size2 >> SLR_WORD_NUM_BYTES_SHIFT, 0);

    auto stHigh = new ((void*)(srcHighdata + sizeHigh - sizeof(SLinkRocketTrailer_v3)))
        SLinkRocketTrailer_v3(0, 0, 0x3990, 1, sizeHigh >> SLR_WORD_NUM_BYTES_SHIFT, 0);

    constexpr size_t hdrsize = sizeof(SLinkRocketHeader_v3);
    constexpr size_t trsize = sizeof(SLinkRocketTrailer_v3);

    for (size_t i = hdrsize; i < size0 - trsize; i++) {
      auto j = i - hdrsize;
      src0data[i] = dataPattern1_[j % std::size(dataPattern1_)];
    }
    for (size_t i = hdrsize; i < size1 - trsize; i++) {
      auto j = i - hdrsize;
      src1data[i] = dataPattern2_[j % std::size(dataPattern2_)];
    }
    for (size_t i = hdrsize; i < size2 - trsize; i++) {
      auto j = i - hdrsize;
      src2data[i] = dataPattern1_[j % std::size(dataPattern1_)];
    }
    for (size_t i = hdrsize; i < sizeHigh - trsize; i++) {
      auto j = i - hdrsize;
      srcHighdata[i] = dataPattern2_[j % std::size(dataPattern2_)];
    }

    assert(sh0->version() == 3);
    assert(sh0->verifyMarker());
    assert(sh1->version() == 3);
    assert(sh1->verifyMarker());
    assert(sh2->version() == 3);
    assert(sh2->verifyMarker());
    assert(shHigh->version() == 3);
    assert(shHigh->verifyMarker());
    assert(st0->verifyMarker());
    assert(st1->verifyMarker());
    assert(st2->verifyMarker());
    assert(stHigh->verifyMarker());

    auto rawDataBuffer = std::make_unique<RawDataBuffer>(size0 + size1 + size2 + sizeHigh);  //divisible by 16

    rawDataBuffer->addSource(sid0, src0data, size0);
    rawDataBuffer->addSource(sid1, src1data, size1);
    rawDataBuffer->addSource(sid2, src2data, size2);
    rawDataBuffer->addSource(sidHigh, srcHighdata, sizeHigh);

    auto const& fragData0 = rawDataBuffer->fragmentData(sid0);
    auto const& fragData1 = rawDataBuffer->fragmentData(sid1);
    auto const& fragData2 = rawDataBuffer->fragmentData(sid2);
    auto const& fragDataHigh = rawDataBuffer->fragmentData(sidHigh);

    assert(fragData0.size());
    assert(fragData1.size());
    assert(fragData2.size());
    assert(fragDataHigh.size());

    auto hdrView0 = makeSLinkRocketHeaderView(fragData0.dataHeader(hdrsize));
    auto trlView0 = makeSLinkRocketTrailerView(fragData0.dataTrailer(trsize), hdrView0->version());
    auto hdrView1 = makeSLinkRocketHeaderView(fragData1.dataHeader(hdrsize));
    auto trlView1 = makeSLinkRocketTrailerView(fragData1.dataTrailer(trsize), hdrView1->version());
    auto hdrView2 = makeSLinkRocketHeaderView(fragData2.dataHeader(hdrsize));
    auto trlView2 = makeSLinkRocketTrailerView(fragData2.dataTrailer(trsize), hdrView2->version());
    auto hdrViewHigh = makeSLinkRocketHeaderView(fragDataHigh.dataHeader(hdrsize));
    auto trlViewHigh = makeSLinkRocketTrailerView(fragDataHigh.dataTrailer(trsize), hdrViewHigh->version());

    iEvent.put(rawDataBufferPutToken_, std::move(rawDataBuffer));
  }

  void TestWriteRawDataBuffer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
    edm::ParameterSetDescription desc;
    desc.add<std::vector<unsigned int>>("dataPattern1");
    desc.add<std::vector<unsigned int>>("dataPattern2");
    descriptions.addDefault(desc);
  }
}  // namespace edmtest

using edmtest::TestWriteRawDataBuffer;
DEFINE_FWK_MODULE(TestWriteRawDataBuffer);
