%%
%% This is file `lstpatch.sty', generated manually.
%%
%% (w)(c) 2004 Carsten Heinz
%%
%% This file may be distributed under the terms of the LaTeX Project Public
%% License from CTAN archives in directory  macros/latex/base/lppl.txt.
%% Either version 1.0 or, at your option, any later version.
%%
%% Send comments and ideas on the package, error reports and additional
%% programming languages to <cheinz@gmx.de>.
%%
%%
%% The following features are added to the base package.
%%
%% 1.3a (2004/09/07)
%%
%%  a) H I G H L Y   E X P E R I M E N T A L
%%
%%     Use the options
%%        rangeprefix=<prefix for begin and end of range>
%%        rangesuffix=<suffix for begin and end of range>
%%
%%        rangebeginprefix=<prefix for begin of range>
%%        rangebeginsuffix=<suffix for begin of range>
%%
%%        rangeendprefix=<prefix for end of range>
%%        rangeendsuffix=<suffix for end of range>
%%
%%        includerangemarker=true|false
%%     together with
%%        firstline=<begin marker>
%%        lastline=<end marker>
%%     or
%%        linerange={<begin marker 1>-<end marker 1>,
%%                   <begin marker 2>-<end marker 2>, ...}
%%     The according markers in the source code are
%%           <prefix><marker><suffix>
%%     for begin respectively end of range. Moreover, one can use
%%        includerangemarker=true|false
%%     to show or hide the range markers in the output.
%%
%%
\lst@CheckVersion{1.3}
{\typeout{^^J%
    ***^^J%
    *** This is a patch for listings 1.3, but you're using^^J%
    *** version \lst@version.^^J%
    ***^^J
    *** Patch file not loaded.^^J%
    ***^^J}%
    \endinput
}
\def\fileversion{1.3a}
\def\filedate{2004/09/07}
\ProvidesFile{lstpatch.sty}[\filedate\space\fileversion\space (Carsten Heinz)]
%
% 0) Insert % after #1.
\def\@@xbitor #1{\@tempcntb \count#1%
   \ifnum \@tempcnta =\z@
   \else
     \divide\@tempcntb\@tempcnta
     \ifodd\@tempcntb \@testtrue\fi
   \fi}
%
% a) Let's start with the options:
\lst@Key{rangeprefix}\relax{\def\lst@rangebeginprefix{#1}%
                            \def\lst@rangeendprefix{#1}}
\lst@Key{rangesuffix}\relax{\def\lst@rangebeginsuffix{#1}%
                            \def\lst@rangeendsuffix{#1}}
\lst@Key{rangebeginprefix}{}{\def\lst@rangebeginprefix{#1}}
\lst@Key{rangebeginsuffix}{}{\def\lst@rangebeginsuffix{#1}}
\lst@Key{rangeendprefix}{}{\def\lst@rangeendprefix{#1}}
\lst@Key{rangeendsuffix}{}{\def\lst@rangeendsuffix{#1}}
\lst@Key{includerangemarker}{true}[t]{\lstKV@SetIf{#1}\lst@ifincluderangemarker}
%
%    The key is a redefinition of \lst@GLI@ checking for numbers.
\def\lst@GLI@#1-#2-#3\@nil{%
    \lst@IfNumber{#1}%
    {\ifx\@empty#1\@empty
         \let\lst@firstline\@ne
     \else
         \def\lst@firstline{#1\relax}%
     \fi
     \ifx\@empty#3\@empty
         \def\lst@lastline{9999999\relax}%
     \else
         \ifx\@empty#2\@empty
             \let\lst@lastline\lst@firstline
         \else
             \def\lst@lastline{#2\relax}%
         \fi
     \fi}%
%
%    If we've found a general marker, we set firstline and lastline to 9999999.
%    This prevents (almost) anything to be printed for now.
    {\def\lst@firstline{9999999\relax}%
     \let\lst@lastline\lst@firstline
%
%    We add the prefixes and suffixes to the markers.
     \let\lst@rangebegin\lst@rangebeginprefix
     \lst@AddTo\lst@rangebegin{#1}\lst@Extend\lst@rangebegin\lst@rangebeginsuffix
     \ifx\@empty#3\@empty
         \let\lst@rangeend\lst@rangeendprefix
         \lst@AddTo\lst@rangeend{#1}\lst@Extend\lst@rangeend\lst@rangeendsuffix
     \else
         \ifx\@empty#2\@empty
             \let\lst@rangeend\@empty
         \else
             \let\lst@rangeend\lst@rangeendprefix
             \lst@AddTo\lst@rangeend{#2}\lst@Extend\lst@rangeend\lst@rangeendsuffix
         \fi
     \fi
%    The following definition will be executed in the SelectCharTable hook
%    and here right now if we are already processing a listing.
     \global\def\lst@DefRange{\expandafter\lst@CArgX\lst@rangebegin\relax\lst@DefRangeB}%
     \ifnum\lst@mode=\lst@Pmode \expandafter\lst@DefRange \fi}}
%    \lst@DefRange is not inserted via a hook anymore. Instead it is now called
%    directly from \lst@SelectCharTable. This was necessary to get rid of an
%    interference with the escape-to-LaTeX-feature. The bug was reported by
%    \lsthelper{Michael~Bachmann}{2004/07/21}{Keine label-Referenzierung
%    m\"oglich...}. Another chance is due to the same bug: \lst@DefRange is
%    redefined globally when the begin of code is found, see below. The bug was
%    reported by \lsthelper{Tobias~Rapp}{2004/04/06}{undetected end of range if
%    listing crosses page break} \lsthelper{Markus~Luisser}{2004/08/13}{Bug mit
%    'linerangemarker' in umgebrochenen listings}
%\lst@AddToHook{SelectCharTable}{\lst@DefRange}
\lst@AddToHookExe{DeInit}{\global\let\lst@DefRange\@empty}
%
%    Actually defining the marker (via \lst@GLI@, \lst@DefRange, \lst@CArgX as
%    seen above) is similar to \lst@DefDelimB---except that we unfold the first
%    parameter and use different <execute>, <pre>, and <post> statements.
\def\lst@DefRangeB#1#2{\lst@DefRangeB@#1#2}
\def\lst@DefRangeB@#1#2#3#4{%
    \lst@CDef{#1{#2}{#3}}#4{}%
    {\lst@ifincluderangemarker
         \lst@LeaveMode
         \let#1#4%
         \lst@DefRangeEnd
         \lst@InitLstNumber
     \else
         \@tempcnta\lst@lineno \advance\@tempcnta\@ne
         \edef\lst@firstline{\the\@tempcnta\relax}%
         \gdef\lst@OnceAtEOL{\let#1#4\lst@DefRangeEnd}%
         \lst@InitLstNumber
     \fi
	 \global\let\lst@DefRange\lst@DefRangeEnd
     \lst@CArgEmpty}%
    \@empty}
%
% Modify labels and define |\lst@InitLstNumber| used above.
% \lsthelper{Omair-Inam~Abdul-Matin}{2004/05/10}{experimental linerange
% feature does not work with firstnumber}
\def\lstpatch@labels{%
\gdef\lst@SetFirstNumber{%
    \ifx\lst@firstnumber\@undefined
        \@tempcnta 0\csname\@lst no@\lst@intname\endcsname\relax
        \ifnum\@tempcnta=\z@ \else
            \lst@nololtrue
            \advance\@tempcnta\lst@advancenumber
            \edef\lst@firstnumber{\the\@tempcnta\relax}%
        \fi
    \fi}%
}
\lst@AddToAtTop\lsthk@PreInit
    {\ifx\lst@firstnumber\@undefined
         \def\lst@firstnumber{\lst@lineno}%
     \fi}
\def\lst@InitLstNumber{%
     \global\c@lstnumber\lst@firstnumber
     \global\advance\c@lstnumber\lst@advancenumber
     \global\advance\c@lstnumber-\lst@advancelstnum
     \ifx \lst@firstnumber\c@lstnumber
         \global\advance\c@lstnumber-\lst@advancelstnum
     \fi}
%
%    The end-marker is defined if and only if it's not empty. The definition is
%    similar to \lst@DefDelimE---with the above exceptions and except that we
%    define the re-entry point \lst@DefRangeE@@ as it is defined in the new
%    version of \lst@MProcessListing above.
\def\lst@DefRangeEnd{%
    \ifx\lst@rangeend\@empty\else
        \expandafter\lst@CArgX\lst@rangeend\relax\lst@DefRangeE
    \fi}
\def\lst@DefRangeE#1#2{\lst@DefRangeE@#1#2}
\def\lst@DefRangeE@#1#2#3#4{%
    \lst@CDef{#1#2{#3}}#4{}%
    {\let#1#4%
     \edef\lst@lastline{\the\lst@lineno\relax}%
     \lst@DefRangeE@@}%
    \@empty}
\def\lst@DefRangeE@@#1\@empty{%
    \lst@ifincluderangemarker
        #1\lst@XPrintToken
    \fi
    \lst@LeaveModeToPmode
    \lst@BeginDropInput{\lst@Pmode}}
%
\def\lst@LeaveModeToPmode{%
    \ifnum\lst@mode=\lst@Pmode
        \expandafter\lsthk@EndGroup
    \else
        \expandafter\egroup\expandafter\lst@LeaveModeToPmode
    \fi}
%
%    Eventually we shouldn't forget to install \lst@OnceAtEOL, which must
%    also be called in \lst@MSkipToFirst.
\lst@AddToHook{EOL}{\lst@OnceAtEOL\global\let\lst@OnceAtEOL\@empty}
\gdef\lst@OnceAtEOL{}% Init
\def\lst@MSkipToFirst{%
    \global\advance\lst@lineno\@ne
    \ifnum \lst@lineno=\lst@firstline
        \def\lst@next{\lst@LeaveMode \global\lst@newlines\z@
        \lst@OnceAtEOL \global\let\lst@OnceAtEOL\@empty
        \lst@InitLstNumber % Added to work with modified \lsthk@PreInit.
        \lsthk@InitVarsBOL
        \lst@BOLGobble}%
        \expandafter\lst@next
    \fi}
\def\lst@SkipToFirst{%
    \ifnum \lst@lineno<\lst@firstline
        \def\lst@next{\lst@BeginDropInput\lst@Pmode
        \lst@Let{13}\lst@MSkipToFirst
        \lst@Let{10}\lst@MSkipToFirst}%
        \expandafter\lst@next
    \else
        \expandafter\lst@BOLGobble
    \fi}
%
%    Finally the service macro \lst@IfNumber:
\def\lst@IfNumber#1{%
    \ifx\@empty#1\@empty
        \let\lst@next\@firstoftwo
    \else
        \lst@IfNumber@#1\@nil
    \fi
    \lst@next}
\def\lst@IfNumber@#1#2\@nil{%
    \let\lst@next\@secondoftwo
    \ifnum`#1>47\relax \ifnum`#1>57\relax\else
        \let\lst@next\@firstoftwo
    \fi\fi}
%%
\endinput
%%
%% End of file `lstpatch.sty'.
