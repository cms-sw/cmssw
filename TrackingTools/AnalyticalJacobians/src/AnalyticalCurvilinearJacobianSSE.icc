
void
AnalyticalCurvilinearJacobian::computeFullJacobian
(const GlobalTrajectoryParameters& globalParameters,
 const GlobalPoint& x, 
 const GlobalVector& p, 
 const GlobalVector& h, 
 const double& s)
{ 
#ifdef  CMS_USE_AVX
  // needed fro gcc < 4.6    
  mathSSE::ZeroUpper zu;
#endif

  using mathSSE::Vec4D;
  using mathSSE::Vec3D;
  using mathSSE::Vec2D;

  //GlobalVector p1 = fts.momentum().unit();
  GlobalVector p1 = globalParameters.momentum().unit();
  GlobalVector p2 = p.unit();
  //GlobalPoint xStart = fts.position();
  GlobalPoint xStart = globalParameters.position();
  GlobalVector dxf = xStart - x;
  //GlobalVector h  = MagneticField::inInverseGeV(xStart);
  // Martijn: field is now given as parameter.. GlobalVector h  = globalParameters.magneticFieldInInverseGeV(xStart);

  //double qbp = fts.signedInverseMomentum();
  double qbp = globalParameters.signedInverseMomentum();
  double absS = s;
  
  // calculate transport matrix
  // Origin: TRPRFN
   double cosl0 = p1.perp(); double cosl1 = 1./p2.perp();

  // define average magnetic field and gradient 
  // at initial point - inlike TRPRFN
  GlobalVector hnf = h.unit();
  double qp = -h.mag();
  //   double q = -h.mag()*qbp;
  double q = qp*qbp;

  double theta = q*absS; double sint,cost;   vdt::fast_sincos(theta,sint,cost);

  Vec3D t1(p1.basicVector().v);
  Vec3D t2(p2.basicVector().v);

  Vec3D hn(hnf.basicVector().v);
  Vec3D dx(dxf.basicVector().v);

  double gamma = dot(hn,t2);
  Vec3D an = cross(hn,t2);

  Vec4D t(t1.xy(),t2.xy());
  Vec4D tt = t*t;
  tt = mathSSE::sqrt(hadd(tt,tt));


#ifdef  CMS_USE_AVX
  const __m256d neg = _mm256_setr_pd (-0.0 , 0.0, -0.0 , 0.0 );
  Vec4D res(_mm256_xor_pd(neg,_mm256_div_pd(_mm256_shuffle_pd(t.vec,t.vec,5),tt.vec)));
  Vec2D u1(res.xy());
  Vec2D u2(res.zw());
#else
  // __m128d t = _mm_mul_pd(t1.xy().vec,t1.xy().vec);
  //  t = _mm_sqrt_pd(_mm_add_pd(t,_mm_shuffle_pd(t,t,1)));
  // t = _mm_sqrt_pd(_mm_hadd_pd(t,t));
  const __m128d neg = _mm_set_pd ( 0.0 , -0.0 ); // mind: set not setr
  Vec2D u1(_mm_xor_pd(neg,_mm_div_pd(_mm_shuffle_pd(t1.xy().vec,t1.xy().vec,1),tt.xy().vec)));
  // t = _mm_mul_pd(t2.xy().vec,t2.xy().vec);
  //  t = _mm_sqrt_pd(_mm_add_pd(t,_mm_shuffle_pd(t,t,1)));
  //t = _mm_sqrt_pd(_mm_hadd_pd(t,t));
 
  Vec2D u2(_mm_xor_pd(neg,_mm_div_pd(_mm_shuffle_pd(t2.xy().vec,t2.xy().vec,1),tt.zw().vec)));
 
#endif

  Vec3D u13(u1);
  Vec3D v1 = cross(t1,u13);
  Vec3D u23(u2);
  Vec3D v2 = cross(t2,u23);


  // now prepare the transport matrix
  // pp only needed in high-p case (WA)
//   double pp = 1./qbp;
////    double pp = fts.momentum().mag();
// moved up (where -h.mag() is needed()
//   double qp = q*pp;

  double anv = -dot(hn,u23);
  double anu =  dot(hn,v2);

  double omcost = 1. - cost; double tmsint = theta - sint;
  
  
  Vec3D hu = cross(hn,u13);
  Vec3D hv = cross(hn,v1);

  
  //   1/p - doesn't change since |p1| = |p2|
  
  //   lambda
  
  theJacobian(1,0) = -qp*anv*dot(t2,dx);
  
  theJacobian(1,1) = 
    cost*dot(v1,v2) +
    sint*dot(hv,v2) +
    omcost*dot(hn,v1) * dot(hn,v2) +
    anv*(-sint*dot(v1,t2) +
	 omcost*dot(v1,an) -
	 tmsint*gamma*dot(hn,v1)
	 )
    ;

  theJacobian(1,2) = 
    cost*dot(u1,v2.xy()) +
    sint*dot(hu,v2) +
    omcost*dot(hn.xy(),u1) * dot(hn,v2) +
    anv*(-sint*dot(u1,t2.xy()) +
	 omcost*dot(u1,an.xy())  -
	 tmsint*gamma*dot(hn.xy(),u1)
	 )
    ;
  theJacobian(1,2) *= cosl0;

  theJacobian(1,3) = -q*anv*dot(u1,t2.xy());

  theJacobian(1,4) = -q*anv*dot(v1,t2);

  //   phi

  theJacobian(2,0) = -qp*anu*cosl1*dot(t2,dx);

  theJacobian(2,1) = 
    cost*dot(v1.xy(),u2) +
    sint*dot(hv.xy(),u2) +
    omcost*dot(hn,v1)*dot(hn.xy(),u2) +
    anu*(-sint*dot(v1,t2) +
	 omcost*dot(v1,an) -
	 tmsint*gamma*dot(hn,v1)
	 )
    ;
  theJacobian(2,1) *= cosl1;

  theJacobian(2,2) = 
    cost*dot(u1,u2) +
    sint*dot(hu.xy(),u2) +
    omcost*dot(hn.xy(),u1)*dot(hn.xy(),u2) +
    anu*(-sint*dot(u1,t2.xy()) +
	 omcost*dot(u1,an.xy()) -
	 tmsint*gamma*dot(hn.xy(),u1)
	 )
    ;
  theJacobian(2,2) *= cosl1*cosl0;

  theJacobian(2,3) = -q*anu*cosl1*dot(u1,t2.xy());

  theJacobian(2,4) = -q*anu*cosl1*dot(v1,t2);

  //   yt


  double overQ = 1./q;

  theJacobian(3,1) = (sint*dot(v1.xy(),u2) +
		      omcost*dot(hv.xy(),u2) +
		      tmsint*dot(hn,v1)*dot(hn.xy(),u2)
		      )*overQ;

  theJacobian(3,2) = (sint*dot(u1,u2) +
		      omcost*dot(hu.xy(),u2) +
		      tmsint*dot(hn.xy(),u1)*dot(hn.xy(),u2) 
		      )*(cosl0*overQ);

  theJacobian(3,3) = dot(u1,u2);
  
  theJacobian(3,4) = dot(v1.xy(),u2);

  //   zt

  theJacobian(4,1) = (sint*dot(v1,v2) +
		      omcost*dot(hv,v2) +
		      tmsint*dot(hn,v1)*dot(hn,v2)
		      )*overQ;

  theJacobian(4,2) = (sint*dot(u1,v2.xy()) +
		      omcost*dot(hu,v2) +
		      tmsint*dot(hn.xy(),u1)*dot(hn,v2)
		      )*(cosl0*overQ);

  theJacobian(4,3) = dot(u1,v2.xy()); 

  theJacobian(4,4) = dot(v1,v2);

  //double cutCriterion = abs(s/fts.momentum().mag());
  //  double cutCriterion = fabs(s/globalParameters.momentum().mag());
  double cutCriterion = std::abs(s*qbp);
  const double limit = 5.; // valid for propagations with effectively float precision

  if (cutCriterion > limit) {
    double pp = 1./qbp;
    theJacobian(3,0) = pp*dot(u2,dx.xy());
//    theJacobian(4,0) = -pp*dot(v2,dx);  // was wrong sign???
/*
It seems so.
The effect was noticed analysing the distribution of reduced chi2 of general tracks
vs eta. A +3% difference was noticed whem using the - sign instead of the plus,
in the region .75 < |eta| < 1.5, in particular for <1GeV tracks.
Indeed, the reduced chi2 is only one of the symptoms: many other quantities 
were affected (momentum for example). In addition additional tracks were reconstructed.
*/
    theJacobian(4,0) = pp*dot(v2,dx);  

  }
  else {
    Vec3D hp1 = cross(hn,t1);
    double temp1 = dot(hp1.xy(),u2);
    Vec3D ghnmp = gamma*hn - t1;
    double temp2 = dot(ghnmp.xy(),u2);

    double qps = qp*s;
    double h2 = qps*qbp;
    double h3 = (-1./8.) * h2;

    double secondOrder41 = 0.5 * temp1;
    double thirdOrder41  =  (1./3.) *temp2;
    double fourthOrder41 = h3 * temp1;
    theJacobian(3,0) = (s*qps)*(secondOrder41 + h2*(thirdOrder41 + fourthOrder41));

    double temp3 = dot(hp1,v2);
    double temp4 = dot(ghnmp,v2);

    double secondOrder51 = 0.5 * temp3;
    double thirdOrder51  = (1./3.) *temp4;
    double fourthOrder51 =  h3 * temp3;
    theJacobian(4,0) = (s*qps)*(secondOrder51 + h2*(thirdOrder51 + fourthOrder51));
  }



  // end of TRPRFN
}
