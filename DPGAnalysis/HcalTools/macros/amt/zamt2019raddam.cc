#include <iostream>
#include <fstream>
#include "TH1.h"
#include "TH2.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TCanvas.h"
#include "TROOT.h"
#include <TMath.h>
#include "TStyle.h"
#include "TSystem.h"
#include "TLegend.h"
#include "TText.h"
#include "TAxis.h"
#include "TFile.h"
#include "TLine.h"
#include "TGraph.h"
#include <TPaveText.h>
#include <TPostScript.h>
#include <TClass.h>
#include <TLatex.h>
#include <TFrame.h>
#include <TPad.h>

#include "TGraphErrors.h"
#include "TF1.h"
#include "TArrow.h"

//
using namespace std;
//
//
int main(int argc, char *argv[]) {
  //______________________________________________________________________________________________________________________________
  //TCanvas *c1;
  TGraph *gr1;
  TGraph *gr2;
  TGraph *gr3;
  TGraph *gr4;
  TGraph *gr5;
  TGraph *gr6;
  TGraph *gr7;
  TGraph *gr8;
  TGraph *gr9;
  TGraphErrors *ge1;
  TGraphErrors *ge2;
  TGraphErrors *ge3;
  TGraphErrors *ge4;
  TGraphErrors *ge5;
  TGraphErrors *ge6;
  TGraphErrors *ge7;
  TGraphErrors *ge8;
  TGraphErrors *ge9;

  //
  const Int_t NMethods = 38;       // total number of Methods (all-together 38 methods)
  const Int_t NMethodsStart = 0;   // since which method to start ( min=  0)
  const Int_t NMethodsToUse = 37;  // choose Number of methods to use ( max= 37)
                                   //
  TString MethodName[NMethods] = {"PLOT0",  "PLOT1",  "PLOT2",  "PLOT3",  "PLOT4",  "PLOT5",  "PLOT6",  "PLOT7",
                                  "PLOT8",  "PLOT9",  "PLOT10", "PLOT11", "PLOT12", "PLOT13", "PLOT14", "PLOT15",
                                  "PLOT16", "PLOT17", "PLOT18", "PLOT19", "PLOT20", "PLOT21", "PLOT22", "PLOT23",
                                  "PLOT24", "PLOT25", "PLOT26", "PLOT27", "PLOT28", "PLOT29", "PLOT30", "PLOT31",
                                  "PLOT32", "PLOT33", "PLOT34", "PLOT35", "PLOT36", "PLOT37"};
  //______________________________________________________________________________________________________________________________
  //LUMI-DAYS:
  const Int_t NMAX0 = 220;  // number of DAYS(time abscissa)

  // first experience with lumi taken by eye:
  Float_t LU[NMAX0] = {
      0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.2,
      1.3,  1.6,  1.9,  2.1,  2.4,  2.7,  3.0,  3.0,  3.0,  3.0,  3.0,  3.0,  3.0,  3.5,  4.0,  4.5,  5.0,  5.5,  6.0,
      6.5,  6.9,  7.0,  7.0,  7.0,  7.0,  7.0,  7.0,  7.4,  7.9,  8.3,  8.7,  9.1,  9.5,  10.0, 10.5, 10.9, 11.3, 11.7,
      12.1, 12.5, 13.0, 13.4, 13.8, 14.2, 14.6, 15.0, 15.4, 15.8, 16.2, 16.6, 17.0, 17.4, 17.8, 18.2, 18.7, 19.1, 19.5,
      19.5, 19.5, 19.5, 19.5, 19.5, 19.5, 19.5, 19.8, 20.1, 20.4, 20.8, 21.1, 21.5, 21.9, 22.2, 22.5, 22.5, 22.5, 22.5,
      23.0, 23.5, 24.0, 24.5, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.2, 25.4, 26.0, 26.5, 27.0, 27.5,
      28.0, 28.5, 29.0, 29.5, 30.0, 30.5, 31.0, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5, 31.5,
      31.5, 31.5, 31.5, 31.5, 31.5, 32.6, 32.8, 33.3, 33.7, 34.0, 34.2, 34.2, 34.2, 34.2, 34.2, 34.2, 34.2, 34.2, 34.2,
      34.2, 34.9, 35.4, 35.9, 36.4, 36.9, 37.4, 37.8, 38.3, 38.6, 39.0, 39.4, 40.0, 40.5, 41.0, 41.3, 41.3, 41.3, 41.3,
      41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3,
      41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 41.3, 0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,
      0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.};

  // recorded LUMI:
  Float_t LU0[NMAX0] = {
      24.6,  50.4,  47.7,  28.0,  122.5, 0.,    98.5,  0.02,  37.,   256.6, 0.,    0.,    0.,    0.,    0.,    0.,
      9.4,   5.1,   101.8, 130.6, 190.,  198.8, 228.5, 320.3, 301.,  338.6, 219.4, 0.,    0.,    0.,    0.,    0.,
      443.,  464.6, 0.,    365.,  191.4, 158.8, 387.8, 182.,  740.1, 0.,    0.,    0.,    73.9,  472.,  550.,  0.,
      237.4, 345.1, 104.9, 0.,    608.4, 340.8, 617.7, 0.,    500.,  532.6, 485.,  360.6, 491.6, 289.7, 525.,  0.,
      541.5, 481.4, 529.1, 172.,  470.,  611.,  0.,    673.9, 518.7, 756.5, 250.4, 61.3,  0.,    0.,    0.,    0.,
      0.,    0.,    385.4, 0.,    324.7, 367.4, 39.2,  412.7, 468.,  298.,  274.,  0.,    0.,    0.,    580.7, 482.4,
      200.2, 249.9, 407.3, 126.6, 40.3,  180.,  0.,    0.,    0.,    0.,    238.7, 391.6, 284.9, 805.2, 513.6, 224.7,
      464.5, 265.2, 471.3, 857.4, 0.,    286.5, 428.7, 0.,    505.5, 374.3, 0.,    0.,    0.,    0.,    0.,    0.,
      0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    17.4,  519.7, 469.4, 397.9, 0.,    752.,  0.,
      392.6, 0.,    0.,    24.9,  0.,    10.4,  494.4, 441.7, 211.8, 152.6, 217.4, 600.7, 350.8, 434.6, 500.,  127.6,
      400.,  126.8, 399.,  271.3, 819.,  322.8, 364.6, 106.4, 350.,  111.1, 385.3, 0.0,   0.9,   102.5, 130.3, 0.0,
      0.112, 0.071, 0.036, 1.771, 1.004, 12.40, 10.81, 3.80,  5.396, 8.971, 0.006, 11.17, 4.364, 0.671, 1.310, 7.819,
      8.927, 7.179, 8.289, 8.268, 4.788, 5.304, 5.443, 0.668, 1.128, 2.569, 7.931, 10.70, 7.068, 10.96, 10.29, 5.189,
      0.112, 0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.};
  //		     delivered LUMI: recorderLUMI*klumi    (=1.076 (41.3/38.3713)   )
  Float_t LU1[NMAX0];
  Float_t klumi = 1.076;
  //                   Float_t LU1[NMAX0];Float_t klumi = 1.1023122;
  int ncounts = 1;
  LU1[ncounts - 1] = klumi * LU0[ncounts - 1] / 1000.;  // fb-1
                                                        // just comparison:
  cout << "Terminated:  ind = " << ncounts - 1 << "     LU1 = " << LU1[ncounts - 1] << "     LU = " << LU[ncounts - 1]
       << endl;

  for (int jj = 1; jj < NMAX0; jj++) {
    LU1[ncounts] = LU1[ncounts - 1] + klumi * LU0[jj] / 1000.;
    //           cout << "  ind = " <<      ncounts   << "     LU1 = " <<      LU1[ncounts]    << "     LU = " <<      LU[ncounts]    <<endl;
    ++ncounts;
  }
  cout << "LU1[NMAX0-1] = " << LU1[NMAX0 - 1] << endl;

  // LU1-stuff above obsolet !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  //______________________________________________________________________________________________________________________________
  ///===============================================================================================================================================================================================
  //===============================================================================================================================================================================================
  //______________________________________________________________________________________________________________________________
  //   year              date                    #days             dates        #lines_in_massive
  //     2016 :  10.5.2016  - 15.11.2016     (190-1)+1=190        1 - 190         168               190 days; 168 lines in massive corresponding LumiFills in Days with Stable Beams only;  ALF = 168 ->  AlmostLumiFills
  // fall2016 : 2016.11.16  - 2016.12.04     (209-191)+1=19     191 - 209          34
  //     2017 : 2017.04.13  - 2017.11.15     (554-370)+1=185    370 - 554         226
  //     2018 : 2018.04.17  - 2018.10.26     (899-707)+1=193    707 - 899         241

  //		    const Int_t ALF =168; +34 = 202; +226 = 428                          n=171 -> 27.10 pb-1, but since 172 -> nb-1 already for starting Ion runs; Then, since 203 -> fb-1  +11 (in 2016)
  //		    const Int_t ALF =428; // 417+11 (fall2016+2017)=428
  const Int_t ALF = 670;  // 428+241 lines (2018) = 669

  Int_t DeltaDaysLumiTaken[ALF] = {
      1,   2,   3,   5,   5,   5,   7,   7,   8,   9,   9,   11,  18,  18,  18,  19,  20,  20,  21,  22,  23,  23,  24,
      25,  25,  26,  27,  33,  33,  35,  36,  37,  39,  39,  40,  41,  41,  42,  46,  47,  48,  50,  51,  52,  52,  53,
      54,  54,  55,  56,  56,  58,  59,  60,  61,  62,  64,  64,  66,  67,  68,  69,  70,  71,  73,  74,  74,  74,  75,
      75,  76,  77,  77,  84,  84,  84,  86,  87,  87,  88,  88,  89,  90,  91,  91,  92,  95,  96,  96,  96,  97,  98,
      99,  99,  100, 100, 101, 101, 102, 102, 103, 108, 108, 108, 109, 110, 110, 111, 111, 112, 113, 114, 114, 115, 115,
      116, 117, 117, 118, 119, 120, 122, 123, 139, 139, 139, 140, 140, 141, 142, 144, 144, 146, 150, 152, 152, 153, 153,
      154, 155, 156, 156, 157, 158, 158, 159, 160, 161, 161, 162, 163, 163, 163, 165, 165, 166, 167, 167, 168, 169, 170,
      170, 171, 185, 185, 187, 189, 190, 191, 191, 193, 193, 193, 194, 195, 195, 197, 197, 198, 198, 199, 200, 201, 201,
      201, 202, 202, 203, 203, 204, 205, 205, 205, 206, 206, 206, 207, 207, 208, 208, 209, 209, 339, 371, 379, 380, 381,
      382, 383, 383, 384, 384, 386, 389, 390, 391, 392, 398, 398, 398, 400, 400, 401, 401, 402, 402, 403, 403, 404, 405,
      406, 408, 409, 409, 410, 410, 411, 411, 412, 412, 413, 414, 414, 415, 415, 415, 425, 425, 427, 428, 430, 430, 431,
      431, 432, 432, 434, 434, 435, 435, 435, 435, 436, 436, 437, 438, 440, 443, 444, 444, 444, 445, 445, 445, 445, 446,
      447, 447, 449, 450, 451, 451, 452, 452, 453, 454, 454, 455, 455, 456, 456, 459, 461, 461, 461, 462, 462, 463, 463,
      464, 464, 464, 464, 465, 466, 466, 467, 468, 469, 469, 470, 471, 473, 474, 474, 475, 475, 476, 477, 477, 478, 479,
      479, 479, 480, 480, 481, 481, 482, 483, 483, 483, 484, 484, 485, 486, 486, 486, 487, 487, 488, 488, 489, 490, 490,
      490, 491, 500, 501, 501, 502, 502, 503, 503, 504, 505, 505, 506, 507, 508, 508, 509, 509, 509, 510, 511, 512, 512,
      513, 513, 514, 514, 515, 516, 516, 517, 517, 518, 519, 520, 520, 521, 522, 523, 523, 524, 525, 525, 526, 526, 527,
      527, 528, 529, 529, 530, 530, 531, 531, 532, 533, 534, 535, 535, 536, 536, 537, 538, 538, 539, 539, 540, 540, 541,
      542, 543, 545, 548, 548, 550, 551, 551, 551, 552, 553, 554, 554, 554, 707, 707, 708, 709, 710, 711, 711, 712, 712,
      714, 715, 715, 716, 716, 717, 717, 718, 718, 719, 719, 720, 721, 722, 722, 722, 723, 724, 724, 725, 725, 725, 726,
      726, 727, 727, 728, 729, 730, 730, 731, 732, 732, 733, 734, 735, 735, 736, 736, 736, 737, 738, 738, 739, 739, 740,
      740, 741, 742, 742, 743, 744, 745, 746, 747, 748, 748, 748, 750, 750, 751, 751, 752, 752, 753, 754, 755, 755, 756,
      757, 757, 759, 759, 760, 761, 761, 762, 762, 776, 777, 777, 778, 779, 779, 780, 781, 782, 783, 783, 784, 784, 785,
      785, 786, 787, 788, 789, 789, 790, 792, 792, 793, 794, 795, 795, 796, 796, 796, 797, 797, 798, 799, 800, 800, 801,
      801, 802, 802, 803, 803, 804, 811, 812, 813, 813, 814, 814, 815, 815, 816, 817, 817, 818, 819, 819, 819, 820, 821,
      821, 822, 823, 823, 824, 825, 825, 826, 826, 826, 827, 829, 829, 830, 831, 832, 835, 835, 836, 837, 838, 838, 839,
      839, 840, 840, 841, 841, 841, 842, 843, 843, 843, 844, 844, 845, 845, 845, 846, 846, 847, 847, 848, 849, 849, 850,
      850, 850, 851, 851, 852, 852, 853, 859, 866, 866, 867, 867, 868, 868, 868, 872, 872, 873, 873, 874, 874, 876, 876,
      877, 877, 879, 880, 881, 881, 882, 883, 887, 887, 888, 889, 889, 890, 890, 891, 892, 892, 893, 894, 894, 895, 895,
      896, 899, 909

  };  //

  const Int_t NMAXDAYS = DeltaDaysLumiTaken[ALF - 1];
  cout << "*********** NMAXDAYS = ************* " << NMAXDAYS << endl;

  Float_t DeliveredLumi[ALF] = {
      28.0,   59.1,    54.9,   33.5,    31.0,    103.2,   31.4,   72.3,   0.0,    39.3,   0.1,     269.2,   9.7,
      0.0,    7.1,     103.1,  6.7,     137.5,   204.2,   158.6,  57.9,   249.3,  352.8,  8.0,     308.5,   353.9,
      235.9,  48.6,    435.7,  488.1,   406.5,   201.7,   198.5,  403.0,  203.4,  107.3,  144.1,   523.0,   85.6,
      547.4,  710.5,   254.4,  363.4,   19.3,    100.0,   121.2,  122.1,  557.0,  356.7,  171.3,   496.7,   538.8,
      564.1,  505.6,   381.3,  535.1,   311.8,   552.3,   570.9,  517.4,  549.5,  181.8,  540.6,   652.2,   514.2,
      197.6,  150.0,   409.9,  34.2,    485.3,   115.8,   163.7,  65.7,   0.0,    54.9,   366.4,   340.2,   36.9,
      353.0,  29.9,    21.3,   436.0,   150.3,   369.8,   313.9,  295.6,  0.0,    0.0,    182.2,   448.1,   519.3,
      223.5,  103.9,   38.7,   124.1,   430.9,   34.3,    108.3,  27.6,   14.8,   188.0,  0.0,     7.1,     241.2,
      447.0,  216.8,   96.4,   431.4,   412.0,   546.5,   232.0,  84.8,   394.7,  334.9,  77.1,    486.4,   96.4,
      251.9,  598.7,   339.4,  465.3,   542.1,   401.2,   0.1,    11.3,   8.5,    88.2,   495.1,   493.6,   412.8,
      415.9,  383.4,   405.9,  25.0,    0.2,     11.2,    38.4,   498.8,  467.6,  45.8,   213.1,   166.6,   263.8,
      6.5,    615.5,   374.4,  458.1,   0.0,     534.7,   132.6,  1.1,    234.2,  205.0,  229.8,   417.9,   297.5,
      443.3,  416.9,   339.1,  380.0,   111.1,   385.3,   0.0,    0.9,    0.0,    102.5,  130.3,   0.0,     111.8,
      71.2,   36.5,    1770.9, 10047.3, 12403.8, 10891.5, 3806.9, 5396.6, 8971.2, 5.8,    11172.5, 4364.3,  671.1,
      6.7,    1310.7,  7819.1, 8927.2,  7179.0,  8289.8,  8268.8, 4788.3, 5304.8, 5443.9, 668.1,   11286.1, 2569.6,
      7931.7, 10707.8, 7068.5, 10965.6, 10299.9, 5189.4,  112.7,  0.0,    0.0,    0.2,    0.1,     0.9,     0.6,
      8.3,    7.1,     3.9,    53.1,    63.3,    5.7,     85.2,   2.5,    50.1,   0.1,    43.3,    13.9,    132.2,
      70.6,   114.2,   209.8,  70.2,    140.9,   153.2,   254.1,  93.1,   380.7,  519.7,  427.4,   44.2,    214.1,
      347.0,  89.5,    8.6,    518.9,   390.4,   399.7,   435.9,  87.9,   390.3,  253.3,  12.3,    189.5,   0.0,
      0.0,    2.7,     26.6,   54.6,    4.9,     334.2,   56.8,   125.2,  226.6,  186.9,  330.1,   85.6,    99.2,
      17.4,   44.5,    15.0,   518.7,   460.9,   153.7,   111.6,  0.1,    0.0,    0.1,    2.1,     14.9,    54.8,
      10.8,   535.2,   523.1,  135.6,   522.3,   423.1,   110.5,  440.3,  487.8,  67.4,   523.4,   486.9,   353.8,
      561.3,  48.1,    105.1,  496.7,   427.1,   5.8,     22.9,   105.0,  123.1,  71.8,   149.4,   165.8,   178.1,
      70.2,   62.7,    102.8,  296.1,   74.6,    214.9,   107.2,  295.0,  254.9,  67.9,   136.2,   142.4,   20.3,
      92.0,   78.5,    304.2,  33.3,    309.3,   297.8,   10.4,   314.2,  122.3,  17.6,   166.5,   109.4,   112.6,
      146.8,  253.1,   189.9,  102.8,   101.3,   159.6,   136.2,  248.6,  324.2,  322.4,  74.5,    340.9,   14.8,
      13.8,   269.6,   83.3,   316.0,   339.0,   330.3,   111.0,  164.2,  16.3,   0.0,    3.5,     16.0,    149.6,
      344.8,  416.5,   432.5,  420.6,   285.3,   399.2,   457.1,  563.5,  390.3,  435.8,  150.7,   164.1,   134.0,
      389.8,  386.6,   73.4,   441.1,   437.7,   468.7,   237.8,  272.2,  161.1,  450.8,  300.1,   342.3,   502.0,
      463.7,  587.6,   0.0,    6.3,     501.9,   595.2,   335.4,  526.7,  494.5,  525.0,  420.7,   392.9,   521.9,
      48.8,   525.6,   472.8,  70.2,    546.6,   471.7,   519.0,  133.1,  501.9,  591.2,  552.9,   14.5,    279.2,
      49.6,   471.8,   255.3,  607.6,   213.0,   241.3,   162.3,  52.5,   50.7,   486.7,  555.8,   703.0,   712.6,
      743.8,  374.4,   680.8,  0.1,     4.2,     2.6,     22.7,   57.2,   36.6,   0.1,    1.2,     12.6,    0.3,
      0.1,    1.5,     13.6,   5.8,     9.4,     0.4,     63.2,   39.0,   63.2,   115.6,  7.2,     82.0,    78.1,
      181.2,  181.6,   95.0,   155.5,   264.8,   260.3,   354.6,  392.0,  37.6,   124.3,  509.7,   459.8,   332.3,
      365.0,  214.7,   25.7,   117.0,   123.7,   520.5,   317.6,  354.2,  305.0,  523.0,  141.9,   501.3,   259.6,
      554.5,  597.7,   575.8,  552.5,   32.3,    93.8,    204.3,  4.6,    342.6,  396.4,  402.1,   0.6,     493.0,
      189.5,  83.8,    436.6,  383.8,   490.6,   456.3,   558.2,  390.6,  45.0,   495.0,  172.5,   272.8,   8.9,
      496.8,  0.0,     407.9,  181.9,   67.5,    541.7,   518.8,  234.4,  54.7,   500.9,  500.6,   439.0,   358.9,
      449.0,  112.2,   527.2,  529.3,   487.2,   543.4,   118.7,  231.9,  0.1,    16.5,   46.4,    76.5,    13.9,
      400.0,  0.2,     0.4,    17.0,    0.0,     0.1,     0.4,    0.8,    0.1,    0.2,    2.4,     0.9,     1.3,
      229.7,  276.6,   602.5,  159.5,   613.2,   0.3,     793.8,  70.6,   405.4,  234.0,  95.4,    17.1,    100.1,
      486.3,  72.2,    342.3,  454.2,   115.0,   65.6,    529.3,  454.3,  308.6,  408.0,  424.5,   0.2,     0.0,
      0.2,    98.9,    156.3,  69.5,    116.9,   432.6,   452.6,  290.4,  441.8,  148.1,  506.5,   357.6,   39.0,
      78.0,   453.7,   473.8,  395.4,   514.5,   314.6,   458.4,  371.8,  214.6,  500.3,  322.9,   10.0,    411.6,
      754.0,  523.4,   572.2,  472.6,   535.4,   500.7,   117.1,  523.6,  446.2,  518.1,  80.0,    520.7,   527.0,
      162.5,  292.7,   521.7,  282.1,   107.8,   156.8,   535.8,  520.1,  13.9,   484.7,  16.0,    10.4,    248.2,
      361.3,  297.8,   332.0,  496.5,   528.9,   445.7,   510.0,  331.6,  436.2,  282.6,  188.7,   183.5,   495.2,
      481.5,  3.3,     429.6,  409.9,   0.0,     4.0,     70.2,   134.8,  398.5,  451.0,  0.2,     521.8,   497.0,
      413.0,  313.9,   337.4,  313.4,   268.8,   471.9,   328.5,  408.5,  462.0,  501.4,  79.7,    437.9,   537.3,
      196.0,  251.9,   0.0,    0.0,     0.2,     31.6,    533.4,  452.3,  546.8,  424.0,  54.2,    545.8,   550.8,
      412.6,  452.3,   127.9,  559.9,   449.9,   3.6,     0.0};  // DeliveredLumi pb-1; since 172 t0 209 ->nb-1; then again -> pb-1
  //______________________________________________________________________________________________________________________________

  //   treatment to obtaine massives of Days and DeliveredLumiForDays:
  cout << "*********************    treatment to obtaine massives of Days and DeliveredLumiForDays "
          "************************** "
       << endl;
  Float_t DeliveredLumiForDays[ALF];
  Int_t Days[ALF];
  for (int w9 = 0; w9 < ALF; w9++) {
    Days[w9] = 0.;
    DeliveredLumiForDays[w9] = 0.;
  }
  int w8 = 0;
  Days[w8] = DeltaDaysLumiTaken[0];
  DeliveredLumiForDays[w8] += DeliveredLumi[0];
  //    cout << "  w8 = " <<      w8   << "     Days[w8] = " <<      Days[w8]    << "    DeliveredLumiForDays[w8]= " <<    DeliveredLumiForDays[w8]    <<endl;
  for (int w9 = 1; w9 < ALF; w9++) {
    if (DeltaDaysLumiTaken[w9] != DeltaDaysLumiTaken[w9 - 1])
      w8++;
    Days[w8] = DeltaDaysLumiTaken[w9];
    if (DeltaDaysLumiTaken[w9] < 172)
      DeliveredLumiForDays[w8] += DeliveredLumi[w9];  // pb-1
    if (DeltaDaysLumiTaken[w9] > 171 && DeltaDaysLumiTaken[w9] < 210)
      DeliveredLumiForDays[w8] += DeliveredLumi[w9] / 1000.;  // nb-1
    if (DeltaDaysLumiTaken[w9] > 209)
      DeliveredLumiForDays[w8] += DeliveredLumi[w9];  //  pb-1
    //		      if((DeltaDaysLumiTaken[w9] > 170 && DeltaDaysLumiTaken[w9] < 210)|| DeltaDaysLumiTaken[w9] > 550) cout << "  w8 = " <<      w8   << "     Days[w8] = " <<      Days[w8]    << "    DeliveredLumiForDays[w8]= " <<    DeliveredLumiForDays[w8]    <<endl;
  }  // w8massive: 0,...w8 -> w8+1 elements; last element w8
     //   cout << "#Days for RunII up to fall2016 = " <<      w8+1   <<endl;// result:115 elements in massive: 0,...114
     //   cout << "Last Day for RunII up to fall2016 = " <<      Days[w8]   <<endl;
     //   cout << "this LAST Day DeliveredLumi = " <<      DeliveredLumiForDays[w8]   <<endl;

  // result:
  //______________________________________________________________________________________________________________________________
  // delivered LUMI:
  Float_t LU2[NMAXDAYS];
  for (int w9 = 0; w9 < NMAXDAYS; w9++) {
    LU2[w9] = 0.;
  }
  // day 1 , massive-index = 0:
  LU2[0] = DeliveredLumiForDays[0] / 1000.;
  //		    cout << " days = 1" << " Days[w8counts] = " << Days[0]  << " LU2 = " << LU2[0] << " LU1= " <<  LU1[0] << " w8counts = 0 " << " DeliveredLumi = " << DeliveredLumiForDays[0]/1000.  <<endl;
  // next day, massive-index = 1
  int w8counts = 1;
  for (int jj = 1; jj < NMAXDAYS; jj++) {
    if (jj + 1 == Days[w8counts]) {
      LU2[jj] = LU2[jj - 1] + DeliveredLumiForDays[w8counts] / 1000.;
      //			cout << " days = " << jj+1 << " Days[w8counts] = " << Days[w8counts]  << " LU2 = " << LU2[jj] << " LU1= " <<  LU1[jj] << " w8counts = " << w8counts  << " DeliveredLumi = " << DeliveredLumiForDays[w8counts]/1000.  <<endl;
      w8counts++;
      if (w8counts > w8)
        break;
    } else {
      LU2[jj] = LU2[jj - 1];
      //		      cout << " days = " << jj+1 << " Days[w8counts] = " << Days[w8counts]  << " LU2 = " << LU2[jj] << " LU1= " <<  LU1[jj] << " w8counts = " << w8counts  << " DeliveredLumi = " << DeliveredLumiForDays[w8counts]/1000.  <<endl;
    }
  }  //for jj
  // finally:
  cout << "before any correction: LU2[NMAXDAYS-1] = " << LU2[NMAXDAYS - 1] << endl;

  //	 normilized delivered LUMI: LU2*klumi2   (=1.015       (41.07/40.46)   );
  //		    Float_t klumi2= 1.015;
  // once Ldeliv(22.04-27.10 ) = 41.07 but Ldeliv(10.05-27.10 ) = 40.46 i.e. diff=1.5% because of dates, do not apply this correction, just =1.0 !!!
  Float_t klumi2 = 1.0;

  TH1F *lumiplot = new TH1F("lumiplot", "", NMAXDAYS + 1, 1., float(NMAXDAYS) + 1.);
  TH1F *lumiplot1 = new TH1F("lumiplot1", "", 172 + 1, 1., float(172) + 1.);
  TH1F *lumiplot2 = new TH1F("lumiplot2", "", 190 + 1, 1., float(190) + 1.);
  TH1F *lumiplot3 = new TH1F("lumiplot3", "", 195 + 1, 1., float(195) + 1.);
  for (int jj = 0; jj < NMAXDAYS; jj++) {
    if (jj < 172) {
      LU2[jj] *= klumi2;
      lumiplot1->Fill(float(jj + 1), LU2[jj]);
    }
    if (jj > 370) {
      lumiplot2->Fill(float(jj + 1 - 370), LU2[jj] - LU2[371]);
    }
    if (jj > 707) {
      lumiplot3->Fill(float(jj + 1 - 707), LU2[jj] - LU2[708]);
    }
    lumiplot->Fill(float(jj + 1), LU2[jj]);
    //		      lumiplot->SetBinError(0.,0.);
  }
  cout << "day 172(27.10.2016) LU2 = " << LU2[171] << endl;
  //		    cout << "since 15.05.2017 LU2 = " <<      LU2[NMAXDAYS-1]-LU2[370]    <<endl;
  cout << "since 15.05.2017 LU2 = " << LU2[555] - LU2[370] << endl;
  cout << "since 17.04.2018 LU2 = " << LU2[NMAXDAYS - 1] - LU2[706] << endl;
  cout << "after any correction: LU2[NMAXDAYS-1] = " << LU2[NMAXDAYS - 1] << endl;

  //______________________________________________________________________________________________________________________________  Lumi end
  //______________________________________________________________________________________________________________________________
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////  runs for positive direction: P kdirection = 1
  // always use maximal!!! value of massives dimention below:
  //		    const Int_t NMAXP =102;// 623 runs 321 days    50+623 = 673-6=667   22*2+6=50; 22*3+15=81;   50+81=131; -13 = 113; -3 = 110; -6 = 104 -1 =103; -1 102
  //		    const Int_t NMAXP =437;// 623 runs 321 days    50+623 = 673-6=667   22*2+6=50; 22*3+15=81;   50+81=131; -13 = 113; -3 = 110; -6 = 104 -1 =103; -1 102
  // 102+32= 134
  const Int_t NMAXP =
      134;  // 623 runs 321 days    50+623 = 673-6=667   22*2+6=50; 22*3+15=81;   50+81=131; -13 = 113; -3 = 110; -6 = 104 -1 =103; -1 102
  //  const Int_t NMAXP =50;// number of LASER runs(time abscissa)    50(2016)  +  52(1017)
  TString LASERrunsP[NMAXP] = {
      "272957", "273354", "273899", "274185", "274260", "274357", "274409", "274462", "274767", "275273", "275392",
      "275707", "275802", "275877", "276256", "276424", "276465", "276479", "276523", "276556", "276823", "277134",
      "277340", "278074", "278223", "278326", "278592", "278901", "279098", "279610", "279734", "279804", "280141",
      "280204", "280266", "280378", "282043", "282777", "282850", "282854", "282931", "283117", "283328", "283365",
      "283401", "283445", "283800", "283840", "283982", "285355",

      "285701", "285878", "287385", "287739", "287765", "287766", "287866", "287867", "287868", "287869", "287870",
      "288174", "288180", "288181", "288182", "288988", "295678", "296810", "297084", "297526", "297573", "297632",
      "297692", "297850", "298104", "298295", "298794", "299461", "299971", "300181", "302109", "302256", "302412",
      "302431", "302434", "302587", "302614", "303249", "303853", "303928", "304232", "304425", "304601", "304633",
      "304682", "304748", "304860", "305127", "305217", "305472", "305702", "305874",

      "315059", "315435", "315591", "315809", "316190", "316191", "316192", "316396", "316672", "316748", "316774",
      "316814", "316885", "316967", "317048", "317113", "317199", "317359", "317423", "317598", "317679", "317724",
      "317783", "317975", "320576", "321326", "321353", "321444", "321858", "321863", "323505", "324704"

      //================== 345 LASER runs of 2018:
      /*
,
"315059", "315064", "315082", "315276", "315435", "315442", "315586", "315591", "315600", "315604", "315606", "315609", "315612", "315808", "315809", "315979", "315988", "315994", "315997", "316071", "316074", "316117", "316118", "316190", "316191", "316192", "316193", "316194", "316244", "316248", "316250", "316253", "316257", "316298", "316300", "316303", "316304", "316309", "316384", "316392", "316396", "316397", "316401", "316402", "316476", "316479", "316481", "316484", "316488", "316520", "316521", "316523", "316526", "316527", "316528", "316570", "316572", "316573", "316574", "316622", "316623", "316625", "316628", "316669", "316670", "316671", "316672", "316673", "316744", "316748", "316771", "316772", "316774", "316776", "316777", "316812", "316814", "316818", "316819", "316822", "316832", "316834", "316836", "316837", "316838", "316884", "316885", "316887", "316888", "316966", "316967", "316969", "316970", "317000", "317003", "317005", "317009", "317012", "317044", "317048", "317109", "317113", "317123", "317135", "317137", "317142", "317145", "317147", "317195", "317197", "317198", "317199", "317237", "317238", "317307", "317310", "317311", "317324", "317332", "317356", "317359", "317360", "317361", "317364", "317365", "317366", "317369", "317370", "317423", "317424", "317426", "317427", "317597", "317598", "317676", "317679", "317723", "317724", "317731", "317732", "317733", "317782", "317783", "317967", "317975", "317990", "317991", "317992", "317993", "317994", "317995", "317996", "317997", "318188", "318190", "318591", "318592", "318593", "318594", "318595", "318596", "318597", "318599", "318692", "318694", "318753", "318754", "318759", "318760", "318761", "318763", "318764", "319199", "319200", "319201", "319208", "319210", "319522", "319607", "319608", "319613", "319614", "319963", "320106", "320107", "320118", "320119", "320121", "320123", "320124", "320126", "320224", "320226", "320355", "320356", "320362", "320363", "320364", "320365", "320367", "320575", "320576", "320580", "320581", "320582", "320583", "320584", "320868", "320870", "320874", "320876", "320878", "321030", "321031", "321037", "321039", "321040", "321041", "321042", "321044", "321193", "321195", "321324", "321325", "321326", "321353", "321355", "321362", "321363", "321366", "321367", "321368", "321418", "321422", "321444", "321448", "321449", "321450", "321452", "321453", "321454", "321571", "321575", "321590", "321591", "321697", "321700", "321703", "321805", "321808", "321809", "321811", "321812", "321854", "321858", "321860", "321863", "321873", "321876", "321890", "322161", "322162", "322241", "322242", "322265", "322266", "322268", "322270", "322273", "322411", "322412", "322420", "322421", "322832", "322834", "322859", "322861", "323505", "323506", "323581", "323582", "323584", "323735", "323736", "323743", "323745", "323746", "323747", "323748", "324080", "324081", "324082", "324085", "324092", "324095", "324096", "324097", "324106", "324109", "324139", "324140", "324141", "324142", "324143", "324144", "324216", "324217", "324226", "324227", "324228", "324229", "324230", "324589", "324676", "324677", "324703", "324704", "324922", "324927", "325265", "325266", "325451", "325452", "325634", "325635", "325636", "325638", "326444", "326445", "326447", "326448", "327672", "327678", "327680", "327681"
*/

  };  //
  /*
P: 0 - 101: 0-49  & 50-101  ->  66-101(2017)
yearcase=1:  since 10.05.2016  up to  15.11.2016
yearcase=2:  since 31.05.2017  up to  30.10.2017
yearcase=3:  since 10.05.2016  up to  30.10.2017
*/
  Float_t X0P[NMAXP] = {
      1.,   4.,   15.,  20.,  22.,  25.,  26.,  28.,  30.,  38.,  43.,  46.,  48.,  50.,  55.,  57.,  59.,  59.,
      60.,  62.,  67.,  74.,  77.,  85.,  87.,  90.,  93.,  99.,  103., 109., 112., 114., 119., 120., 121., 123.,
      145., 154., 155., 155., 156., 157., 160., 161., 161., 162., 165., 166., 169., 190.,

      197., 200., 277., 284., 284., 284., 287., 287., 287., 287., 287., 291., 291., 291., 291., 304., 387., 401.,
      404., 413., 414., 415., 416., 420., 422., 423., 428., 437., 444., 448., 479., 481., 485., 485., 485., 489.,
      490., 498., 504., 505., 511., 513., 515., 516., 518., 519., 521., 525., 527., 532., 535., 539.,

      715., 721., 723., 728., 733., 733., 733., 737., 742., 743., 744., 745., 746., 748., 749., 750., 751., 755.,
      756., 760., 763., 764., 766., 770., 813., 829., 829., 832., 840., 840., 869., 889.

      //   to be added... 2018

  };  // days of year    time points (abscissa) !!!

  //  for(int jjj = 1; jjj<=NMAXP; jjj++){
  //    X0P[101+jjj] = 715. + jjj ;
  //  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// negative: M kdirection = 0
  //  const Int_t NMAXM = 94;// number of LASER runs(time abscissa) 47+623 = 670 -7 = 663    47+47
  //const Int_t NMAXM = 429;// number of LASER runs(time abscissa) 47+623 = 670 -7 = 663    47+47
  //const Int_t NMAXM = 397;// number of LASER runs(time abscissa) 47+623 = 670 -7 = 663    47+47
  // 94 + 27 = 121
  const Int_t NMAXM = 121;  // number of LASER runs(time abscissa) 47+623 = 670 -7 = 663    47+47
  TString LASERrunsM[NMAXM] = {
      "272967", "273211", "273460", "273562", "273897", "274355", "274408", "274765", "275017", "275272",
      "275357", "275706", "275874", "276252", "276420", "276470", "276478", "276522", "276532", "276860",
      "277133", "277174", "277869", "278071", "278221", "278325", "278590", "278898", "279097", "279701",
      "279802", "279909", "280138", "280202", "280207", "280264", "280376", "282042", "282243", "283325",
      "283364", "283400", "283443", "283799", "283837", "284735", "285353",

      "285699", "286399", "287041", "288987", "290828", "293565", "295406", "295677", "295930", "295986",
      "296189", "296809", "297083", "297524", "297572", "297631", "297690", "297848", "298101", "298294",
      "298717", "298802", "299459", "299965", "300176", "302105", "302250", "302432", "302433", "302461",
      "302586", "302607", "303482", "303492", "303849", "303923", "304235", "304424", "304553", "304631",
      "304678", "304746", "304858", "305214", "305468", "305701", "305871",

      "315056", "315586", "315808", "316118", "316193", "316194", "316253", "316527", "316528", "316772",
      "316812", "316884", "316966", "317044", "317109", "317198", "317310", "317356", "317424", "317597",
      "317723", "317782", "317967", "319607", "321030", "325265", "325634"

      //================== 302 LASER runs of 2018:
      /*
,
"315056", 
"315064","315082","315276","315442","315586","315600","315604","315609","315612","315808","315979","315988","315994","315997","316071","316074","316117","316118","316193","316194","316244","316248","316250","316253","316257",
"316298","316300","316303","316304","316309","316384","316392","316397","316401","316402","316476","316479","316481","316484","316488","316520","316521","316523","316526","316527","316528","316570","316572","316574","316622",
"316623","316625","316628","316669","316670","316671","316673","316744","316771","316772","316776","316777","316812","316818","316819","316822","316832","316834","316836","316837","316838","316884","316887","316888","316966",
"316969","316970","317000","317003","317005","317009","317012","317044","317109","317123","317135","317137","317142","317145","317147","317195","317197","317198","317237","317238","317307","317310","317311","317324","317332",
"317356","317360","317361","317364","317365","317366","317369","317370","317424","317426","317427","317597","317676","317723","317731","317732","317733","317782","317967","317990","317991","317992","317993","317994","317995",
"317996","317997","318188","318190","318591","318592","318593","318594","318595","318596","318597","318599","318692","318694","318753","318754","318759","318760","318761","318763","318764","319199","319200","319201","319208",
"319210","319522","319607","319608","319613","319614","319963","320106","320107","320118","320119","320121","320123","320124","320126","320224","320226","320355","320356","320362","320363","320364","320365","320367","320575",
"320580","320581","320582","320583","320584","320868","320870","320874","320876","320878","321030","321031","321037","321039","321040","321041","321042","321044","321193","321195","321324","321325","321326","321355","321362",
"321363","321366","321367","321368","321418","321422","321448","321449","321450","321452","321453","321454","321571","321575","321590","321591","321697","321700","321703","321805","321808","321809","321811","321812","321854",
"321860","321873","321876","321890","322161","322162","322241","322242","322265","322266","322268","322270","322273","322411","322412","322420","322421","322832","322834","322859","322861","323506","323581","323582","323584",
"323735","323736","323743","323745","323746","323747","323748","324080","324081","324082","324085","324092","324095","324096","324097","324106","324109","324139","324140","324141","324142","324143","324144","324216","324217",
"324226","324227","324228","324229","324230","324589","324676","324677","324703","324922","324927","325265","325266","325451","325452","325634","325635","325636","325638","326444","326445","326447","326448","327672","327678",
"327680","327681"

//================== 335 LASER runs of 2018:
"315056", "315064", "315082", "315276", "315435", "315442", "315586", "315591", "315600", "315604", "315606", "315609", "315612", "315808", "315809", "315979", "315988", "315994", "315997", "316071", "316074", "316117", "316118", "316190", "316191", "316192", "316193", "316194", "316244", "316248", "316250", "316253", "316257", "316298", "316300", "316303", "316304", "316309", "316384", "316392", "316396", "316397", "316401", "316402", "316476", "316479", "316481", "316484", "316488", "316520", "316521", "316523", "316526", "316527", "316528", "316570", "316572", "316573", "316574", "316622", "316623", "316625", "316628", "316669", "316670", "316671", "316672", "316673", "316744", "316748", "316771", "316772", "316774", "316776", "316777", "316812", "316814", "316818", "316819", "316822", "316832", "316834", "316836", "316837", "316838", "316884", "316885", "316887", "316888", "316966", "316967", "316969", "316970", "317000", "317003", "317005", "317009", "317012", "317044", "317048", "317109", "317113", "317123", "317135", "317137", "317142", "317145", "317147", "317195", "317197", "317198", "317199", "317237", "317238", "317307", "317310", "317311", "317324", "317332", "317356", "317359", "317360", "317361", "317364", "317365", "317366", "317369", "317370", "317423", "317424", "317426", "317427", "317597", "317598", "317676", "317679", "317723", "317724", "317731", "317732", "317733", "317782", "317783", "317967", "317975", "317990", "317991", "317992", "317993", "317994", "317995", "317996", "317997", "318188", "318190", "318591", "318592", "318593", "318594", "318595", "318596", "318597", "318599", "318692", "318694", "318753", "318754", "318759", "318760", "318761", "318763", "318764", "319199", "319200", "319201", "319208", "319210", "319522", "319607", "319608", "319613", "319614", "319963", "320106", "320107", "320118", "320119", "320121", "320123", "320124", "320126", "320224", "320226", "320355", "320356", "320362", "320363", "320364", "320365", "320367", "320575", "320576", "320580", "320581", "320582", "320583", "320584", "320868", "320870", "320874", "320876", "320878", "321030", "321031", "321037", "321039", "321040", "321041", "321042", "321044", "321193", "321195", "321324", "321325", "321326", "321353", "321355", "321362", "321363", "321366", "321367", "321368", "321418", "321422", "321444", "321448", "321449", "321450", "321452", "321453", "321454", "321571", "321575", "321590", "321591", "321697", "321700", "321703", "321805", "321808", "321809", "321811", "321812", "321854", "321858", "321860", "321863", "321873", "321876", "321890", "322161", "322162", "322241", "322242", "322265", "322266", "322268", "322270", "322273", "322411", "322412", "322420", "322421", "322832", "322834", "322859", "322861", "323505", "323506", "323581", "323582", "323584", "323735", "323736", "323743", "323745", "323746", "323747", "323748", "324080", "324081", "324082", "324085", "324092", "324095", "324096", "324097", "324106", "324109", "324139", "324140", "324141", "324142", "324143", "324144", "324216", "324217", "324226", "324227", "324228", "324229", "324230", "324589", "324676", "324677", "324703", "324704", "324922", "324927", "325265", "325266", "325451", "325452", "325634", "325635", "325636", "325638", "326444", "326445", "326447", "326448", "327672", "327678", "327680", "327681"
*/

  };
  //                                       22.10     06.11    15.11
  /*
P: 0 - 93: 0-46  & 47-93  ->   ->  53-93(2017)
yearcase=1:  since 10.05.2016  up to  15.11.2016
yearcase=2:  since 28.05.2017  up to  30.10.2017
yearcase=3:  since 10.05.2016  up to  30.10.2017
*/
  Float_t X0M[NMAXM] = {1.,   3.,   6.,   9.,   15.,  25.,  26.,  30.,  36.,  38.,  41.,  46.,  50.,  55.,  57.,  59.,
                        59.,  60.,  61.,  68.,  74.,  75.,  83.,  85.,  87.,  90.,  93.,  99.,  103., 111., 114., 116.,
                        119., 120., 120., 121., 123., 145., 148., 159., 161., 161., 162., 165., 166., 181., 190.,

                        197., 207., 273., 304., 329., 364., 384., 387., 389., 390., 393., 401., 404., 413., 414., 415.,
                        416., 420., 422., 423., 427., 428., 437., 444., 448., 479., 481., 485., 485., 486., 489., 490.,
                        500., 500., 504., 505., 511., 513., 515., 516., 518., 519., 521., 527., 532., 535., 539.,

                        715., 723., 728., 732., 733., 733., 735., 739., 739., 744., 745., 746., 747., 748., 749., 750.,
                        752., 754., 755., 759., 763., 765., 769., 795., 820., 899., 899.

  };  // days of year    time points (abscissa) !!!

  //  for(int jjj = 1; jjj<=NMAXM; jjj++){
  //    X0M[93+jjj] = 715. + jjj ;
  //  }

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //______________________________________________________________________________
  //______________________________________________________________________________
  //______________________________________________________________________________
  //______________________________________________________________________________
  //                                           2016 only:                   yearcase=1
  //                                           2017 only:                   yearcase=2
  //                                           20167    :                   yearcase=3
  //                                           2018 only:                   yearcase=4
  //                                           201678   :                   yearcase=5

  //define yearcase:
  //         ____________________________________________________________________________                    THIS line below is MAIN to make a yearcase selection !!!!!!!!!!!!!!!!!!!!!!!!!!
  const Int_t yearcase = 4;
  //______________________________________________________________________________

  //______________________________________________________________________________
  // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  flaglumiuse
  Int_t flaglumiuse = 2;  // =0-days; =1-lumi1; =2-lumi2(recomendent);

  //      Int_t flaglumiuse = 0; // =0-days; =1-lumi1; =2-lumi2;
  cout << "!!*********************        flaglumiuse  = " << flaglumiuse << endl;

  //______________________________________________________________________________
  //
  //---=[ SetCanvasDef           ]=----------------
  // Create a new canvas.
  TCanvas *c1 = new TCanvas("c1", "Hcal4test", 10, 10, 900, 700);
  //TCanvas  *c1 = new TCanvas("c1","Hcal4test",200,10,700,900);

  c1->Range(0, 0, 25, 18);
  //c1->SetFillColor(40);
  c1->SetFillColor(0);
  c1->Clear();

  TLatex *t = new TLatex();
  t->SetTextFont(32);
  //t->SetTextColor(4);
  t->SetTextSize(0.03);
  t->SetTextAlign(12);
  //______________________________________________________________________________
  t->DrawLatex(0.9,
               15.5,
               "Time dependence of full Amplitude averaged over events of each LASER run for some random HE channels");

  //-----------------------------------------------------------------------------------------------------
  //
  //              x1   y1     x2     y2
  //    pad1->DrawFrame(1,   0.8,  370,   1.2);// all

  //

  // x(abscissa) for Days, no Lumi:
  //(yearcase == 1
  Float_t x1 = 0.00;
  Float_t x2 = 200.00;
  int Dref = 3;
  int DepthMax = 4;  // depthes: for ref channel & #depthes
  if (yearcase == 2)
    x2 = 200.00;
  if (yearcase == 3)
    x2 = 550.00;
  if (yearcase == 4)
    x2 = 200.00;
  if (yearcase == 5)
    x2 = 900.00;

  // y(ordinate) for All Days and Lumi:
  //(yearcase == 1
  Float_t y1 = 0.60;
  Float_t y2 = 1.01;  //  for 1,2,5,6   for 11,12,15,16
  Float_t y3 = 0.85;
  Float_t y4 = 1.01;  //   for 3,4  for 13,14
  Float_t y5 = 0.70;
  Float_t y6 = 1.01;  //  for 7,8  for 17,18
  if (yearcase == 2) {
    y1 = 0.60;
    y2 = 1.01;  // 11: 0.40  12: 0.40   15: 0.40  16: 0.40   -> same for 1,2,5,6
    y3 = 0.85;
    y4 = 1.01;  // 13: 0.85  14: 0.75 0.8 18: 0.75 0.8      -> same for 3,4
    y5 = 0.70;
    y6 = 1.01;  // 17: 0.5 18: 0.75                  -> same for 7,8
  }
  if (yearcase == 3) {
    y1 = 0.40;
    y2 = 1.01;  // 11: 0.40  12: 0.40   15: 0.40  16: 0.40   -> same for 1,2,5,6
    y3 = 0.75;
    y4 = 1.01;  // 13: 0.85  14: 0.75 0.8 18: 0.75 0.8      -> same for 3,4
    y5 = 0.60;
    y6 = 1.01;  // 17: 0.5 18: 0.75                  -> same for 7,8
  }
  if (yearcase == 4) {
    Dref = 4;
    DepthMax = 8;
    y1 = 0.60;
    y2 = 1.01;  // 11: 0.40  12: 0.40   15: 0.40  16: 0.40   -> same for 1,2,5,6
    y3 = 0.85;
    y4 = 1.01;  // 13: 0.85  14: 0.75 0.8 18: 0.75 0.8      -> same for 3,4
    y5 = 0.70;
    y6 = 1.01;  // 17: 0.5 18: 0.75                  -> same for 7,8
  }
  if (yearcase > 4) {
    Dref = 4;
    DepthMax = 8;
    y1 = 0.30;
    y2 = 1.01;  // 11: 0.40  12: 0.40   15: 0.40  16: 0.40   -> same for 1,2,5,6
    y3 = 0.65;
    y4 = 1.01;  // 13: 0.85  14: 0.75 0.8 18: 0.75 0.8      -> same for 3,4
    y5 = 0.50;
    y6 = 1.01;  // 17: 0.5 18: 0.75                  -> same for 7,8
  }

  //
  Float_t xx1 = 0.12;
  Float_t xx2 = 0.31;
  Float_t yy1 = 0.17;
  Float_t yy2 = 0.38;
  //
  //-----------------------------------------------------------------------------------------------------
  //-----------------------------------------------------------------------------------------------------
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // define max size of massives (to be just NMAXSIZE ):
  Int_t NMAXSIZE = NMAXM;
  if (NMAXP > NMAXM)
    NMAXSIZE = NMAXP;
  //----------------------------------------------------------------------
  Float_t X0[NMAXSIZE];
  TString LASERruns[NMAXSIZE];
  Double_t XX[NMAXSIZE];
  Double_t XXE[NMAXSIZE];
  const Int_t NDEP = 8;
  const Int_t NETA = 14;
  const Int_t NETA0 = 83;
  const Int_t NPHI0 = 73;

  Double_t ZZM[NMAXSIZE][NDEP][NETA];
  Double_t ZZP[NMAXSIZE][NDEP][NETA];
  Double_t YY[NMAXSIZE];
  Double_t YYE[NMAXSIZE];
  //
  Double_t mapRADDAM_HE[NDEP][NETA0][NPHI0];
  Double_t mapRADDAM_HED2[NDEP][NETA0];
  Int_t mapRADDAM_HED20[NDEP][NETA0];
  Float_t gainRADDAM_HE[NDEP][NETA0][NPHI0];
  Double_t normM[NDEP][NETA0][NPHI0];
  Double_t normP[NDEP][NETA0][NPHI0];

  Double_t THETA[13] = {17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29.};
  Double_t RRM[13];
  Double_t RRP[13];
  Double_t THETA7[11] = {18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28.};
  Double_t RRM7[11];
  Double_t RRP7[11];
  for (int ij = 0; ij < 13; ij++) {
    RRM[ij] = 0.;
    RRP[ij] = 0.;
  }
  for (int ij = 0; ij < 11; ij++) {
    RRM7[ij] = 0.;
    RRP7[ij] = 0.;
  }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  TH1F *phidependenceM = new TH1F("phidependenceM", "", 72, 0., 72.);
  TH1F *phidependenceM0 = new TH1F("phidependenceM0", "", 72, 0., 72.);
  TH1F *phidependenceP = new TH1F("phidependenceP", "", 72, 0., 72.);
  TH1F *phidependenceP0 = new TH1F("phidependenceP0", "", 72, 0., 72.);
  TH1F *phidepdrawing30 = (TH1F *)phidependenceM->Clone("phidepdrawing30");
  TH1F *phidepdrawing31 = (TH1F *)phidependenceP->Clone("phidepdrawing31");
  TH1F *phiRRM = new TH1F("phiRRM", "", 100, 0., 5.);
  TH1F *phiRRP = new TH1F("phiRRP", "", 100, 0., 5.);
  // variant of order of normalization ; =2 as V.Epshteyn
  Int_t variant = 1;
  //  Int_t variant = 2;// does not work properly for moment(30.03.2017)
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// NMAXaM = NMAXmM - NMINmM + 1
  //////////////////////////////////////////////////////
  // define where to run inside massives above:
  Int_t NMINmM = -1;
  Int_t NMAXmM = -1;
  Int_t NMAXaM = -1;
  Int_t NMINmP = -1;
  Int_t NMAXmP = -1;
  Int_t NMAXaP = -1;
  if (yearcase == 1) {
    //                                           2016 only:                     yearcase=1
    NMINmM = 0;
    NMAXmM = 46;
    NMAXaM = 47;  // M
    NMINmP = 0;
    NMAXmP = 49;
    NMAXaP = 50;  // P
  } else if (yearcase == 2) {
    //                                           2017 only::                    yearcase=2
    //    NMINmM = 47; NMAXmM = 93;  NMAXaM = 47; // M
    //    NMINmP = 50; NMAXmP = 101; NMAXaP = 52; // P
    NMINmM = 53;
    NMAXmM = 93;
    NMAXaM = 41;  // M
    NMINmP = 66;
    NMAXmP = 101;
    NMAXaP = 36;  // P
  } else if (yearcase == 3) {
    //                                           20167 only::                   yearcase=3
    NMINmM = 0;
    NMAXmM = 93;
    NMAXaM = 94;  // M
    NMINmP = 0;
    NMAXmP = 101;
    NMAXaP = 102;  // P
  } else if (yearcase == 4) {
    //                                           2018 only::                    yearcase=4
    //  NMINmM =  94; NMAXmM = 428; NMAXaM =335; // M  428-94+1=335
    //  NMINmM =  94; NMAXmM = 396; NMAXaM =303; // M  396-94+1=303
    NMINmM = 94;
    NMAXmM = 120;
    NMAXaM = 27;  // M  120-94+1=27
    //    NMINmP = 102; NMAXmP = 436; NMAXaP =335; // P  436-102+1=335
    NMINmP = 102;
    NMAXmP = 133;
    NMAXaP = 32;  // P  133-102+1=32
  } else if (yearcase == 5) {
    //                                           20168 only::                   yearcase=5
    NMINmM = 0;
    NMAXmM = -1;
    NMAXaM = -1;  // M
    NMINmP = 0;
    NMAXmP = -1;
    NMAXaP = -1;  // P
  }

  if (NMINmM == -1 || NMAXmM == -1 || NMAXaM == -1 || NMINmP == -1 || NMAXmP == -1 || NMAXaP == -1)
    cout << " STOP  !!!!!!     NMINmM == -1 || NMAXmM == -1 || NMAXaM == -1 ||  NMINmP == -1 || NMAXmP == -1 || NMAXaP "
            "== -1"
         << endl;

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    LOOP over kdirection 0 & 1
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    LOOP over kdirection 0 & 1
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    LOOP over kdirection 0 & 1
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    LOOP over kdirection 0 & 1
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    LOOP over kdirection 0 & 1
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    LOOP over kdirection 0 & 1
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  Int_t NMAX = 0;
  // kdirection:   negative dir M:=0 ;   positive dir P: =1
  for (int kdirection = 0; kdirection < 2; kdirection++) {
    //------------------------------------------------------
    // M:
    if (kdirection == 0) {
      NMAX = NMAXaM;
      //      cout << "NMAX= " << NMAX << "NMINmM= " << NMINmM << "NMAXmM= " << NMAXmM <<endl;
      for (int jjj = NMINmM; jjj <= NMAXmM; jjj++) {
        LASERruns[jjj - NMINmM] = LASERrunsM[jjj];
        X0[jjj - NMINmM] = X0M[jjj];
        //	cout << "jjj= " << jjj << "     jjj-NMINmM= " << jjj-NMINmM << "     LASERrunsM[jjj]= " << LASERrunsM[jjj] << "     X0M[jjj]= " << X0M[jjj] <<endl;
      }
    }
    // P:
    else if (kdirection == 1) {
      NMAX = NMAXaP;
      //      cout << "NMAX= " << NMAX << "NMINmP= " << NMINmP << "NMAXmP= " << NMAXmP <<endl;
      for (int jjj = NMINmP; jjj <= NMAXmP; jjj++) {
        LASERruns[jjj - NMINmP] = LASERrunsP[jjj];
        X0[jjj - NMINmP] = X0P[jjj];
        //	cout << "jjj= " << jjj << "     jjj-NMINmP= " << jjj-NMINmP << "     LASERrunsP[jjj]= " << LASERrunsP[jjj] << "     X0P[jjj]= " << X0P[jjj] <<endl;
      }
    }
    //////////////////////////////////////////////////////
    //========================================================================================================================
    //---------------------------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------------------------
    //     Int_t NP = 3; // for loop over time points(LASER runs) NMAX is number of LASER runs(time abscissa)
    Int_t NP = NMAX;  // for loop over time points(LASER runs) NMAX is number of LASER runs(time abscissa)
    cout << "************************-=============================*************************=======__________++++++++++"
            "=================================================   NP = "
         << NP << endl;
    cout << "***********************++++++++++=================================================   kdirection = "
         << kdirection << endl;
    //
    //---------------------------------------------------------------------------------------------------------------------  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //  ------ flagcutamplitude is  very important flag !!!!!!  :
    //
    //  = 0 Acut    =1 (mean_with_kfactor +  cutMinA)       =2 (mean_with_k2factor*RMS +cutMinA)   <--- all works good; plots are perfect for =2(default now)
    Int_t flagcutamplitude = 0;
    // take into account for future treatment only channels with <Aijk>_runevents within cutMinA to cutMaxA:
    Double_t cutMinA = 10.;
    Double_t cutMaxA = 50000.;
    if (kdirection == 0) {
      cutMinA = 100.;
      cutMaxA = 3600.;
    }  // only for flagcutamplitude=0 !!!!!!!!!!!!!!!!!!!!!!!!!
    //Double_t cutMinA = 70.; Double_t cutMaxA = 3500.;  if(kdirection == 0 ) {cutMinA =100.;cutMaxA = 3600.;} // only for flagcutamplitude=0
    Double_t kfactor = 2.6;   // only for flagcutamplitude=1 and cutMinA applied as well
    Double_t k2factor = 1.5;  // only for flagcutamplitude=2 and cutMinA applied as well

    cout << "!!*********************        flagcutamplitude= " << flagcutamplitude << endl;
    if (flagcutamplitude == 1)
      cout << "   kfactor= " << kfactor << endl;
    if (flagcutamplitude == 2)
      cout << "   k2factor= " << k2factor << endl;
    //
    //
    //    ///    //    //    //    /    //    //    //    //    //    //    //    //
    Double_t cutMinM = 600.;
    if (kdirection == 0)
      cutMinM = 800.;  // mean value in whole run for run selections: to choose/reject whole run
                       //
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //----------------------------------------------------------------------first ratio Aijk/Aijk_ref ----> cut Rijk
    // for flagcutamplitude = 2  :
    Double_t CutrwithphiMin = 0.0;
    Double_t CutrwithphiMax = 6.0;  // P
    if (kdirection == 0) {
      CutrwithphiMin = 0.0;
      CutrwithphiMax = 6.0;
    }  // M
    // for flagcutamplitude = 0 and 1 :
    if (flagcutamplitude < 2) {
      CutrwithphiMin = 0.0;
      CutrwithphiMax = 6.0;  // P
      if (kdirection == 0) {
        CutrwithphiMin = 0.0;
        CutrwithphiMax = 6.0;
      }  // M
    }
    //---------------------------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------------- cut rr
    //  Double_t CutrrwithphiMin = 0.4; Double_t CutrrwithphiMax = 99991.5; // P
    //  if(kdirection == 0 ){CutrrwithphiMin = 0.4; CutrrwithphiMax = 99991.5;} // M
    Double_t CutrrwithphiMin = 0.0;
    Double_t CutrrwithphiMax = 4.0;  // P
    if (kdirection == 0) {
      CutrrwithphiMin = 0.0;
      CutrrwithphiMax = 3.0;
    }  // M
    //---------------------------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------------------------Var2  (cut rr)
    //    Float_t CutrwithphiMinVar2 = 0.4; Float_t CutrwithphiMaxVar2 = 1.4; // P
    //    if(kdirection == 0 ){CutrwithphiMinVar2 = 0.4; CutrwithphiMaxVar2 = 2.0;} // M

    Double_t CutrwithphiMinVar2 = 0.1;
    Double_t CutrwithphiMaxVar2 = 1.5;  // P
    if (kdirection == 0) {
      CutrwithphiMinVar2 = 0.1;
      CutrwithphiMaxVar2 = 1.5;
    }  // M

    //---------------------------------------------------------------------------------------------------------------------
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  flaglumiuse
    //-----------------------------------------------------------------------------------------------------
    for (int kk1 = 0; kk1 < NP; kk1++) {
      XX[kk1] = X0[kk1];
      int k10 = 0;
      int z1 = X0[k10];
      XX[kk1] -= z1;
      XXE[kk1] = 0.001 * XX[kk1];
    }  //XXE - errors at fit
    // use lumi ??? and which one ???:
    // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// flaggaincorrections
    Int_t flaggaincorrections = 0;  // =0 do not use; =1 use corrections
    //  Int_t flaggaincorrections = 1; // =0 do not use; =1 use corrections
    cout << "     !!*********************        flaggaincorrections  = " << flaggaincorrections << endl;
    //----------------------------------------------------------------------------------------------------- for test with test-LU
    //  if(flaglumiuse == 0) {for(int k1 = 0; k1<NP; k1++){ int z1=X0[k1];  XX[k1] = LU[z1];}    }
    //-----------------------------------------------------------------------------------------------------
    if (flaglumiuse == 1) {
      for (int k1 = 0; k1 < NP; k1++) {
        int z1 = X0[k1];
        XX[k1] = LU1[z1];
      }
    }
    //-----------------------------------------------------------------------------------------------------
    if (flaglumiuse == 2) {
      for (int k1 = 0; k1 < NP; k1++) {
        int z1 = X0[k1];
        XX[k1] = LU2[z1];
        int k10 = 0;
        z1 = X0[k10];
        XX[k1] -= LU2[z1];
        //cout << " k1    = " << k1  << " z1    = " << z1  << " XX[k1]    = " << XX[k1]  <<endl;
      }
    }

    //  x(abscissa) for Lumi: re-define x2 (wrt days):
    if (flaglumiuse > 0) {
      if (yearcase == 1)
        x2 = 45.0;
      if (yearcase == 2)
        x2 = 50.0;
      if (yearcase == 3)
        x2 = 95.0;
      if (yearcase == 4)
        x2 = 70.0;
      if (yearcase == 5)
        x2 = 165.0;
    }
    //-----------------------------------------------------------------------------------------------------
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Int_t verbosity =
        0;  //    =0 no printout;                   =9 run selection;                   others >0 - validation tests
    //
    // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 2016 & 2017:
    //
    // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
    // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
    //
    //
    // M:L7 for(int k1 = 0; k1<NP; k1++){for(int iii=2;iii<4;iii++) {for (int jj=0;jj<=13;jj++) {
    // P:L7 for(int k1 = 0; k1<NP; k1++){for(int iii=???...

    // L1: (iii=d1 & eta 17-29);
    // M: int LM1 = 0;if((iii==1 && jj<13)) LM1 = 1;
    // P: int LP1 = 0;if((iii==1 && jj> 0)) LP1 = 1;

    // :L7:  (iii=d2 & eta 17-26) && (iii=d3 & eta 27-28)
    // M: int LM7=0;if((iii==2 && jj>2 && jj<13) || (iii==3 && jj> 0 && jj< 3)) LM7=1;
    // P: int LP7=0;if((iii==2 && jj>0 && jj<11) || (iii==3 && jj>10 && jj<13)) LP7=1;
    //
    // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 2018:
    //
    // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
    // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
    //
    //
    // M:L7 for(int k1 = 0; k1<NP; k1++){for(int iii=2;iii<4;iii++) {for (int jj=0;jj<=13;jj++) {
    // P:L7 for(int k1 = 0; k1<NP; k1++){for(int iii=???...

    // L1: (iii=d2 & eta 17-29);
    // M: int LM1 = 0;if((iii==2 && jj<13)) LM1 = 1;
    // P: int LP1 = 0;if((iii==2 && jj> 0)) LP1 = 1;

    // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
    // M: int LM7=0;if((iii==3 && jj==12) || (iii==4 && jj> 3 && jj<12) || (iii==5 && jj> 0 && jj< 4)) LM7=1;
    // P: int LP7=0;if((iii==3 && jj==1 ) || (iii==4 && jj> 1 && jj<10) || (iii==5 && jj> 9 && jj<13)) LP7=1;
    //

    //========================================================================================== PLOT0:        P   Amplitude -    100 5000
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT1:        M       r vs t for Depth1  and eta 21 22 23 25 27 28 (for tests)
    //========================================================================================== PLOT2:        M       r vs t for Depth1  and eta 17 18 19 20 24 26 29 (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT3:        M       r vs t for Depth2  and eta 21 22 23 25 27 28 (for tests)
    //========================================================================================== PLOT4:        M       r vs t for Depth2  and eta 17 18 19 20 24 26 (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT5:        M       r vs t for L1      and eta 21 22 23 25 27 28
    //========================================================================================== PLOT6:        M       r vs t for L1      and eta 17 18 19 20 24 26 29
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT7:        M       r vs t for L7      and eta 21 22 23 25 27 28
    //========================================================================================== PLOT8:        M       r vs t for L7      and eta 17 18 19 20 24 26 29
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT9:         M Amplitude
    //========================================================================================== PLOT10:        P Amplitude Amplitude -    100 200
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT11:        P       r vs t for Depth1  and eta 21 22 23 25 27 28 (for tests)
    //========================================================================================== PLOT12:        P       r vs t for Depth1  and eta 17 18 19 20 24 26 29 (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT13:        P       r vs t for Depth2  and eta 21 22 23 25 27 28 (for tests)
    //========================================================================================== PLOT14:        P       r vs t for Depth2  and eta 17 18 19 20 24 26 29 (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT15:        P       r vs t for L1      and eta 21 22 23 25 27 28
    //========================================================================================== PLOT16:        P       r vs t for L1      and eta 17 18 19 20 24 26 29
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT17:        P       r vs t for L7      and eta 21 22 23 25 27 28
    //========================================================================================== PLOT18:        P       r vs t for L7      and eta 17 18 19 20 24 26 29
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT19:        M Amplitude
    //========================================================================================== PLOT20:        p Mean amplitude 3 Depthed (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT21:        P       r vs t for Depth3  and eta 27 28 (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT22:        P       Rijk
    //========================================================================================== PLOT23:        all     gains from 2 LED runs
    //========================================================================================== PLOT24:        M       Rijk
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT25:        all     r(Theta) dependence for P & M
    //========================================================================================== PLOT26:        M       RRijkM
    //========================================================================================== PLOT27:        P       RRijkP
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT28:        M Mean Amplitude
    //========================================================================================== PLOT29:        P Mean Amplitude
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT30:        M     r(PHI) dependence  (for tests)
    //========================================================================================== PLOT31:        P     r(PHI) dependence  (for tests)
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT32:        M:  RMS <Aijk>_ev.run for all runs
    //========================================================================================== PLOT33:        P:  RMS <Aijk>_ev.run for all runs
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT34:        LUMI vs days of 2016+2017+2018
    //========================================================================================== PLOT35:        LUMI vs days of 2016
    //========================================================================================== PLOT36:        LUMI vs days of 2017
    //========================================================================================== PLOT37:        LUMI vs days of 2018
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT28:        M RMS Amplitude
    //========================================================================================== PLOT29:        P RMS Amplitude
    //----------------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------- additions  (for tests) after PLOT loop:
    //----------------------------------------------------------------------------------------------------
    //========================================================================================== PLOT100:        M & P     r(PHI) dependence ( PLOT30 & PLOT31 )
    //========================================================================================== PLOT101:        like Rijk M & P (PLOT22 & PLOT24) but w/o bad channels on base RRijk limits
    //----------------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------------
    ///////////////////////////////////////////////////////////////////////// initial nulling:
    for (int iii = 0; iii < DepthMax; iii++) {
      for (int jjj = 0; jjj <= 82; jjj++) {
        mapRADDAM_HED2[iii][jjj] = 0.;
        mapRADDAM_HED20[iii][jjj] = 0.;
        for (int kkk = 0; kkk <= 72; kkk++) {
          mapRADDAM_HE[iii][jjj][kkk] = 0.;
          normM[iii][jjj][kkk] = 0.;
          normP[iii][jjj][kkk] = 0.;
          gainRADDAM_HE[iii][jjj][kkk] = 0.;
        }
      }
    }
    /////////////////////////////////////////////////////////////////////////
    //______________________________________________________________________________ gain corrections:
    TH1F *gainkoeff = new TH1F("gainkoeff", "", 100, 0.5, 1.5);
    //TH1F* gainkoeff = new TH1F("gainkoeff","", 100, 0.8,1.2);
    //__________________________________________________________________________________________________________________________________________ gain corrections:
    // 2016: 272847(09.05) - 285349(15.11)   (time range: 187 days)     yearcase=1
    // 2017: 294054(15.05) - 306249(07.11)   (time range: 176 days)     yearcase=2
    // 2016: 272847(09.05) - 306249(07.11)   (time range: 548 days)     yearcase=3

    TFile *hfile1 =
        new TFile("/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_272847.root",
                  "READ");  // 2016-05-09
    TFile *hfile2 =
        new TFile("/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_306249.root",
                  "READ");  //2017-11-07
    TFile *hfile3 =
        new TFile("/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_272847.root",
                  "READ");  // 2016-05-09
    TFile *hfile4 =
        new TFile("/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_285349.root",
                  "READ");  //2016-11-15
    TFile *hfile5 =
        new TFile("/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_294054.root",
                  "READ");  // 2017-05-26
    TFile *hfile6 =
        new TFile("/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_306249.root",
                  "READ");  //2017-11-07

    // ref.runs1:   key letter is wo
    TH2F *xwod1 = (TH2F *)hfile1->Get("h_mapDepth1ADCAmpl12_HE");
    TH2F *xwod2 = (TH2F *)hfile1->Get("h_mapDepth2ADCAmpl12_HE");
    TH2F *xwod3 = (TH2F *)hfile1->Get("h_mapDepth3ADCAmpl12_HE");
    TH2F *xwo10 = (TH2F *)hfile1->Get("h_mapDepth1_HE");
    TH2F *xwo20 = (TH2F *)hfile1->Get("h_mapDepth2_HE");
    TH2F *xwo30 = (TH2F *)hfile1->Get("h_mapDepth3_HE");
    TH2F *Xwof1 = (TH2F *)xwod1->Clone("Xwof1");
    TH2F *Xwof2 = (TH2F *)xwod2->Clone("Xwof2");
    TH2F *Xwof3 = (TH2F *)xwod3->Clone("Xwof3");
    Xwof1->Divide(xwod1, xwo10, 1, 1, "B");
    Xwof2->Divide(xwod2, xwo20, 1, 1, "B");
    Xwof3->Divide(xwod3, xwo30, 1, 1, "B");
    // last.run1:   key letter is wo
    TH2F *ywod1 = (TH2F *)hfile2->Get("h_mapDepth1ADCAmpl12_HE");
    TH2F *ywod2 = (TH2F *)hfile2->Get("h_mapDepth2ADCAmpl12_HE");
    TH2F *ywod3 = (TH2F *)hfile2->Get("h_mapDepth3ADCAmpl12_HE");
    TH2F *ywo10 = (TH2F *)hfile2->Get("h_mapDepth1_HE");
    TH2F *ywo20 = (TH2F *)hfile2->Get("h_mapDepth2_HE");
    TH2F *ywo30 = (TH2F *)hfile2->Get("h_mapDepth3_HE");
    TH2F *Ywof1 = (TH2F *)ywod1->Clone("Ywof1");
    TH2F *Ywof2 = (TH2F *)ywod2->Clone("Ywof2");
    TH2F *Ywof3 = (TH2F *)ywod3->Clone("Ywof3");
    Ywof1->Divide(ywod1, ywo10, 1, 1, "B");
    Ywof2->Divide(ywod2, ywo20, 1, 1, "B");
    Ywof3->Divide(ywod3, ywo30, 1, 1, "B");
    ////
    // ref.runs2:   key letter is yo
    TH2F *xyod1 = (TH2F *)hfile3->Get("h_mapDepth1ADCAmpl12_HE");
    TH2F *xyod2 = (TH2F *)hfile3->Get("h_mapDepth2ADCAmpl12_HE");
    TH2F *xyod3 = (TH2F *)hfile3->Get("h_mapDepth3ADCAmpl12_HE");
    TH2F *xyo10 = (TH2F *)hfile3->Get("h_mapDepth1_HE");
    TH2F *xyo20 = (TH2F *)hfile3->Get("h_mapDepth2_HE");
    TH2F *xyo30 = (TH2F *)hfile3->Get("h_mapDepth3_HE");
    TH2F *Xyof1 = (TH2F *)xyod1->Clone("Xyof1");
    TH2F *Xyof2 = (TH2F *)xyod2->Clone("Xyof2");
    TH2F *Xyof3 = (TH2F *)xyod3->Clone("Xyof3");
    Xyof1->Divide(xyod1, xyo10, 1, 1, "B");
    Xyof2->Divide(xyod2, xyo20, 1, 1, "B");
    Xyof3->Divide(xyod3, xyo30, 1, 1, "B");
    // last.run2:   key letter is yo
    TH2F *yyod1 = (TH2F *)hfile4->Get("h_mapDepth1ADCAmpl12_HE");
    TH2F *yyod2 = (TH2F *)hfile4->Get("h_mapDepth2ADCAmpl12_HE");
    TH2F *yyod3 = (TH2F *)hfile4->Get("h_mapDepth3ADCAmpl12_HE");
    TH2F *yyo10 = (TH2F *)hfile4->Get("h_mapDepth1_HE");
    TH2F *yyo20 = (TH2F *)hfile4->Get("h_mapDepth2_HE");
    TH2F *yyo30 = (TH2F *)hfile4->Get("h_mapDepth3_HE");
    TH2F *Yyof1 = (TH2F *)yyod1->Clone("Yyof1");
    TH2F *Yyof2 = (TH2F *)yyod2->Clone("Yyof2");
    TH2F *Yyof3 = (TH2F *)yyod3->Clone("Yyof3");
    Yyof1->Divide(yyod1, yyo10, 1, 1, "B");
    Yyof2->Divide(yyod2, yyo20, 1, 1, "B");
    Yyof3->Divide(yyod3, yyo30, 1, 1, "B");
    ////
    // ref.runs3:   key letter is zo
    TH2F *xzod1 = (TH2F *)hfile5->Get("h_mapDepth1ADCAmpl12_HE");
    TH2F *xzod2 = (TH2F *)hfile5->Get("h_mapDepth2ADCAmpl12_HE");
    TH2F *xzod3 = (TH2F *)hfile5->Get("h_mapDepth3ADCAmpl12_HE");
    TH2F *xzo10 = (TH2F *)hfile5->Get("h_mapDepth1_HE");
    TH2F *xzo20 = (TH2F *)hfile5->Get("h_mapDepth2_HE");
    TH2F *xzo30 = (TH2F *)hfile5->Get("h_mapDepth3_HE");
    TH2F *Xzof1 = (TH2F *)xzod1->Clone("Xzof1");
    TH2F *Xzof2 = (TH2F *)xzod2->Clone("Xzof2");
    TH2F *Xzof3 = (TH2F *)xzod3->Clone("Xzof3");
    Xzof1->Divide(xzod1, xzo10, 1, 1, "B");
    Xzof2->Divide(xzod2, xzo20, 1, 1, "B");
    Xzof3->Divide(xzod3, xzo30, 1, 1, "B");
    // last.run3:   key letter is zo
    TH2F *yzod1 = (TH2F *)hfile6->Get("h_mapDepth1ADCAmpl12_HE");
    TH2F *yzod2 = (TH2F *)hfile6->Get("h_mapDepth2ADCAmpl12_HE");
    TH2F *yzod3 = (TH2F *)hfile6->Get("h_mapDepth3ADCAmpl12_HE");
    TH2F *yzo10 = (TH2F *)hfile6->Get("h_mapDepth1_HE");
    TH2F *yzo20 = (TH2F *)hfile6->Get("h_mapDepth2_HE");
    TH2F *yzo30 = (TH2F *)hfile6->Get("h_mapDepth3_HE");
    TH2F *Yzof1 = (TH2F *)yzod1->Clone("Yzof1");
    TH2F *Yzof2 = (TH2F *)yzod2->Clone("Yzof2");
    TH2F *Yzof3 = (TH2F *)yzod3->Clone("Yzof3");
    Yzof1->Divide(yzod1, yzo10, 1, 1, "B");
    Yzof2->Divide(yzod2, yzo20, 1, 1, "B");
    Yzof3->Divide(yzod3, yzo30, 1, 1, "B");
    ////

    // fill massive <Aijk>_runevents ,  where iii=depth, jjj=eta, kkk=phi
    // use wo
    int gx = Xwof1->GetXaxis()->GetNbins();
    int gy = Xwof1->GetYaxis()->GetNbins();
    for (int jjj = 0; jjj < gx; jjj++) {
      for (int kkk = 0; kkk < gy; kkk++) {
        if (Xwof1->GetBinContent(jjj, kkk) != 0.) {
          gainRADDAM_HE[1][jjj][kkk + 1] = (Ywof1->GetBinContent(jjj, kkk) / Xwof1->GetBinContent(jjj, kkk));
        }
        if (Xwof2->GetBinContent(jjj, kkk) != 0.) {
          gainRADDAM_HE[2][jjj][kkk + 1] = (Ywof2->GetBinContent(jjj, kkk) / Xwof2->GetBinContent(jjj, kkk));
        }
        if (Xwof3->GetBinContent(jjj, kkk) != 0.) {
          gainRADDAM_HE[3][jjj][kkk + 1] = (Ywof3->GetBinContent(jjj, kkk) / Xwof3->GetBinContent(jjj, kkk));
        }
      }
    }
    // use yo
    for (int jjj = 0; jjj < gx; jjj++) {
      for (int kkk = 0; kkk < gy; kkk++) {
        if (Xyof1->GetBinContent(jjj, kkk) != 0. &&
            fabs((Yyof1->GetBinContent(jjj, kkk) / Xyof1->GetBinContent(jjj, kkk)) - 1.) <
                fabs(gainRADDAM_HE[1][jjj][kkk + 1] - 1.)) {
          gainRADDAM_HE[1][jjj][kkk + 1] = (Yyof1->GetBinContent(jjj, kkk) / Xyof1->GetBinContent(jjj, kkk));
        }
        if (Xyof2->GetBinContent(jjj, kkk) != 0. &&
            fabs((Yyof2->GetBinContent(jjj, kkk) / Xyof2->GetBinContent(jjj, kkk)) - 1.) <
                fabs(gainRADDAM_HE[1][jjj][kkk + 1] - 1.)) {
          gainRADDAM_HE[2][jjj][kkk + 1] = (Yyof2->GetBinContent(jjj, kkk) / Xyof2->GetBinContent(jjj, kkk));
        }
        if (Xyof3->GetBinContent(jjj, kkk) != 0. &&
            fabs((Yyof3->GetBinContent(jjj, kkk) / Xyof3->GetBinContent(jjj, kkk)) - 1.) <
                fabs(gainRADDAM_HE[1][jjj][kkk + 1] - 1.)) {
          gainRADDAM_HE[3][jjj][kkk + 1] = (Yyof3->GetBinContent(jjj, kkk) / Xyof3->GetBinContent(jjj, kkk));
        }
      }
    }
    // use zo
    for (int jjj = 0; jjj < gx; jjj++) {
      for (int kkk = 0; kkk < gy; kkk++) {
        if (Xzof1->GetBinContent(jjj, kkk) != 0. &&
            fabs((Yzof1->GetBinContent(jjj, kkk) / Xzof1->GetBinContent(jjj, kkk)) - 1.) <
                fabs(gainRADDAM_HE[1][jjj][kkk + 1] - 1.)) {
          gainRADDAM_HE[1][jjj][kkk + 1] = (Yzof1->GetBinContent(jjj, kkk) / Xzof1->GetBinContent(jjj, kkk));
        }
        if (Xzof2->GetBinContent(jjj, kkk) != 0. &&
            fabs((Yzof2->GetBinContent(jjj, kkk) / Xzof2->GetBinContent(jjj, kkk)) - 1.) <
                fabs(gainRADDAM_HE[1][jjj][kkk + 1] - 1.)) {
          gainRADDAM_HE[2][jjj][kkk + 1] = (Yzof2->GetBinContent(jjj, kkk) / Xzof2->GetBinContent(jjj, kkk));
        }
        if (Xzof3->GetBinContent(jjj, kkk) != 0. &&
            fabs((Yzof3->GetBinContent(jjj, kkk) / Xzof3->GetBinContent(jjj, kkk)) - 1.) <
                fabs(gainRADDAM_HE[1][jjj][kkk + 1] - 1.)) {
          gainRADDAM_HE[3][jjj][kkk + 1] = (Yzof3->GetBinContent(jjj, kkk) / Xzof3->GetBinContent(jjj, kkk));
        }
      }
    }

    /////////////////////////////////////////////////////////////////
    // fill massive gainkoeff ,  where iii=depth, jjj=eta, kkk=phi
    for (int iii = 1; iii < DepthMax; iii++) {
      for (int jjj = 1; jjj <= 82; jjj++) {
        for (int kkk = 1; kkk <= 72; kkk++) {
          if (fabs(gainRADDAM_HE[iii][jjj][kkk] - 1.) > 0.5)
            gainRADDAM_HE[iii][jjj][kkk] = 1.;
          if (flaggaincorrections == 0)
            gainRADDAM_HE[iii][jjj][kkk] = 1.;
          gainkoeff->Fill(gainRADDAM_HE[iii][jjj][kkk]);
        }  //for kkk
      }    // for jjj
    }      // for iii

    /*
  for(int iii = 1; iii<4; iii++) {
    for (int jjj=1;jjj<=82;jjj++) {
      for (int kkk=1;kkk<=72;kkk++) {
	if(gainRADDAM_HE[iii][jjj][kkk] !=0.) {
	  gainkoeff->Fill(gainRADDAM_HE[iii][jjj][kkk]);
	  if(flaggaincorrections == 0) gainRADDAM_HE[iii][jjj][kkk] = 1.;
	}
      }
    }
  }
*/
    //______________________________________________________________________________
    //     ls -latr /afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LASER_* | less
    TString fname = "/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LASER_";
    //  TString fname = "/afs/cern.ch/cms/CAF/CMSALCA/ALCA_HCALCALIB/HCALMONITORING/RDMweb/histos/LED_";

    // booking:
    TH1F *Ceff1D = new TH1F("Ceff1D", "", 200, 0., 5000.);
    TH1F *Seff1D = new TH1F("Seff1D", "", 200, 0., 1000.);
    TH1F *Ceff1M = new TH1F("Ceff1M", "", 200, 0., 1300.);
    TH1F *Ceff1R = new TH1F("Ceff1R", "", 100, 0., 1000.);

    TH1F *Meff1D = new TH1F("Meff1D", "", 100, 0., 4000.);
    TH1F *Meff2D = new TH1F("Meff2D", "", 100, 0., 4000.);
    TH1F *Meff3D = new TH1F("Meff3D", "", 100, 0., 4000.);
    TH1F *Meff4D = new TH1F("Meff4D", "", 100, 0., 4000.);
    TH1F *Meff5D = new TH1F("Meff5D", "", 100, 0., 4000.);
    TH1F *Meff6D = new TH1F("Meff6D", "", 100, 0., 4000.);
    TH1F *Meff7D = new TH1F("Meff7D", "", 100, 0., 4000.);

    //    TH1F* rwithphi = new TH1F("rwithphi","", 1000, -1.,2449.);
    //    TH1F* rwithphi = new TH1F("rwithphi","", 100, -1.,1449.);
    //    TH1F* rwithphi = new TH1F("rwithphi","", 100, -1.,449.);
    //    TH1F* rwithphi = new TH1F("rwithphi","", 100, -1.,149.);
    TH1F *rwithphi = new TH1F("rwithphi", "", 100, -1., 9.);
    //      TH1F* rwithphi = new TH1F("rwithphi","", 100, -1.,5.);

    TH1F *rrwithphiM = new TH1F("rrwithphiM", "", 100, -1., 4.);
    TH1F *rrwithphiP = new TH1F("rrwithphiP", "", 100, -1., 4.);

    Int_t kmm = 0;
    Int_t kpp = 0;
    //    first runs:
    Int_t mk1f = 0;
    Int_t pk1f = 0;
    //

    //////////////////////////////////////////////////////////////////////////  LOOP    raddam current
    //////////////////////////////////////////////////////////////////////////  LOOP    raddam current
    //////////////////////////////////////////////////////////////////////////////////////////////  LOOP    raddam current !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  MAIN LOOP !!!!!!!
    //////////////////////////////////////////////////////////////////////////  LOOP    raddam current
    //////////////////////////////////////////////////////////////////////////  LOOP    raddam current
    Int_t RUN3 = 0;
    Dref = 3;
    DepthMax = 4;
    for (int k1 = 0; k1 < NP; k1++) {
      //  if(k1==0 || (k1 >37 && k1<42)) {

      //______________________________________________________
      TString epsName = fname + LASERruns[k1] + ".root";
      TFile *hfile = new TFile(epsName, "READ");
      //  	TFile *hfile= new TFile("LASER_226835.root", "READ");
      //	TFile *hfile= new TFile("LASER_272957.root", "READ");
      if (LASERruns[k1] > "305874")
        RUN3 = 1;
      // Define nominator denominator for some methods:
      //---------------------------------------------------
      // 000000000000000000000000000000000000000000000000000000000000000000000000
      //      TH2F *twod1= (TH2F*)hfile->Get("h_mapDepth1ADCAmpl_HE");
      //      TH2F *twod2= (TH2F*)hfile->Get("h_mapDepth2ADCAmpl_HE");
      //      TH2F *twod3= (TH2F*)hfile->Get("h_mapDepth3ADCAmpl_HE");
      // 111111111111111111111111111111111111111111111111111111111111111111111111
      // h_mapDepth1ADCAmpl12_HE means ADCcounts(massive) within -1 max +1 +2

      TH2F *twod1 = (TH2F *)hfile->Get("h_mapDepth1ADCAmpl12_HE");
      TH2F *twod2 = (TH2F *)hfile->Get("h_mapDepth2ADCAmpl12_HE");
      TH2F *twod3 = (TH2F *)hfile->Get("h_mapDepth3ADCAmpl12_HE");
      TH2F *twod4 = (TH2F *)hfile->Get("h_mapDepth4ADCAmpl12_HE");
      TH2F *twod5 = (TH2F *)hfile->Get("h_mapDepth5ADCAmpl12_HE");
      TH2F *twod6 = (TH2F *)hfile->Get("h_mapDepth6ADCAmpl12_HE");
      TH2F *twod7 = (TH2F *)hfile->Get("h_mapDepth7ADCAmpl12_HE");

      TH2F *t0010 = (TH2F *)hfile->Get("h_mapDepth1_HE");
      TH2F *t0020 = (TH2F *)hfile->Get("h_mapDepth2_HE");
      TH2F *t0030 = (TH2F *)hfile->Get("h_mapDepth3_HE");
      TH2F *t0040 = (TH2F *)hfile->Get("h_mapDepth4_HE");
      TH2F *t0050 = (TH2F *)hfile->Get("h_mapDepth5_HE");
      TH2F *t0060 = (TH2F *)hfile->Get("h_mapDepth6_HE");
      TH2F *t0070 = (TH2F *)hfile->Get("h_mapDepth7_HE");
      if (RUN3 = 1) {
        Dref = 4;
        DepthMax = 8;
      }
      //	  	  cout << "!!!! read LASER run with k1= " << k1   <<"  run:  " << LASERruns[k1] << "  Dref= " << Dref   <<"  DepthMax:  " << DepthMax <<endl;

      //
      // 222222222222222222222222222222222222222222222222222222222222222222222222
      //  h_mapDepth1linADCAmpl12_HE means ADCcounts(linearized) within -1 max +1 +2
      /*
      TH2F *twod1= (TH2F*)hfile->Get("h_mapDepth1linADCAmpl12_HE");
      TH2F *twod2= (TH2F*)hfile->Get("h_mapDepth2linADCAmpl12_HE");
      TH2F *twod3= (TH2F*)hfile->Get("h_mapDepth3linADCAmpl12_HE");
      TH2F *t0010= (TH2F*)hfile->Get("h_mapDepth1_HE");
      TH2F *t0020= (TH2F*)hfile->Get("h_mapDepth2_HE");
      TH2F *t0030= (TH2F*)hfile->Get("h_mapDepth3_HE");
*/
      //
      /*
    // 3333333333333333333333333333333333333333333333333333333333333333333333
     // h_mapDepth1RADDAM_HE means ADCcounts(massive) within -1 max +1 +2
      // pedestal subtracted and cut(50 adcCounts) for each digi:
      TH2F *twod1= (TH2F*)hfile->Get("h_mapDepth1RADDAM_HE");
      TH2F *twod2= (TH2F*)hfile->Get("h_mapDepth2RADDAM_HE");
      TH2F *twod3= (TH2F*)hfile->Get("h_mapDepth3RADDAM_HE");
      TH2F *t0010= (TH2F*)hfile->Get("h_mapDepth1RADDAM0_HE");
      TH2F *t0020= (TH2F*)hfile->Get("h_mapDepth2RADDAM0_HE");
      TH2F *t0030= (TH2F*)hfile->Get("h_mapDepth3RADDAM0_HE");

    */
      //
      //
      // Divide  Divide  Divide  Divide  Divide  Divide  Divide  Divide:
      // for raddam get <Aijk>_runevents
      //
      //	if(t0010->IsA()->InheritsFrom("TH2F")) {
      TH2F *Ceff1 = (TH2F *)twod1->Clone("Ceff1");
      TH2F *Ceff2 = (TH2F *)twod2->Clone("Ceff2");
      TH2F *Ceff3 = (TH2F *)twod3->Clone("Ceff3");
      TH2F *Ceff4 = (TH2F *)twod4->Clone("Ceff4");
      TH2F *Ceff5 = (TH2F *)twod5->Clone("Ceff5");
      TH2F *Ceff6 = (TH2F *)twod6->Clone("Ceff6");
      TH2F *Ceff7 = (TH2F *)twod7->Clone("Ceff7");

      //    twod1->Sumw2();
      //    twod2->Sumw2();
      //    twod3->Sumw2();
      //    t0010->Sumw2();

      // <Aijk>_runevents:
      // kscale =200 for 2018 to have a'la the same A-scale as for HPD(<2018). So, a'la: adcCounts = fC/kscale;
      int kscale = 1;
      if (RUN3 == 1)
        kscale = 200;
      Ceff1->Divide(twod1, t0010, 1, kscale, "B");
      Ceff2->Divide(twod2, t0020, 1, kscale, "B");
      Ceff3->Divide(twod3, t0030, 1, kscale, "B");
      Ceff4->Divide(twod4, t0040, 1, kscale, "B");
      Ceff5->Divide(twod5, t0050, 1, kscale, "B");
      Ceff6->Divide(twod6, t0060, 1, kscale, "B");
      Ceff7->Divide(twod7, t0070, 1, kscale, "B");
      //      Ceff1->Sumw2();Ceff2->Sumw2();Ceff3->Sumw2();
      //	}

      int nx = Ceff1->GetXaxis()->GetNbins();
      int ny = Ceff1->GetYaxis()->GetNbins();
      // print for verbosity:
      if (verbosity == 2) {
        cout << "************* nx = " << nx << " ny = " << ny << endl;
        for (int jjj = 0; jjj <= nx; jjj++) {
          for (int kkk = 0; kkk <= ny; kkk++) {
            if (Ceff1->GetBinContent(jjj, kkk) != 0.)
              cout << "*111111************ jjj = " << jjj << "************* kkk = " << kkk << endl;
            if (Ceff2->GetBinContent(jjj, kkk) != 0.)
              cout << "*******222****** jjj = " << jjj << "************* kkk = " << kkk << endl;
            if (Ceff3->GetBinContent(jjj, kkk) != 0.)
              cout << "**********3*** jjj = " << jjj << "************* kkk = " << kkk << endl;
            if (Ceff4->GetBinContent(jjj, kkk) != 0.)
              cout << "*144444************ jjj = " << jjj << "************* kkk = " << kkk << endl;
            if (Ceff5->GetBinContent(jjj, kkk) != 0.)
              cout << "*******555****** jjj = " << jjj << "************* kkk = " << kkk << endl;
            if (Ceff6->GetBinContent(jjj, kkk) != 0.)
              cout << "**********6*** jjj = " << jjj << "************* kkk = " << kkk << endl;
            if (Ceff7->GetBinContent(jjj, kkk) != 0.)
              cout << "**********7*** jjj = " << jjj << "************* kkk = " << kkk << endl;
          }  //jjj
        }    //kkk
      }      // if(verbosity == 2 )
      //////////////////////////////////////////////////////////////////////////////////   see raddam done
      ////////////////////////////////////////////////////////////////////////////////////// FILLING for future PLOTTING:
      // fill massive <Aijk>_runevents ,  where iii=depth, jjj=eta, kkk=phi
      for (int jjj = 0; jjj < nx; jjj++) {
        for (int kkk = 0; kkk < ny; kkk++) {
          // FILL NEW PLOTS:
          // Aijk: Ceff1D & Seff1D plots
          if (Ceff1->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff1->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff1->GetBinContent(jjj, kkk));
          }
          if (Ceff2->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff2->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff2->GetBinContent(jjj, kkk));
          }
          if (Ceff3->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff3->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff3->GetBinContent(jjj, kkk));
          }
          if (Ceff4->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff4->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff4->GetBinContent(jjj, kkk));
          }
          if (Ceff5->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff5->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff5->GetBinContent(jjj, kkk));
          }
          if (Ceff6->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff6->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff6->GetBinContent(jjj, kkk));
          }
          if (Ceff7->GetBinContent(jjj, kkk) != 0.) {
            Ceff1D->Fill(Ceff7->GetBinContent(jjj, kkk));
            Seff1D->Fill(Ceff7->GetBinContent(jjj, kkk));
          }
          // to get correct mean w/o channels without signal
          if (Ceff1->GetBinContent(jjj, kkk) > cutMinA) {
            Meff1D->Fill(Ceff1->GetBinContent(jjj, kkk));
          }
          if (Ceff2->GetBinContent(jjj, kkk) > cutMinA) {
            Meff2D->Fill(Ceff2->GetBinContent(jjj, kkk));
          }
          if (Ceff3->GetBinContent(jjj, kkk) > cutMinA) {
            Meff3D->Fill(Ceff3->GetBinContent(jjj, kkk));
          }
          if (Ceff4->GetBinContent(jjj, kkk) > cutMinA) {
            Meff4D->Fill(Ceff4->GetBinContent(jjj, kkk));
          }
          if (Ceff5->GetBinContent(jjj, kkk) > cutMinA) {
            Meff5D->Fill(Ceff5->GetBinContent(jjj, kkk));
          }
          if (Ceff6->GetBinContent(jjj, kkk) > cutMinA) {
            Meff6D->Fill(Ceff6->GetBinContent(jjj, kkk));
          }
          if (Ceff7->GetBinContent(jjj, kkk) > cutMinA) {
            Meff7D->Fill(Ceff7->GetBinContent(jjj, kkk));
          }
        }
      }
      //--------------------------------------
      Ceff1M->Fill(Meff1D->GetMean());
      Ceff1M->Fill(Meff2D->GetMean());
      Ceff1M->Fill(Meff3D->GetMean());
      Ceff1M->Fill(Meff4D->GetMean());
      Ceff1M->Fill(Meff5D->GetMean());
      Ceff1M->Fill(Meff6D->GetMean());
      Ceff1M->Fill(Meff7D->GetMean());
      //cout<<" kdirection = " << kdirection <<"!!!!!!!  run out Mean = " << k1 <<"   Meff1D->GetMean() = " << Meff1D->GetMean() <<endl;
      if (verbosity == 9 && (Meff1D->GetMean() < cutMinM || Meff2D->GetMean() < cutMinM || Meff3D->GetMean() < cutMinM))
        cout << " kdirection = " << kdirection << "******  run out Mean = " << k1
             << "   Meff1D->GetMean() = " << Meff1D->GetMean() << "   cutMinM = " << cutMinM << endl;
      Ceff1R->Fill(Meff1D->GetRMS());
      Ceff1R->Fill(Meff2D->GetRMS());
      Ceff1R->Fill(Meff3D->GetRMS());
      Ceff1R->Fill(Meff4D->GetRMS());
      Ceff1R->Fill(Meff5D->GetRMS());
      Ceff1R->Fill(Meff6D->GetRMS());
      Ceff1R->Fill(Meff7D->GetRMS());
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      // take into account for future treatment only channels with <Aijk>_runevents within cutMinA to cutMaxA: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // apply cut on <Aijk>_runevents
      //             -41                                +41
      //                            82 bins
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  APPLY cutS !!!!! AND FILL MASSIV !!!!!!
      //--------------------------------------
      //--------------------------------------
      if (flagcutamplitude == 0) {
        for (int jjj = 0; jjj < nx; jjj++) {
          for (int kkk = 0; kkk < ny; kkk++) {
            if (Ceff1->GetBinContent(jjj, kkk) > cutMinA && Ceff1->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[1][jjj][kkk + 1] = Ceff1->GetBinContent(jjj, kkk);
            if (Ceff2->GetBinContent(jjj, kkk) > cutMinA && Ceff2->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[2][jjj][kkk + 1] = Ceff2->GetBinContent(jjj, kkk);
            if (Ceff3->GetBinContent(jjj, kkk) > cutMinA && Ceff3->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[3][jjj][kkk + 1] = Ceff3->GetBinContent(jjj, kkk);
            if (Ceff4->GetBinContent(jjj, kkk) > cutMinA && Ceff4->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[4][jjj][kkk + 1] = Ceff4->GetBinContent(jjj, kkk);
            if (Ceff5->GetBinContent(jjj, kkk) > cutMinA && Ceff5->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[5][jjj][kkk + 1] = Ceff5->GetBinContent(jjj, kkk);
            if (Ceff6->GetBinContent(jjj, kkk) > cutMinA && Ceff6->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[6][jjj][kkk + 1] = Ceff6->GetBinContent(jjj, kkk);
            if (Ceff7->GetBinContent(jjj, kkk) > cutMinA && Ceff7->GetBinContent(jjj, kkk) < cutMaxA)
              mapRADDAM_HE[7][jjj][kkk + 1] = Ceff7->GetBinContent(jjj, kkk);
          }
        }
      }  // if
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      //--------------------------------------
      else if (flagcutamplitude == 1) {
        for (int jjj = 0; jjj < nx; jjj++) {
          for (int kkk = 0; kkk < ny; kkk++) {
            if (Ceff1->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff1->GetBinContent(jjj, kkk) < kfactor * Meff1D->GetMean())
              mapRADDAM_HE[1][jjj][kkk + 1] = Ceff1->GetBinContent(jjj, kkk);
            if (Ceff2->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff2->GetBinContent(jjj, kkk) < kfactor * Meff2D->GetMean())
              mapRADDAM_HE[2][jjj][kkk + 1] = Ceff2->GetBinContent(jjj, kkk);
            if (Ceff3->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff3->GetBinContent(jjj, kkk) < kfactor * Meff3D->GetMean())
              mapRADDAM_HE[3][jjj][kkk + 1] = Ceff3->GetBinContent(jjj, kkk);
            if (Ceff4->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff4->GetBinContent(jjj, kkk) < kfactor * Meff1D->GetMean())
              mapRADDAM_HE[4][jjj][kkk + 1] = Ceff4->GetBinContent(jjj, kkk);
            if (Ceff5->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff5->GetBinContent(jjj, kkk) < kfactor * Meff2D->GetMean())
              mapRADDAM_HE[5][jjj][kkk + 1] = Ceff5->GetBinContent(jjj, kkk);
            if (Ceff6->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff6->GetBinContent(jjj, kkk) < kfactor * Meff3D->GetMean())
              mapRADDAM_HE[6][jjj][kkk + 1] = Ceff6->GetBinContent(jjj, kkk);
            if (Ceff7->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff7->GetBinContent(jjj, kkk) < kfactor * Meff3D->GetMean())
              mapRADDAM_HE[7][jjj][kkk + 1] = Ceff7->GetBinContent(jjj, kkk);
          }
        }
      }  // if
      else if (flagcutamplitude == 2) {
        for (int jjj = 0; jjj < nx; jjj++) {
          for (int kkk = 0; kkk < ny; kkk++) {
            if (Ceff1->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff1->GetBinContent(jjj, kkk) < (Meff1D->GetMean() + k2factor * Meff1D->GetRMS()))
              mapRADDAM_HE[1][jjj][kkk + 1] = Ceff1->GetBinContent(jjj, kkk);
            if (Ceff2->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff2->GetBinContent(jjj, kkk) < (Meff2D->GetMean() + k2factor * Meff2D->GetRMS()))
              mapRADDAM_HE[2][jjj][kkk + 1] = Ceff2->GetBinContent(jjj, kkk);
            if (Ceff3->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff3->GetBinContent(jjj, kkk) < (Meff3D->GetMean() + k2factor * Meff3D->GetRMS()))
              mapRADDAM_HE[3][jjj][kkk + 1] = Ceff3->GetBinContent(jjj, kkk);
            if (Ceff4->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff4->GetBinContent(jjj, kkk) < (Meff4D->GetMean() + k2factor * Meff4D->GetRMS()))
              mapRADDAM_HE[4][jjj][kkk + 1] = Ceff4->GetBinContent(jjj, kkk);
            if (Ceff5->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff5->GetBinContent(jjj, kkk) < (Meff5D->GetMean() + k2factor * Meff5D->GetRMS()))
              mapRADDAM_HE[5][jjj][kkk + 1] = Ceff5->GetBinContent(jjj, kkk);
            if (Ceff6->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff6->GetBinContent(jjj, kkk) < (Meff6D->GetMean() + k2factor * Meff6D->GetRMS()))
              mapRADDAM_HE[6][jjj][kkk + 1] = Ceff6->GetBinContent(jjj, kkk);
            if (Ceff7->GetBinContent(jjj, kkk) > cutMinA &&
                Ceff7->GetBinContent(jjj, kkk) < (Meff7D->GetMean() + k2factor * Meff7D->GetRMS()))
              mapRADDAM_HE[7][jjj][kkk + 1] = Ceff7->GetBinContent(jjj, kkk);
          }
        }
      }  // if
      //////////////////---------------------------------------
      ///////////////////////////////////////////////////////////////// nulling: either M for positive direction, or P for negative direction, just in case
      for (int iii = 1; iii < DepthMax; iii++) {
        for (int jjj = 1; jjj <= 82; jjj++) {
          if ((kdirection == 0 && jjj > 41) || (kdirection == 1 && jjj < 42)) {
            for (int kkk = 1; kkk <= 72; kkk++) {
              mapRADDAM_HE[iii][jjj][kkk] = 0.;
            }
          }
        }
      }
      //////////////////---------------------------------------
      ///////////////////////////////////////////////////////////////// nulling for known bad channels of known runs:
      if (k1 > 36 && k1 < 45) {
        for (int iii = 1; iii < DepthMax; iii++) {
          for (int jjj = 1; jjj <= 82; jjj++) {
            for (int kkk = 1; kkk <= 72; kkk++) {
              if ((iii == 1) &&
                  (jjj == 59 || jjj == 60 || jjj == 63 || jjj == 65 || jjj == 66 || jjj == 67 || jjj == 68) &&
                  (kkk == 23 || kkk == 24)) {
                mapRADDAM_HE[iii][jjj][kkk] = 0.;
              }
            }
          }
        }
      }
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////////--------------------------------------------------------------------- gain corrections:
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      for (int iii = 1; iii < DepthMax; iii++) {
        for (int jjj = 1; jjj <= 82; jjj++) {
          for (int kkk = 1; kkk <= 72; kkk++) {
            if (mapRADDAM_HE[iii][jjj][kkk] != 0 && gainRADDAM_HE[iii][jjj][kkk] != 0)
              mapRADDAM_HE[iii][jjj][kkk] /= gainRADDAM_HE[iii][jjj][kkk];
          }
        }
      }
      //////////////////---------------------------------------
      //                                                 define A for refRun    Laser-megatile:           HEM : 272967 = k1=[0] ,                     HEP : 272957 = k1=[0],   20167
      //                                                 define A for refRun    Laser-megatile:           HEM : 315056 = k1=[0] ,                     HEP : 315056 = k1=[0],   2018
      //////////////////---------------------------------------

      if (k1 == mk1f && kmm == 0 && kdirection == 0) {
        kmm = 1;  //Int_t mcount=0;
        cout << "* to be printed once only  CHECK IT please  ************ kmm = " << kmm << endl;
        cout << "NEGATIVE direction refRun !!!! read LASER run with k1= " << k1 << "  run:  " << LASERruns[k1] << endl;
        for (int iii = 1; iii < DepthMax; iii++) {
          for (int jjj = 1; jjj <= 82; jjj++) {
            for (int kkk = 1; kkk <= 72; kkk++) {
              //	    if(mapRADDAM_HE[iii][jjj][kkk]!=0.) {dormM += mapRADDAM_HE[iii][jjj][kkk];++mcount;}
              normM[iii][jjj][kkk] = mapRADDAM_HE[iii][jjj][kkk];
              // AZ2019
              //	    if(normM[iii][jjj][kkk] != 0.)  cout<<" normM[iii][jjj][kkk] =  " << normM[iii][jjj][kkk] <<" iii =  " << iii <<endl;
            }  //for
          }    //for
        }      //for
        //      dormM /= mcount;
      }

      if (k1 == pk1f && kpp == 0 && kdirection == 1) {
        kpp = 1;  //Int_t pcount=0;
        cout << "* to be printed once only  CHECK IT please  ************ kpp = " << kpp << endl;
        cout << "POSITIVE direction refRun !!!! read LASER run with k1= " << k1 << "  run:  " << LASERruns[k1] << endl;
        for (int iii = 1; iii < DepthMax; iii++) {
          for (int jjj = 1; jjj <= 82; jjj++) {
            for (int kkk = 1; kkk <= 72; kkk++) {
              //	if(mapRADDAM_HE[iii][jjj][kkk]!=0.) {dormP += mapRADDAM_HE[iii][jjj][kkk];++pcount;}
              normP[iii][jjj][kkk] = mapRADDAM_HE[iii][jjj][kkk];
              // AZ2019
              //	    if(normP[iii][jjj][kkk] != 0.)  cout<<" normP[iii][jjj][kkk] =  " << normP[iii][jjj][kkk] <<" iii =  " << iii <<endl;
            }  //for
          }    //for
        }      //for
        //      dormP /= pcount;
      }
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////////--------each run  normalization on first run  ----------------- find Rijk = <Aijk>_runevents /  <Aijk>_runevents(ref.run)
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      for (int iii = 1; iii < DepthMax; iii++) {
        for (int jjj = 1; jjj <= 82; jjj++) {
          for (int kkk = 1; kkk <= 72; kkk++) {
            if (jjj < 42 && kdirection == 0) {
              if (normM[iii][jjj][kkk] != 0) {
                mapRADDAM_HE[iii][jjj][kkk] /= normM[iii][jjj][kkk];
              } else {
                mapRADDAM_HE[iii][jjj][kkk] = 0.;
              }
            }
            if (jjj > 41 && kdirection == 1) {
              if (normP[iii][jjj][kkk] != 0) {
                mapRADDAM_HE[iii][jjj][kkk] /= normP[iii][jjj][kkk];
              } else {
                mapRADDAM_HE[iii][jjj][kkk] = 0.;
              }
            }
          }  //for
        }    //for
      }      //for
      //
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      ///   variant2: for each run define phi-averaged A for normalization channel (Dref,16) and then, divide Rijk on it, i.e. get RRijk
      if (variant == 2) {
        Double_t normchannelM = 0;
        Double_t normchannelP = 0;
        //////////////////--------------------------------------- for each run, define A-norm_channel(Dref,16) averaged over PHI
        if (kdirection == 0) {
          Int_t mcounter = 0;
          for (int kkk = 1; kkk <= 72; kkk++) {
            if (mapRADDAM_HE[Dref][26][kkk] > 0.) {
              normchannelM += mapRADDAM_HE[Dref][26][kkk];
              mcounter++;
            }
          }  //for
          if (mcounter != 0)
            normchannelM /= mcounter;
        } else if (kdirection == 1) {
          Int_t pcounter = 0;
          for (int kkk = 1; kkk <= 72; kkk++) {
            if (mapRADDAM_HE[Dref][57][kkk] > 0.) {
              normchannelP += mapRADDAM_HE[Dref][57][kkk];
              pcounter++;
            }
          }  //for
          if (pcounter != 0)
            normchannelP /= pcounter;
        }
        //      cout<<"norm_channel(Dref,16) averaged over PHI: normchannelM = " << normchannelM <<   "                        normchannelP = " << normchannelP <<endl;
        //////////////////---------------------------------------
        //////////////////--------each run  normalization on channel Dref,16
        //////////////////---------------------------------------
        for (int iii = 1; iii < DepthMax; iii++) {
          for (int jjj = 1; jjj <= 82; jjj++) {
            for (int kkk = 1; kkk <= 72; kkk++) {
              if (mapRADDAM_HE[iii][jjj][kkk] > 0. && normchannelM != 0 && jjj < 42 && kdirection == 0) {
                mapRADDAM_HE[iii][jjj][kkk] /= normchannelM;
              }
              if (mapRADDAM_HE[iii][jjj][kkk] > 0. && normchannelP != 0 && jjj > 41 && kdirection == 1) {
                mapRADDAM_HE[iii][jjj][kkk] /= normchannelP;
              }
            }  //for
          }    //for
        }      //for

      }  // variant2

      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //                                               then, avereaging over phi, but first sum over phi before!!! any dividing:
      //////////////////---------------------------------------
      for (int iii = 1; iii < DepthMax; iii++) {
        for (int jjj = 1; jjj <= 82; jjj++) {
          for (int kkk = 1; kkk <= 72; kkk++) {
            if (mapRADDAM_HE[iii][jjj][kkk] > 0) {
              //	    if(mapRADDAM_HE[iii][jjj][kkk]< 0.031)  cout<<"*****   depth = " << iii <<" k1 = " << k1 <<" eta = " << jjj <<" phi = " << kkk <<" mapRADDAM_ijk = " <<     mapRADDAM_HE[iii][jjj][kkk] <<endl;
              // control histoes to reject bad channels using Rijk:
              rwithphi->Fill(mapRADDAM_HE[iii][jjj][kkk]);

              // use only good(rwithphi) Rijk channels:
              if ((mapRADDAM_HE[iii][jjj][kkk] > CutrwithphiMin && mapRADDAM_HE[iii][jjj][kkk] < CutrwithphiMax &&
                   variant != 2) ||
                  (mapRADDAM_HE[iii][jjj][kkk] > CutrwithphiMinVar2 &&
                   mapRADDAM_HE[iii][jjj][kkk] < CutrwithphiMaxVar2 && variant == 2)) {
                // control only! histoes to reject bad channels using RRijk (rrwithphiM & rrwithphiP) :
                Double_t RRrrRr = 0.;
                if (variant != 2) {
                  if (jjj < 42 && kdirection == 0) {
                    if (mapRADDAM_HE[Dref][26][kkk] != 0) {
                      RRrrRr = mapRADDAM_HE[iii][jjj][kkk] / mapRADDAM_HE[Dref][26][kkk];
                      rrwithphiM->Fill(RRrrRr);
                    }
                  } else if (jjj > 41 && kdirection == 1) {
                    if (mapRADDAM_HE[Dref][57][kkk] != 0) {
                      RRrrRr = mapRADDAM_HE[iii][jjj][kkk] / mapRADDAM_HE[Dref][57][kkk];
                      rrwithphiP->Fill(RRrrRr);
                    }
                  }
                } else if (variant == 2) {
                  if (jjj < 42 && kdirection == 0) {
                    RRrrRr = mapRADDAM_HE[iii][jjj][kkk];
                    rrwithphiM->Fill(RRrrRr);
                  } else if (jjj > 41 && kdirection == 1) {
                    RRrrRr = mapRADDAM_HE[iii][jjj][kkk];
                    rrwithphiP->Fill(RRrrRr);
                  }
                  //	      if(RRrrRr< 0.031)  cout<<"   depth = " << iii <<" k1 = " << k1 <<" eta = " << jjj <<" phi = " << kkk <<" RRrrRr = " <<     RRrrRr <<endl;
                }

                // use only good(rrwithphiM P) RRijk channels:
                if ((RRrrRr > CutrrwithphiMin && RRrrRr < CutrrwithphiMax && variant != 2) || variant == 2) {
                  // ----------------------------------------   sum over phi before!!! any dividing:
                  mapRADDAM_HED2[iii][jjj] += mapRADDAM_HE[iii][jjj][kkk];
                  // N phi sectors w/ digihits
                  mapRADDAM_HED20[iii][jjj]++;

                  if (verbosity == 3 && iii == Dref)
                    cout << "   depth = " << iii << " k1 = " << k1 << " eta = " << jjj
                         << " mapRADDAM_HED2[iii][jjj] = " << mapRADDAM_HED2[iii][jjj]
                         << " Nphi = " << mapRADDAM_HED20[iii][jjj]
                         << " mapRADDAM_HE[iii][jjj][kkk = " << mapRADDAM_HE[iii][jjj][kkk] << endl;

                  // define pointers for PHI dependence:
                  if (jjj < 42 && kdirection == 0) {
                    phidependenceM->Fill(float(kkk - 1), mapRADDAM_HE[iii][jjj][kkk]);
                    phidependenceM0->Fill(float(kkk - 1), 1.);
                    phiRRM->Fill(mapRADDAM_HE[iii][jjj][kkk]);
                  } else if (jjj > 41 && kdirection == 1) {
                    phidependenceP->Fill(float(kkk - 1), mapRADDAM_HE[iii][jjj][kkk]);
                    phidependenceP0->Fill(float(kkk - 1), 1.);
                    phiRRP->Fill(mapRADDAM_HE[iii][jjj][kkk]);
                  }

                }  //if RRrrRr
              }    //if > CutrwithphiMin

            }  // if mapRADDAM_HE[iii][jjj][kkk] != 0
          }    //for
        }      //for
      }        //for
      //=================================================================== normalization on first run channel 3,16:
      //           jjj =  1          |         82
      //                1- 41        -        42-82
      //                       26          57
      //HE
      // depth1         13-25        -        58-70        13-26 --> N=14, 57-70 --> N=14
      // depth2         13-24        -        59-67
      // depth3       14,15,26*      -       *57,68,69
      //  jjj       13-26 --> N=14   -     57-70 --> N=14
      //   jj     M: 0-13                P: 0-13
      // real N:    16-29                  16,29
      // correspondence realN to jj:
      //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13*     P:    0*   1   2   3   4   5   6   7   8   9   10    11    12    13
      // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16*          16*  17  18  19  20  21  22  23  24  25   26    27    28    29
      // jjj:      13   14  15  16  17  18  19  20  21  22   23    24    25    26*   +31=   57*  58  59  60  61  62  63  64  65  66   67    68    69    70
      //                                                                           (jjj-41) 16*  17  18  19  20  21  22  23  24  25   26    27    28    29
      //
      //    ZZM[k1][depth]][jjj=eta] --> ZZM[k1][7][14] negative direction   ,  ZZP[k1][7][14] positive dir.
      //                                            jj =  0 - 13                           jj =  0 - 13
      //                                           jjj = 13 - 26                          jjj = 57 - 70
      //                          Cell = ZZM[k1][Dref][13]                  and    ZZP[k1][Dref][0]
      //////////////////---------------------------------------
      //////////////////---------------------------------------
      //////////////------------------------------                                   and now averaging over N-phi_sectors
      //////////////////---------------------------------------
      for (int iii = 1; iii < DepthMax; iii++) {
        for (int jjj = 1; jjj <= 82; jjj++) {
          if (mapRADDAM_HED20[iii][jjj] != 0) {
            if (verbosity == 1)
              cout << "****aver per N-phi_sectors********* depth = " << iii << " RunIndex = " << k1 << " eta = " << jjj
                   << " Nphi = " << mapRADDAM_HED20[iii][jjj] << endl;
            mapRADDAM_HED2[iii][jjj] /= mapRADDAM_HED20[iii][jjj];
            if (verbosity == 3 && iii == Dref)
              cout << "****aver per N-phi_sectors********* depth = " << iii << " RunIndex = " << k1 << " eta = " << jjj
                   << " Nphi = " << mapRADDAM_HED20[iii][jjj] << endl;
            //	  int jj = jjj-13;
            //	  if(jj> 13) jj -=44;
            //	  if(jj<0 || jj>13) cout<<"*** ERROR *** depth = " << iii <<" eta = " << jjj <<" new-eta = " << jj <<endl;

            if (jjj < 42) {
              if (kdirection == 0) {
                int jj = jjj - 13;
                if (jj < 0 || jj > 13)
                  cout << "***ZZM ERROR *** depth = " << iii << " eta = " << jjj << " new-eta = " << jj << endl;
                ZZM[k1][iii][jj] = mapRADDAM_HED2[iii][jjj];
                if (verbosity == 1)
                  cout << "****aver per N-phi_sectors********* ZZM[k1][iii][jj] = " << ZZM[k1][iii][jj] << endl;
              }  //if kdirection=0
            } else {
              if (kdirection == 1) {
                int jj = jjj - 13;
                jj -= 44;
                if (jj < 0 || jj > 13)
                  cout << "***ZZP ERROR *** depth = " << iii << " eta = " << jjj << " new-eta = " << jj << endl;
                ZZP[k1][iii][jj] = mapRADDAM_HED2[iii][jjj];
                if (verbosity == 1)
                  cout << "****aver per N-phi_sectors****** ZZP[k1][iii][jj] = " << ZZP[k1][iii][jj] << endl;
              }  //if kdirection=1
            }    // if jjj<42

          }  // if(mapRADDAM_HED20 != 0

        }  //for jjj
      }    //for iii
      ///////////////////////////////////////////////////////////////// nulling :
      /////////////////////////////////////////////////////////////////////////////////////////////// nulling :
      ///////////////////////////////////////////////////////////////// nulling :
      //
      for (int iii = 0; iii < DepthMax; iii++) {
        for (int jjj = 0; jjj <= 82; jjj++) {
          mapRADDAM_HED2[iii][jjj] = 0.;
          mapRADDAM_HED20[iii][jjj] = 0.;
          for (int kkk = 0; kkk <= 72; kkk++) {
            mapRADDAM_HE[iii][jjj][kkk] = 0.;
          }
        }
      }
      ///////////////////// hfile->Close();
      hfile->Close();
      /////////////////////

      /*	// max Lumi 41.3 fb-1
	if( k1 == NP-1 ) {
  TH1F* rwithphi = new TH1F("rwithphi","", 100, -1.,6.);
	  for(int iii = 1; iii<4; iii++) {
	    for (int jjj=1;jjj<=82;jjj++) {
ZZM[k1][iii][jj] = 
if(mapRADDAM_HE[iii][jjj][kkk] != 0 ) rwithphi->Fill(mapRADDAM_HE[iii][jjj][kkk]);
ZZP[k1][iii][jj] = 
	    }//for  
	  }//for 
	}//if( k1 == NP-1 
*/

      //  }//if(k1==0 || (k1>37
      //  END OF LOOP OVER LASER RUNS
    }  //for k1 loop over time points(LASER runs)
    cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                   DONE: last LASER run READ " << endl;
    // ////////////////////////////////////////////////////////////////////////////////////////////////// END OF LOOP OVER LASER RUNS
    ////////////////////////////////////////////////////////////////////////////////////////////////////  END OF LOOP OVER LASER RUNS
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // ////////////////////////////////////////////////////////////////////////////////////////////////// END OF LOOP OVER LASER RUNS
    ////////////////////////////////////////////////////////////////////////////////////////////////////  END OF LOOP OVER LASER RUNS
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // ////////////////////////////////////////////////////////////////////////////////////////////////// END OF LOOP OVER LASER RUNS
    ////////////////////////////////////////////////////////////////////////////////////////////////////  END OF LOOP OVER LASER RUNS
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (variant != 2) {
      // =========================   normalization on channel:    ZZM[k1][Dref][13];   ZZP[k1][Dref][0];
      //
      for (int k1 = 0; k1 < NP; k1++) {
        if (verbosity == 1) {
          cout << " ********************************************************************time *************point = "
               << k1 << endl;
        }
        for (int iii = 1; iii < DepthMax; iii++) {
          for (int jj = 0; jj <= 13; jj++) {
            if (verbosity == 1) {
              cout << " **** DepthMax = " << DepthMax << " **** iii = " << iii << " **** jj = " << jj << endl;
            }
            //    cout << "!!!!!!!!!!!!!!!!!!normalization on channel:!!!!!!!!!!!!!!   Positive Direction " <<endl;

            if (kdirection == 1) {
              if (iii == Dref && jj == 0) {
              } else {
                if (ZZP[k1][Dref][0] != 0) {
                  ZZP[k1][iii][jj] /= ZZP[k1][Dref][0];
                }
                if (verbosity == 1 && ZZP[k1][iii][jj] != 0) {
                  cout << "Normalized P Positive Direction ***** depth = " << iii << " eta = " << jj
                       << " ZZP[k1][iii][jj] = " << ZZP[k1][iii][jj] << endl;
                }
                if (verbosity == 3 && ZZP[k1][iii][jj] != 0 && iii == Dref) {
                  cout << "Normalized P Positive Direction ***** depth = " << iii << " eta = " << jj
                       << " ZZP[k1][iii][jj] = " << ZZP[k1][iii][jj] << " ZZP[k1][Dref][0] = " << ZZP[k1][Dref][0]
                       << endl;
                }
                //AZ2019		if(iii==1&& jj==13) cout<<" k1 =  = " << k1<<" ZZP[k1][1][13] = " << ZZP[k1][1][13]<<endl;
              }  // if
            }    //if

            else if (kdirection == 0) {
              //    cout << "!!!!!!!!!!!!!!!!!normalization on channel:!!!!!!!!!!!!!!!   Negative Direction " <<endl;
              if (iii == Dref && jj == 13) {
              } else {
                if (ZZM[k1][Dref][13] != 0) {
                  ZZM[k1][iii][jj] /= ZZM[k1][Dref][13];
                }
                //		if( ZZM[k1][iii][jj] != 0 ) {cout<<"Normalized M Negative Direction ***** depth = " << iii <<" k1 = " << k1 <<" eta = " << jj <<" ZZM[k1][iii][jj] = " << ZZM[k1][iii][jj] <<endl;}
                //		if(ZZM[k1][iii][jj] != 0 && iii==Dref ) {cout<<"Normalized M Negative Direction iii==Dref               ***** depth = " << iii <<" k1 = " << k1 <<" eta = " << jj <<" ZZM[k1][iii][jj] = " << ZZM[k1][iii][jj] <<" ZZM[k1][Dref][0] = " << ZZM[k1][Dref][0]<<endl;}
              }  // if

            }  // if

          }  //for
        }    //for
      }      //for
      //
    }  // variant
    cout << "DONE variant   =  " << variant << endl;

    //============================= table   ====================================== normalization on first run channel 3,16:
    //             -41                                +41
    //                            82 bins
    //           jjj =  1          |         82    | -41
    //                1- 41        -        42-82
    //                       26          57        | -41
    //HE
    // depth1         13-25        -        58-70        13-26 --> N=14, 57-70 --> N=14
    // depth2         13-24        -        59-67
    // depth3       14,15,26*      -       *57,68,69
    //  jjj       13-26 --> N=14   -     57-70 --> N=14
    //   jj     M: 0-13                P: 0-13
    // real N:    16-29                  16,29
    // correspondence realN to jj:
    //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
    // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
    //                -   -       -        -   -  -                                                            -   -   -       -           -    -
    //             eta:
    //depth1                     0    -     12                                                          1       -             13   (+57)
    //depth2                       2  -     13                                                            2     -     10
    //depth3                     1,2  -     13*                                                       0*        -       11, 12
    //    ZZM[k1][depth]][jjj=eta] --> ZZM[k1][7][14] negative direction   ,  ZZP[k1][7][14] positive dir.
    //                                            jj =  0 - 13                           jj =  0 - 13
    //                                           jjj = 13 - 26                          jjj = 57 - 70
    //                          Cell = ZZM[k1][3][13]                  and    ZZP[k1][3][0]

    //
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // take last non-zero point corresponding max Integrated Lumi
    // you can clarify that using printout line below to see is last massive-element contains 0 or not:
    //    if(kdirection == 1 ) cout<<"********************    k1last = " <<k1last  <<"      RRP[12] = " << RRP[12] <<"        ZZP[k1last][1][13] = " << ZZP[k1last][1][13] <<   endl;
    int k1last = NP - 1;

    // P:
    if (kdirection == 1 && ZZP[k1last][2][13] < 0.1)
      k1last = NP - 2;

    // M:
    if (kdirection == 0) {
      // L1:
      cout << "******************** M  L1     k1last = " << k1last
           << "        ZZM[k1last][2][10] = " << ZZM[k1last][2][10] << endl;
      cout << "********************************************************************************************************"
              "********************************************************* "
           << endl;
      // L7:
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][5][1] = " << ZZM[k1last][5][1] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][5][2] = " << ZZM[k1last][5][2] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][5][3] = " << ZZM[k1last][5][3] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][4] = " << ZZM[k1last][4][4] << endl;  // eta=25
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][5] = " << ZZM[k1last][4][5] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][6] = " << ZZM[k1last][4][6] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][7] = " << ZZM[k1last][4][7] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][8] = " << ZZM[k1last][4][8] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][9] = " << ZZM[k1last][4][9] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][10] = " << ZZM[k1last][4][10] << endl;
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][4][11] = " << ZZM[k1last][4][11] << endl;  // eta=18
      cout << "********************* M  L7     k1last = " << k1last
           << "        ZZM[k1last][3][12] = " << ZZM[k1last][3][12] << endl;  // eta=17 13-jj==1
      cout << "****************************************************************************** " << endl;
    }
    //    if(kdirection == 0 && ZZM[k1last][5][10]<0.1 ) k1last=NP-2;
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////// Preparation for PLOT25:
    // jj   M:    0-   1   2   3   4   5   6   7   8   9   10    11   -12    13      P:    0    1-  2   3   4   5   6   7   8   9   10    11    12   -13
    // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29

    //            :
    // RR   N:   12   11  10   9   8   7   6   5   4   3    2    1      0                       0   1   2   3   4   5   6   7   8    9    10    11    12
    // RR7  N:        10   9   8   7   6   5   4   3   2    1    0                                  0   1   2   3   4   5   6   7    8    9     10

    //                                      2018:
    // L1: (iii=d2 & eta 17-29);
    // M: int LM1 = 0;if((iii==2 && jj<13)) LM1 = 1;
    // P: int LP1 = 0;if((iii==2 && jj> 0)) LP1 = 1;

    // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
    // M: int LM7=0;if((iii==3 && jj==12) || (iii==4 && jj> 3 && jj<12) || (iii==5 && jj> 0 && jj< 4)) LM7=1;
    // P: int LP7=0;if((iii==3 && jj==1 ) || (iii==4 && jj> 1 && jj<10) || (iii==5 && jj> 9 && jj<13)) LP7=1;
    //

    // L1: eta 17-29
    if (kdirection == 0)
      for (int jj = 0; jj < 13; jj++) {
        if (LASERruns[k1last] > "305874") {
          RRM[12 - jj] = ZZM[k1last][2][jj];
        } else {
          RRM[12 - jj] = ZZM[k1last][1][jj];
        }
      }
    if (kdirection == 1)
      for (int jj = 1; jj < 14; jj++) {
        if (LASERruns[k1last] > "305874") {
          RRP[jj - 1] = ZZP[k1last][2][jj];
        } else {
          RRP[jj - 1] = ZZP[k1last][1][jj];
        }
      }  // 29 P ?

    // L7: eta 18-28
    if (kdirection == 0)
      for (int iii = 2; iii < DepthMax; iii++) {
        for (int jj = 1; jj < 12; jj++) {
          if (LASERruns[k1last] > "305874") {
            if ((iii == 3 && 13 - jj == 1) || (iii == 4 && 13 - jj > 1 && 13 - jj < 10) ||
                (iii == 5 && 13 - jj > 9 && 13 - jj < 13)) {
              RRM7[11 - jj] = ZZM[k1last][iii][jj];
              //	    cout<<"***LAST   ***** M  L7     k1last = " <<k1last <<" iii = " <<iii   <<" jj = " <<jj   <<"   ZZM[k1last][iii][jj] = " <<  ZZM[k1last][iii][jj] <<"   11-jj =" <<11-jj <<"   RRM7[11-jj] = " <<  RRM7[11-jj] <<   endl;
            }
          } else {
            if ((iii == 2 && jj > 2 && jj < 12) || (iii == 3 && jj > 0 && jj < 3))
              RRM7[11 - jj] = ZZM[k1last][iii][jj];
          }
        }
      }

    if (kdirection == 1)
      for (int iii = 2; iii < DepthMax; iii++) {
        for (int jj = 1; jj < 13; jj++) {
          if (LASERruns[k1last] > "305874") {
            if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13)) {
              RRP7[jj - 2] = ZZP[k1last][iii][jj];
            }
          } else {
            if ((iii == 2 && jj > 1 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
              RRP7[jj - 2] = ZZP[k1last][iii][jj];
          }
        }
      }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   DRAWING   DRAWING   DRAWING   DRAWING   DRAWING
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   DRAWING   DRAWING   DRAWING   DRAWING   DRAWING
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   DRAWING   DRAWING   DRAWING   DRAWING   DRAWING
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   DRAWING   DRAWING   DRAWING   DRAWING   DRAWING
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   DRAWING   DRAWING   DRAWING   DRAWING   DRAWING

    cout << "****  DRAWING  ****  ****  ****  ****     Draw Dependencies: *** " << endl;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Int_t Method = NMethodsStart;
    // M: kdirection==0
    // P: kdirection==1
    while (Method < NMethodsToUse + 1) {
      if ((kdirection == 1 && Method != 9 && Method != 19 && Method != 24 && Method != 26 && Method != 28 &&
           Method != 32 && Method != 1 && Method != 2 && Method != 3 && Method != 4 && Method != 5 && Method != 6 &&
           Method != 7 && Method != 8 && Method != 30) ||
          (kdirection == 0 && Method != 0 && Method != 10 && Method != 22 && Method != 27 && Method != 29 &&
           Method != 33 && Method != 11 && Method != 12 && Method != 13 && Method != 14 && Method != 15 &&
           Method != 16 && Method != 17 && Method != 18 && Method != 31 && Method != 20 && Method != 21 &&
           Method != 23 && Method != 25 && Method != 34 && Method != 35 && Method != 36)) {
        cout << " ****  START   Method " << Method << endl;
        //======================================================================================================= PLOT0: P:    <Aijk>_ev.run for all runs
        if (Method == 0) {
          cout << "****Draw 0 Dependencies: P: draw <Aijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(101110);
          //    Ceff1D->SetTitle("any Error, HE Depth1 \n");
          Ceff1D->SetMarkerStyle(20);
          Ceff1D->SetMarkerSize(0.4);
          Ceff1D->GetYaxis()->SetLabelSize(0.04);
          Ceff1D->SetTitle("P: all runs & channels");
          Ceff1D->SetXTitle("<Aijk>");
          Ceff1D->SetYTitle("N");
          Ceff1D->SetMarkerColor(4);
          Ceff1D->SetLineColor(4);
          //    Ceff1D->Draw("Error");
          Ceff1D->Draw("PL");
        }  //Method = 0
        //  //////////////////////////////////////////////////////////////////////////
        //======================================================================================================= PLOT10: P:   <Aijk>_ev.run for all runs
        if (Method == 10) {
          cout << "****Draw 10 Dependencies: P: draw <Aijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(101110);
          //    Seff1D->SetTitle("any Error, HE Depth1 \n");
          Seff1D->SetMarkerStyle(20);
          Seff1D->SetMarkerSize(0.4);
          Seff1D->GetYaxis()->SetLabelSize(0.04);
          Seff1D->SetTitle("P: all runs & channels");
          Seff1D->SetXTitle("<Aijk>");
          Seff1D->SetYTitle("N");
          Seff1D->SetMarkerColor(4);
          Seff1D->SetLineColor(4);
          //    Seff1D->Draw("Error");
          Seff1D->Draw("PL");
        }  //Method = 10
        //  //////////////////////////////////////////////////////////////////////////
        //======================================================================================================= PLOT9: M:    <Aijk>_ev.run for all runs
        if (Method == 9) {
          cout << "****Draw 9 Dependencies: M: draw <Aijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(101110);
          c1->SetFillColor(0);
          //    Ceff1D->SetTitle("any Error, HE Depth1 \n");
          Ceff1D->SetMarkerStyle(20);
          Ceff1D->SetMarkerSize(0.4);
          Ceff1D->GetYaxis()->SetLabelSize(0.04);
          Ceff1D->SetTitle("M: all runs & channels");
          Ceff1D->SetXTitle("<Aijk>");
          Ceff1D->SetYTitle("N");
          Ceff1D->SetMarkerColor(4);
          Ceff1D->SetLineColor(4);
          //    Ceff1D->Draw("Error");
          Ceff1D->Draw("PL");
        }  //Method = 9
        //  //////////////////////////////////////////////////////////////////////////
        //======================================================================================================= PLOT19: M:   <Aijk>_ev.run for all runs
        if (Method == 19) {
          cout << "****Draw 19 Dependencies: M: draw <Aijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(101110);
          c1->SetFillColor(0);
          //    Seff1D->SetTitle("any Error, HE Depth1 \n");
          Seff1D->SetMarkerStyle(20);
          Seff1D->SetMarkerSize(0.4);
          Seff1D->GetYaxis()->SetLabelSize(0.04);
          Seff1D->SetTitle("M: all runs & channels");
          Seff1D->SetXTitle("<Aijk>");
          Seff1D->SetYTitle("N");
          Seff1D->SetMarkerColor(4);
          Seff1D->SetLineColor(4);
          //    Seff1D->Draw("Error");
          Seff1D->Draw("PL");
        }  //Method = 19
        //  //////////////////////////////////////////////////////////////////////////
        //======================================================================================================= PLOT20: P: mean <Aijk>_ev.run for all runs 3 Depthes
        if (Method == 20) {
          cout << "****Draw 20 Dependencies: P: draw mean <Aijk>_ev.run for all runs Depth3  *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(101110);
          Meff1D->SetMarkerStyle(20);
          Meff1D->SetMarkerSize(0.4);
          Meff1D->GetYaxis()->SetLabelSize(0.04);
          Meff1D->SetXTitle("for mean <Aijk>");
          Meff1D->SetYTitle("N");
          Meff1D->SetMarkerColor(4);
          Meff1D->SetLineColor(4);
          Meff1D->Draw("Error");
          Meff2D->SetMarkerColor(2);
          Meff2D->SetLineColor(2);
          Meff2D->Draw("ErrorSame");
          Meff3D->SetMarkerColor(3);
          Meff3D->SetLineColor(3);
          Meff3D->Draw("ErrorSame");
          //          Meff3D->Draw("PL");
        }  //Method = 20
        //  //////////////////////////////////////////////////////////////////////////

        //
        /*
Draw("APL"); - w/ errors

    */
        //                                                                               PLOTS WITH ZZM[k1][iii][jj]   :
        //
        //======================================================================================================= PLOT1 r vs t negative direction:Depth1  and eta 21 22 23 25 27 28
        if (Method == 1) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          //    TPad *pad1 = new TPad("pad1","This is pad1",0.02,0.02,0.98,0.83,33);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 1 Dependencies: M   r vs t for Depth1 and some eta 21 22 23 25 27 28  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][1];
          }  // eta=28
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 28");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][2];
          }  /// eta=27
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][4];
          }  /// eta=25
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][6];
          }  /// eta=23
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 23");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][7];
          }  /// eta=22
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][8];
          }  /// eta=21
          gr6 = new TGraph(NP, XX, YY);
          gr6->SetLineColor(6);
          gr6->SetMarkerColor(6);
          gr6->SetMarkerStyle(20);
          gr6->SetMarkerSize(1.2);
          gr6->SetTitle("ieta 21");
          gr6->SetFillStyle(0);
          gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP Depth1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM Depth1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);
          leg.AddEntry(gr6);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //1
        //======================================================================================================= PLOT2 r vs t negative direction:Depth1  and eta 17 18? 19 20? 24 26 29
        if (Method == 2) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 2 Dependencies: M   r vs t for Depth1 and some eta 17 18 19 20 24 26 29  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][0];
            //    if (YY[k1]>1.001 || YY[k1]<0.1 ) cout<<"\"" << LASERruns[k1] <<"\"," << endl;
            //    if (YY[k1]<.64 ) cout<<" k1 = " << k1 <<"     \"," <<"\"" << LASERruns[k1] <<"\"," <<" XX[k1] = " << YY[k1] <<" XX[k1] = " << YY[k1] << endl;
            //	    if (k1> 30 ) cout<<" k1 = " << k1 <<"     \"," <<"\"" << LASERruns[k1] <<"\"," <<" XX[k1] = " << XX[k1] <<" YY[k1] = " << YY[k1] << endl;

          }  // eta=29
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 29");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][3];
          }  /// eta=26
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 26");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][5];
          }  /// eta=24
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 24");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          //      for(int k1 = 0; k1<NP; k1++) {YY[k1] = ZZM[k1][1][9];}/// eta=20
          //      gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(4); gr6->SetMarkerColor(4); gr6->SetMarkerStyle(20); gr6->SetMarkerSize(1.2); gr6->SetTitle("ieta 20"); gr6->SetFillStyle(0); gr6->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][10];
          }  /// eta=19
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(5);
          gr4->SetMarkerColor(5);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          //      for(int k1 = 0; k1<NP; k1++) {YY[k1] = ZZM[k1][1][11];}/// eta=18
          //      gr7 = new TGraph(NP,XX,YY); gr7->SetLineColor(6); gr7->SetMarkerColor(6); gr7->SetMarkerStyle(20); gr7->SetMarkerSize(1.2); gr7->SetTitle("ieta 18"); gr7->SetFillStyle(0); gr7->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][1][12];
          }  /// eta=17
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(7);
          gr5->SetMarkerColor(7);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 17");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          //      TLegend leg(.6,.67,.78,.88, " HEP Depth1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM Depth1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //12
        //
        //======================================================================================================= PLOT3 r vs t negative direction:Depth2  and eta 21 22 23 25
        if (Method == 3) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y3, x2, y4);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 3 Dependencies: M   r vs t for Depth2 and some eta 21 22 23 25 27 28  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][4];
          }  /// eta=25
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 25");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][6];
          }  /// eta=23
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 23");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][7];
          }  /// eta=22
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 22");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][8];
          }  /// eta=21
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 21");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP Depth2");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM Depth2");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);  //leg.AddEntry(gr5);leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //3
        //
        //======================================================================================================= PLOT4 r vs t negative direction:Depth2  and eta 17 18 19 20 24 26
        if (Method == 4) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y3, x2, y4);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 4 Dependencies: M   r vs t for Depth2 and some eta 17 18 19 20 24 26 29  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][3];
          }  /// eta=26
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 26");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][5];
          }  /// eta=24
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 24");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][9];
          }  /// eta=20
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 20");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][10];
          }  /// eta=19
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZM[k1][2][11];
          }  /// eta=18
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 18");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          //    for(int k1 = 0; k1<NP; k1++) {YY[k1] = ZZM[k1][2][12];}/// eta=17
          //    gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(6); gr6->SetMarkerColor(6); gr6->SetMarkerStyle(20); gr6->SetMarkerSize(1.2); gr6->SetTitle("ieta 17"); gr6->SetFillStyle(0); gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP Depth2");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM Depth2");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  // 4
        //
        //
        //================================================================================
        //================================================================================
        //======================================================================================================= PLOT5 negative direction:r vs t for L1  and eta 21 22 23 25 27 28
        if (Method == 5) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 5 Dependencies:  M  r vs t for L1  and eta 21 22 23 25 27 28   **** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          //======================================================= introduce Layers: negative direction
          //jj   M:    >0   >1   2  >3  <4   5   6   7   8   9   10    11    12   <13      P:    0>   1   2   3   4   5   6   7   8   9   10>  <11    12<   13<
          // real N:   29- -28 -27  26- 25  24  23  22  21  20   19    18    17-   16           16   17- 18  19  20  21  22  23  24  25   26-   27-   28-   29-
          //  iii=depth, jj=eta
          // M:
          // ZZM[k1][iii][jj]    (iii=d1 & eta 17-29)                       L1

          // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13    2018:
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          // L1: (iii=d2 & eta 17-29);
          // M: int LM1 = 0;if((iii==2 && jj<13)) LM1 = 1;
          // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
          // M: int LM7=0;if((iii==3 && jj==12) || (iii==4 && jj> 3 && jj<12) || (iii==5 && jj> 0 && jj< 4)) LM7=1;
          //
          // eta=28 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 1) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 1) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 28");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          /// eta=27 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 2) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 2) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          /// eta=25 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 4) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 4) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          /// eta=23 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 6) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 6) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 23");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          /// eta=22 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 7) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 7) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          /// eta=21 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 8) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 8) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr6 = new TGraph(NP, XX, YY);
          gr6->SetLineColor(6);
          gr6->SetMarkerColor(6);
          gr6->SetMarkerStyle(20);
          gr6->SetMarkerSize(1.2);
          gr6->SetTitle("ieta 21");
          gr6->SetFillStyle(0);
          gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP L1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM L1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);
          leg.AddEntry(gr6);  //leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");

        }  //if(Method == 5
        //

        //======================================================================================================= PLOT6 negative direction:r vs t for L1  and eta 17 18 19 20 24 26 29
        if (Method == 6) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 6 Dependencies:  M  r vs t for L1  and eta 17 18 19 20 24 26 29   **** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          /// eta=29 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 0) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 0) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 29");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          /// eta=26 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 3) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 3) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 26");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          /// eta=24 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 5) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 5) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 24");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          /// eta=20 L1=1
          //	    for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;if(LASERruns[k1] > "305874" ) {for(int iii = 2; iii<3; iii++) {for (int jj=0;jj<13;jj++) {int LM1 = 0;if((iii==2 && jj<13)) LM1 = 1;if(LM1 == 1 && jj == 9)  {YY[k1] = ZZM[k1][iii][jj];} }}}else{for(int iii = 1; iii<2; iii++) {for (int jj=0;jj<13;jj++) {int LM1 = 0;if((iii==1 && jj<13)) LM1 = 1;if(LM1 == 1 && jj == 9)  {YY[k1] = ZZM[k1][iii][jj];} }}}}
          //  	    gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(4); gr6->SetMarkerColor(4); gr6->SetMarkerStyle(20); gr6->SetMarkerSize(1.2); gr6->SetTitle("ieta 20"); gr6->SetFillStyle(0); gr6->Draw("P");
          /// eta=19 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 10) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 10) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(5);
          gr4->SetMarkerColor(5);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          /// eta=18 L1=1
          //	    for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;if(LASERruns[k1] > "305874" ) {for(int iii = 2; iii<3; iii++) {for (int jj=0;jj<13;jj++) {int LM1 = 0;if((iii==2 && jj<13)) LM1 = 1;if(LM1 == 1 && jj ==11)  {YY[k1] = ZZM[k1][iii][jj];} }}}else{for(int iii = 1; iii<2; iii++) {for (int jj=0;jj<13;jj++) {int LM1 = 0;if((iii==1 && jj<13)) LM1 = 1;if(LM1 == 1 && jj == 11)  {YY[k1] = ZZM[k1][iii][jj];} }}}}
          //  	    gr7 = new TGraph(NP,XX,YY); gr7->SetLineColor(6); gr7->SetMarkerColor(6); gr7->SetMarkerStyle(20); gr7->SetMarkerSize(1.2); gr7->SetTitle("ieta 18"); gr7->SetFillStyle(0); gr7->Draw("P");
          /// eta=17 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 2 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 12) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 0; jj < 13; jj++) {
                  int LM1 = 0;
                  if ((iii == 1 && jj < 13))
                    LM1 = 1;
                  if (LM1 == 1 && jj == 12) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(7);
          gr5->SetMarkerColor(7);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 17");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP L1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM L1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
        }  //if(Method == 6

        //
        //======================================================================================================= PLOT7 negative direction:r vs t for L7  and eta 21 22 23 25 27 28
        if (Method == 7) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          // reject bad runs:
          //                cout<<"****   Negative direction:  reject bad runs eta 21   **** " <<endl;
          cout << "****   Negative direction:  take good runs eta 21   **** " << endl;
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y5, x2, y6);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 7 Dependencies:  M  r vs t for L7  and eta 21 22 23 25 27 28   **** " << endl;
          // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //======================================================= introduce Layers: positive direction
          // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
          //                                     (iii=d2 & eta 17-26) && (iii=d3 & eta 27-28)   L7                                  2016 2017
          // M: int LM7=0;if((iii==3 && jj==12) || (iii==4 && jj> 3 && jj<12) || (iii==5 && jj> 0 && jj< 4)) LM7=1;                        2018

          /// eta=28 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 1) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 1) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetTitle("ieta 28");
          gr1->SetFillStyle(0);
          gr1->SetMarkerSize(1.2);
          gr1->Draw("P");
          /// eta=27 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 2) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 2) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->SetMarkerSize(1.2);
          gr2->Draw("P");
          /// eta=25 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 4) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 4) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->SetMarkerSize(1.2);
          gr3->Draw("P");
          /// eta=23 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 6) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 6) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetTitle("ieta 23");
          gr4->SetFillStyle(0);
          gr4->SetMarkerSize(1.2);
          gr4->Draw("P");
          /// eta=22 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 7) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 7) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->SetMarkerSize(1.2);
          gr5->Draw("P");
          /// eta=21 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 8) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 8) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
            //======================================================= introduce Layers: positive direction
            // reject bad runs:
            //	      if (YY[k1]>1.05 || YY[k1]<0.1 ) {} else cout<<"\"" << LASERruns[k1] <<"\"," << endl;
          }
          gr6 = new TGraph(NP, XX, YY);
          gr6->SetLineColor(6);
          gr6->SetMarkerColor(6);
          gr6->SetMarkerStyle(20);
          gr6->SetTitle("ieta 21");
          gr6->SetFillStyle(0);
          gr6->SetMarkerSize(1.2);
          gr6->Draw("P");

          //    TLegend leg(.6,.67,.78,.88, " HEP L7");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM L7");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);
          leg.AddEntry(gr6);  //leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
        }  //if(Method == 7
        //
        //======================================================================================================= PLOT8 negative direction:r vs t for L7  and eta 17 18 19 20 24 26 29
        if (Method == 8) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y5, x2, y6);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 8 Dependencies:  M  r vs t for L7  and eta 17 18 19 20 24 26 29   **** " << endl;
          // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //======================================================= introduce Layers: positive direction
          // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
          //                                     (iii=d2 & eta 17-26) && (iii=d3 & eta 27-28)   L7                                  2016 2017
          // M: int LM7=0;if((iii==3 && jj==12) || (iii==4 && jj> 3 && jj<12) || (iii==5 && jj> 0 && jj< 4)) LM7=1;                        2018

          /// eta=26 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 3) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 3) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetTitle("ieta 26");
          gr1->SetFillStyle(0);
          gr1->SetMarkerSize(1.2);
          gr1->Draw("P");
          /// eta=24 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 5) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 5) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetTitle("ieta 24");
          gr2->SetFillStyle(0);
          gr2->SetMarkerSize(1.2);
          gr2->Draw("P");
          /// eta=20 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 9) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 9) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetTitle("ieta 20");
          gr3->SetFillStyle(0);
          gr3->SetMarkerSize(1.2);
          gr3->Draw("P");
          /// eta=19 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 10) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 10) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->SetMarkerSize(1.2);
          gr4->Draw("P");
          /// eta=18 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 3 && jj == 12) || (iii == 4 && jj > 3 && jj < 12) || (iii == 5 && jj > 0 && jj < 4))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 11) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LM7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LM7 = 1;
                  if (LM7 == 1 && jj == 11) {
                    YY[k1] = ZZM[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetTitle("ieta 18");
          gr5->SetFillStyle(0);
          gr5->SetMarkerSize(1.2);
          gr5->Draw("P");
          /// eta=17 L7=1
          //	    for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;if(LASERruns[k1] > "305874" ) {for(int iii = 3; iii<6; iii++) {for (int jj=1;jj<13;jj++) {int LM7=0;if((iii==3 && jj==12) || (iii==4 && jj> 3 && jj<12) || (iii==5 && jj> 0 && jj< 4)) LM7=1;if(LM7 == 1 && jj ==12)  {YY[k1] = ZZM[k1][iii][jj];} }}}else{for(int iii = 2; iii<4; iii++) {for (int jj=1;jj<13;jj++) {int LM7 = 0;if((iii==2 && jj>0 && jj<11) || (iii==3 && jj>10 && jj<13)) LM7 = 1;if(LM7 == 1 && jj ==12)  {YY[k1] = ZZM[k1][iii][jj];} }}} }
          //            gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(6); gr6->SetMarkerColor(6); gr6->SetMarkerStyle(20); gr6->SetTitle("ieta 17"); gr6->SetFillStyle(0); gr6->SetMarkerSize(1.2); gr6->Draw("P");
          //	    //    TLegend leg(.6,.67,.78,.88, " HEP L7");
          TLegend leg(xx1, yy1, xx2, yy2, " HEM L7");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
        }  //if(Method == 8
        //
        //=======================================================================================================
        //======================================================================================================= positive direction:
        //=======================================================================================================
        //  //////////////////////////////////////////////////////////////////////////
        //
        //                                                                               PLOTS WITH ZZP[k1][iii][jj]   :
        //
        //======================================================================================================= PLOT11 r vs t positive direction:Depth1  and eta 21 22 23 25 27 28
        if (Method == 11) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 11 Dependencies: P   r vs t for Depth1 and some eta 21 22 23 25 27 28  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][12];
          }  // eta=28
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 28");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][11];
          }  /// eta=27
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][9];
          }  /// eta=25
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][7];
          }  /// eta=23
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 23");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][6];
          }  /// eta=22
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][5];
          }  /// eta=21
          gr6 = new TGraph(NP, XX, YY);
          gr6->SetLineColor(6);
          gr6->SetMarkerColor(6);
          gr6->SetMarkerStyle(20);
          gr6->SetMarkerSize(1.2);
          gr6->SetTitle("ieta 21");
          gr6->SetFillStyle(0);
          gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP Depth1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP Depth1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);
          leg.AddEntry(gr6);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //11
        //======================================================================================================= PLOT12 r vs t positive direction:Depth1  and eta 17 18? 19 20? 24 26 29
        if (Method == 12) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 12 Dependencies: P   r vs t for Depth1 and some eta 17 18 19 20 24 26 29  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][13];
            //	    if (YY[k1]>1.001 || YY[k1]<0.1 ) cout<<" k1 = " << k1 <<"     \"," <<"\"" << LASERruns[k1] <<"\"," << endl;
            //    if (YY[k1]<.64 ) cout<<" k1 = " << k1 <<"     \"," <<"\"" << LASERruns[k1] <<"\"," <<" XX[k1] = " << YY[k1] <<" XX[k1] = " << YY[k1] << endl;
            //	    if (k1> 30 ) cout<<" k1 = " << k1 <<"     \"," <<"\"" << LASERruns[k1] <<"\"," <<" XX[k1] = " << XX[k1] <<" YY[k1] = " << YY[k1] << endl;

          }  // eta=29
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 29");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][10];
          }  /// eta=26
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 26");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][8];
          }  /// eta=24
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 24");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          //      for(int k1 = 0; k1<NP; k1++) {YY[k1] = ZZP[k1][1][4];}/// eta=20
          //      gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(4); gr6->SetMarkerColor(4); gr6->SetMarkerStyle(20); gr6->SetMarkerSize(1.2); gr6->SetTitle("ieta 20"); gr6->SetFillStyle(0); gr6->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][3];
          }  /// eta=19
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(5);
          gr4->SetMarkerColor(5);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          //      for(int k1 = 0; k1<NP; k1++) {YY[k1] = ZZP[k1][1][2];}/// eta=18
          //      gr7 = new TGraph(NP,XX,YY); gr7->SetLineColor(6); gr7->SetMarkerColor(6); gr7->SetMarkerStyle(20); gr7->SetMarkerSize(1.2); gr7->SetTitle("ieta 18"); gr7->SetFillStyle(0); gr7->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][1][1];
          }  /// eta=17
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(7);
          gr5->SetMarkerColor(7);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 17");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          //      TLegend leg(.6,.67,.78,.88, " HEP Depth1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP Depth1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //12
        //
        //======================================================================================================= PLOT13 r vs t positive direction:Depth2  and eta 21 22 23 25
        if (Method == 13) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y3, x2, y4);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 13 Dependencies: P   r vs t for Depth2 and some eta 21 22 23 25 27 28  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][9];
          }  /// eta=25
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 25");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][7];
          }  /// eta=23
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 23");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][6];
          }  /// eta=22
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 22");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][5];
          }  /// eta=21
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 21");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP Depth2");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP Depth2");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);  //leg.AddEntry(gr5);leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //13
        //
        //======================================================================================================= PLOT14 r vs t positive direction:Depth2  and eta 17 18 19 20 24 26
        if (Method == 14) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y3, x2, y4);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 14 Dependencies: P   r vs t for Depth2 and some eta 17 18 19 20 24 26 29  *** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][10];
          }  /// eta=26
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 26");
          gr1->SetFillStyle(0);
          gr1->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][8];
          }  /// eta=24
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 24");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][4];
          }  /// eta=20
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 20");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][3];
          }  /// eta=19
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][2][2];
          }  /// eta=18
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 18");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          //    for(int k1 = 0; k1<NP; k1++) {YY[k1] = ZZP[k1][2][1];}/// eta=17
          //    gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(6); gr6->SetMarkerColor(6); gr6->SetMarkerStyle(20); gr6->SetMarkerSize(1.2); gr6->SetTitle("ieta 17"); gr6->SetFillStyle(0); gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP Depth2");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP Depth2");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
          //
        }  //14
        //
        //================================================================================
        //================================================================================
        //======================================================================================================= PLOT15 positive direction:r vs t for L1  and eta 21 22 23 25 27 28
        if (Method == 15) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 15 Dependencies:  P  r vs t for L1  and eta 21 22 23 25 27 28   **** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          //======================================================= introduce Layers: positive direction
          // eta=28 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 12) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 12) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 28");
          gr1->SetFillStyle(0);
          gr1->Draw("P");

          /// eta=27 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 11) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 11) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          /// eta=25 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 9) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 9) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          /// eta=23 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 7) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 7) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 23");
          gr4->SetFillStyle(0);
          gr4->Draw("P");
          /// eta=22 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 6) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 6) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          /// eta=21 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 5) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 5) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr6 = new TGraph(NP, XX, YY);
          gr6->SetLineColor(6);
          gr6->SetMarkerColor(6);
          gr6->SetMarkerStyle(20);
          gr6->SetMarkerSize(1.2);
          gr6->SetTitle("ieta 21");
          gr6->SetFillStyle(0);
          gr6->Draw("P");

          //    TLegend leg(.6,.67,.78,.88, " HEP L1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP L1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);
          leg.AddEntry(gr6);  //leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");

        }  //if(Method == 15
        //
        //======================================================================================================= PLOT16 positive direction:r vs t for L1  and eta 17 18 19 20 24 26 29
        if (Method == 16) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 16 Dependencies:  P  r vs t for L1  and eta 17 18 19 20 24 26 29   **** " << endl;
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          //======================================================= introduce Layers: positive direction
          // eta=29 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 13) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 13) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetMarkerSize(1.2);
          gr1->SetTitle("ieta 29");
          gr1->SetFillStyle(0);
          gr1->Draw("P");

          /// eta=26 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 10) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 10) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetMarkerSize(1.2);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->Draw("P");
          /// eta=24 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 8) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 8) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetMarkerSize(1.2);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->Draw("P");
          /// eta=20 L1=1
          //	    for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;if(LASERruns[k1] > "305874" ) {for(int iii = 2; iii<3; iii++) {for (int jj=1;jj<=13;jj++) {int LP1 = 0;if((iii==2 && jj>0)) LP1 = 1;if(LP1 == 1 && jj ==  4)  {YY[k1] = ZZP[k1][iii][jj];} }}}else{for(int iii = 1; iii<2; iii++) {for (int jj=1;jj<=13;jj++) {int LP1 = 0;if((iii==1 && jj>0)) LP1 = 1;if(LP1 == 1 && jj == 4)  {YY[k1] = ZZP[k1][iii][jj];} }}}}
          //	    gr4 = new TGraph(NP,XX,YY); gr4->SetLineColor(4); gr4->SetMarkerColor(4); gr4->SetMarkerStyle(20); gr4->SetMarkerSize(1.2); gr4->SetTitle("ieta 23"); gr4->SetFillStyle(0); gr4->Draw("P");
          /// eta=19 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 3) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 3) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetMarkerSize(1.2);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->Draw("P");
          /// eta=18 L1=1
          //	    for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;if(LASERruns[k1] > "305874" ) {for(int iii = 2; iii<3; iii++) {for (int jj=1;jj<=13;jj++) {int LP1 = 0;if((iii==2 && jj>0)) LP1 = 1;if(LP1 == 1 && jj ==  2)  {YY[k1] = ZZP[k1][iii][jj];} }}}else{for(int iii = 1; iii<2; iii++) {for (int jj=1;jj<=13;jj++) {int LP1 = 0;if((iii==1 && jj>0)) LP1 = 1;if(LP1 == 1 && jj == 2)  {YY[k1] = ZZP[k1][iii][jj];} }}}}
          //	    gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(6); gr6->SetMarkerColor(6); gr6->SetMarkerStyle(20); gr6->SetMarkerSize(1.2); gr6->SetTitle("ieta 21"); gr6->SetFillStyle(0); gr6->Draw("P");
          /// eta=17 L1=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 2; iii < 3; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 2 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 1) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 1; iii < 2; iii++) {
                for (int jj = 1; jj <= 13; jj++) {
                  int LP1 = 0;
                  if ((iii == 1 && jj > 0))
                    LP1 = 1;
                  if (LP1 == 1 && jj == 1) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr7 = new TGraph(NP, XX, YY);
          gr7->SetLineColor(7);
          gr7->SetMarkerColor(7);
          gr7->SetMarkerStyle(20);
          gr7->SetMarkerSize(1.2);
          gr7->SetTitle("ieta 21");
          gr7->SetFillStyle(0);
          gr7->Draw("P");

          //    TLegend leg(.6,.67,.78,.88, " HEP L1");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP L1");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
        }  //if(Method == 16
        //
        //================================================================================
        //======================================================================================================= PLOT17 positive direction:r vs t for L7  and eta 21 22 23 25 27? 28?
        if (Method == 17) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          // reject bad runs:
          //                cout<<"****   Positive direction:  reject bad runs eta 21   **** " <<endl;
          cout << "****   Positive direction:  take good runs eta 21   **** " << endl;
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y5, x2, y6);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 17 Dependencies:  P  r vs t for L7  and eta 21 22 23 25 27 28   **** " << endl;
          // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
          // P: int LP7=0;if((iii==3 && jj==1 ) || (iii==4 && jj> 1 && jj<10) || (iii==5 && jj> 9 && jj<13)) LP7=1;
          //======================================================= introduce Layers: positive direction
          /// eta=28 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 12) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 12) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetTitle("ieta 28");
          gr1->SetFillStyle(0);
          gr1->SetMarkerSize(1.2);
          gr1->Draw("P");
          /// eta=27 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 11) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 11) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetTitle("ieta 27");
          gr2->SetFillStyle(0);
          gr2->SetMarkerSize(1.2);
          gr2->Draw("P");
          /// eta=25 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 9) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 9) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetTitle("ieta 25");
          gr3->SetFillStyle(0);
          gr3->SetMarkerSize(1.2);
          gr3->Draw("P");
          /// eta=23 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 7) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 7) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetMarkerSize(1.2);
          gr4->SetTitle("ieta 23");
          gr4->SetFillStyle(0);
          gr4->SetMarkerSize(1.2);
          gr4->Draw("P");
          /// eta=22 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 6) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 6) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetTitle("ieta 22");
          gr5->SetFillStyle(0);
          gr5->SetMarkerSize(1.2);
          gr5->Draw("P");
          /// eta=21 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 5) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 5) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
            //======================================================= introduce Layers: positive direction
            // reject bad runs:
            //    	    if (YY[k1]>1.05 || YY[k1]<0.1 ) cout<<"\"" << LASERruns[k1] <<"\"," << endl;
            //	      if (YY[k1]>1.05 || YY[k1]<0.1 ) {} else cout<<"\"" << LASERruns[k1] <<"\"," << endl;
          }
          gr6 = new TGraph(NP, XX, YY);
          gr6->SetLineColor(6);
          gr6->SetMarkerColor(6);
          gr6->SetMarkerStyle(20);
          gr6->SetMarkerSize(1.2);
          gr6->SetTitle("ieta 21");
          gr6->SetFillStyle(0);
          gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP L7");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP L7");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);
          leg.AddEntry(gr6);  //leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
        }  //if(Method == 17
           //
        //======================================================================================================= PLOT18 positive direction:r vs t for L7  and eta 17 18 19 20 24 26
        if (Method == 18) {
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y5, x2, y6);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          cout << "****Draw 18 Dependencies:  P  r vs t for L7  and eta 17 18 19 20 24 26 29   **** " << endl;
          // jj   M:    0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          // :L7:  (iii=d3 & eta 17) && (iii=d4 & eta 18-25) && (iii=d5 & eta 26-28)
          // P: int LP7=0;if((iii==3 && jj==1 ) || (iii==4 && jj> 1 && jj<10) || (iii==5 && jj> 9 && jj<13)) LP7=1;
          //======================================================= introduce Layers: positive direction
          /// eta=26 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 10) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 10) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr1 = new TGraph(NP, XX, YY);
          gr1->SetLineColor(1);
          gr1->SetMarkerColor(1);
          gr1->SetMarkerStyle(20);
          gr1->SetTitle("ieta 26");
          gr1->SetFillStyle(0);
          gr1->SetMarkerSize(1.2);
          gr1->Draw("P");
          /// eta=24 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 8) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 8) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr2 = new TGraph(NP, XX, YY);
          gr2->SetLineColor(2);
          gr2->SetMarkerColor(2);
          gr2->SetMarkerStyle(20);
          gr2->SetTitle("ieta 24");
          gr2->SetFillStyle(0);
          gr2->SetMarkerSize(1.2);
          gr2->Draw("P");
          /// eta=20 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 4) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 4) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr3 = new TGraph(NP, XX, YY);
          gr3->SetLineColor(3);
          gr3->SetMarkerColor(3);
          gr3->SetMarkerStyle(20);
          gr3->SetTitle("ieta 20");
          gr3->SetFillStyle(0);
          gr3->SetMarkerSize(1.2);
          gr3->Draw("P");
          /// eta=19 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 3) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 3) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr4 = new TGraph(NP, XX, YY);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(20);
          gr4->SetTitle("ieta 19");
          gr4->SetFillStyle(0);
          gr4->SetMarkerSize(1.2);
          gr4->Draw("P");
          /// eta=18 L7=1
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
            if (LASERruns[k1] > "305874") {
              for (int iii = 3; iii < 6; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 3 && jj == 1) || (iii == 4 && jj > 1 && jj < 10) || (iii == 5 && jj > 9 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 2) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            } else {
              for (int iii = 2; iii < 4; iii++) {
                for (int jj = 1; jj < 13; jj++) {
                  int LP7 = 0;
                  if ((iii == 2 && jj > 0 && jj < 11) || (iii == 3 && jj > 10 && jj < 13))
                    LP7 = 1;
                  if (LP7 == 1 && jj == 2) {
                    YY[k1] = ZZP[k1][iii][jj];
                  }
                }
              }
            }
          }
          gr5 = new TGraph(NP, XX, YY);
          gr5->SetLineColor(5);
          gr5->SetMarkerColor(5);
          gr5->SetMarkerStyle(20);
          gr5->SetTitle("ieta 18");
          gr5->SetFillStyle(0);
          gr5->SetMarkerSize(1.2);
          gr5->Draw("P");
          /// eta=17 L7=1
          //	    for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;if(LASERruns[k1] > "305874" ) {for(int iii = 3; iii<6; iii++) {for (int jj=1;jj<13;jj++) {int LP7=0;if((iii==3 && jj==1 ) || (iii==4 && jj> 1 && jj<10) || (iii==5 && jj> 9 && jj<13)) LP7=1;if(LP7 == 1 && jj == 1)  {YY[k1] = ZZP[k1][iii][jj];} }}}else{for(int iii = 2; iii<4; iii++) {for (int jj=1;jj<13;jj++) {int LP7 = 0;if((iii==2 && jj>0 && jj<11) || (iii==3 && jj>10 && jj<13)) LP7 = 1;if(LP7 == 1 && jj == 1)  {YY[k1] = ZZP[k1][iii][jj];} }}} }
          //    gr6 = new TGraph(NP,XX,YY); gr6->SetLineColor(6); gr6->SetMarkerColor(6); gr6->SetMarkerStyle(20); gr6->SetTitle("ieta 17"); gr6->SetFillStyle(0); gr6->SetMarkerSize(1.2); gr6->Draw("P");
          //    TLegend leg(.6,.67,.78,.88, " HEP L7");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP L7");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.AddEntry(gr5);  //leg.AddEntry(gr6);leg.AddEntry(gr7);leg.AddEntry(gr8);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");
        }  //if(Method == 18
           //
        //======================================================================================================= PLOT21 r vs t positive direction:Depth3  and eta 27 28
        if (Method == 21) {
          cout << "****Draw 21 Dependencies: P   r vs t for Depth3 and some eta 27 28  *** " << endl;
          // XXE, YYE - errors
          gStyle->SetOptTitle(kFALSE);
          gStyle->SetPalette(kSolar);
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = 0.;
          }
          c1->Range(0, 0, 25, 18);
          //    c1->SetFillColor(0);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          pad1->DrawFrame(x1, y1, x2, y2);  // 1-A,
          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();
          //jj   M:     0    1   2   3   4   5   6   7   8   9   10    11    12    13      P:    0    1   2   3   4   5   6   7   8   9   10    11    12    13
          // real N:   29   28  27  26  25  24  23  22  21  20   19    18    17    16           16   17  18  19  20  21  22  23  24  25   26    27    28    29
          //                -   -       -        -   -  -                                                            -   -   -       -           -    -
          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][3][11];
            YYE[k1] = 0.01 * YY[k1];
          }  /// eta=27
          //    gr1 = new TGraph(NP,XX,YY); gr1->SetLineColor(1); gr1->SetMarkerColor(1); gr1->SetMarkerStyle(20); gr1->SetMarkerSize(1.2); gr1->SetTitle("ieta 27"); gr1->SetName("gr1");gr1->SetFillStyle(0); gr1->Draw("P");
          ge1 = new TGraphErrors(NP, XX, YY, XXE, YYE);
          ge1->SetLineColor(1);
          ge1->SetMarkerColor(1);
          ge1->SetMarkerStyle(20);
          ge1->SetMarkerSize(1.2);
          ge1->SetTitle("ieta 27");
          ge1->SetName("gr1");
          ge1->SetFillStyle(0);
          ge1->Draw("P");
          TF1 *myfit = new TF1("myfit", "[0] + [1]*x**{[2]}", 1., 2.);
          myfit->SetParName(0, "c0");
          myfit->SetParName(1, "c1");
          myfit->SetParName(2, "c2");
          myfit->SetParameter(0, 0.01);
          myfit->SetParameter(1, 1.1);
          myfit->SetParameter(2, 0.12);
          gStyle->SetOptFit(1101);
          myfit->SetLineColor(1);
          ge1->Fit("myfit");  //  OR just: "gaus" "expo" (w/ 2 parameters) "polN"  // ge1->Fit("pol5");

          for (int k1 = 0; k1 < NP; k1++) {
            YY[k1] = ZZP[k1][3][12];
            YYE[k1] = 0.01 * YY[k1];
          }  /// eta=28
          //      gr2 = new TGraph(NP,XX,YY); gr2->SetLineColor(2); gr2->SetMarkerColor(2); gr2->SetMarkerStyle(20); gr2->SetMarkerSize(1.2); gr2->SetTitle("ieta 28"); gr2->SetName("gr2"); gr2->SetFillStyle(0); gr2->Draw("P");
          ge2 = new TGraphErrors(NP, XX, YY, XXE, YYE);
          ge2->SetLineColor(2);
          ge2->SetMarkerColor(2);
          ge2->SetMarkerStyle(20);
          ge2->SetMarkerSize(1.2);
          ge2->SetTitle("ieta 28");
          ge2->SetName("ge2");
          ge2->SetFillStyle(0);
          ge2->Draw("P");
          //    TF1 *myfit = new TF1("myfit","[0] + [1]*x**{[2]}", 1., 2.);
          //    TF1 *myfit = new TF1("myfit","[0]*sin(x) + [1]*exp(-[2]*x)", 0, 2);
          TF1 *myfit2 = new TF1("myfit2", "[0]*sin(x) + [1]*exp(-[2]*x)", 0, 2);
          myfit2->SetParName(0, "c0");
          myfit2->SetParName(1, "c1");
          myfit2->SetParName(2, "c2");
          myfit2->SetParameter(0, 0.01);
          myfit2->SetParameter(1, 1.1);
          myfit2->SetParameter(2, 0.12);
          gStyle->SetOptFit(1101);
          myfit2->SetLineColor(2);
          ge2->Fit("myfit2");  //  OR just: "gaus" "expo" (w/ 2 parameters) "polN"  // ge1->Fit("pol5");

          //    TLegend leg(.5,.67,.88,.88,     "HEP Depth3");
          TLegend leg(xx1, yy1, xx2, yy2, " HEP Depth3");
          //      leg.AddEntry(gr1); leg.AddEntry(gr2);
          leg.AddEntry(ge1);
          leg.AddEntry(ge2);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");

          //            gPad->BuildLegend(.5,.67,.88,.88,"HEP L7");
          //virtual TLegend * 	BuildLegend (Double_t x1=0.5, Double_t y1=0.67, Double_t x2=0.88, Double_t y2=0.88, const char *title="", Option_t *option="")

        }  //21
        //
        //================================================================================
        //======================================================================================================= PLOT22:P: draw <Rijk>_ev.run for all runs
        if (Method == 22) {
          cout << "****Draw 22 Dependencies: P: draw <Rijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          rwithphi->SetMarkerStyle(20);
          rwithphi->SetMarkerSize(0.4);
          rwithphi->GetYaxis()->SetLabelSize(0.04);
          rwithphi->SetTitle("all runs & channels");
          rwithphi->SetXTitle("HEP <Rijk>");
          rwithphi->SetYTitle("N");
          rwithphi->SetMarkerColor(4);
          rwithphi->SetLineColor(4);
          //    rwithphi->Draw("Error");
          rwithphi->Draw("PL");
        }  //Method = 22

        //======================================================================================================= PLOT24:M: draw <Rijk>_ev.run for all runs
        if (Method == 24) {
          cout << "****Draw 24 Dependencies: M: draw <Rijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          rwithphi->SetMarkerStyle(20);
          rwithphi->SetMarkerSize(0.4);
          rwithphi->GetYaxis()->SetLabelSize(0.04);
          rwithphi->SetTitle("all runs & channels");
          rwithphi->SetXTitle("HEM <Rijk>");
          rwithphi->SetYTitle("N");
          rwithphi->SetMarkerColor(4);
          rwithphi->SetLineColor(4);
          //    rwithphi->Draw("Error");
          rwithphi->Draw("PL");
        }  //Method = 24

        //================================================================================
        //======================================================================================================= PLOT23:P:gains LED runs used
        if (Method == 23) {
          cout << "****Draw 23 Dependencies: P:gains LED runs used  *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          gainkoeff->SetMarkerStyle(20);
          gainkoeff->SetMarkerSize(0.4);
          gainkoeff->GetYaxis()->SetLabelSize(0.04);
          gainkoeff->SetTitle("all channels");
          gainkoeff->SetXTitle("gains");
          gainkoeff->SetYTitle("N");
          gainkoeff->SetMarkerColor(4);
          gainkoeff->SetLineColor(4);
          //    gainkoeff->Draw("Error");
          gainkoeff->Draw("PL");
        }  //Method = 23
        //======================================================================================================= PLOT25:P:R(Theta) Dependencies for last LASER runs for M&P
        if (Method == 25) {
          cout << "****Draw 25 R(Theta) Dependencies for last LASER runs for M&P  *** " << endl;

          //      for(int k1 = 0; k1<NP; k1++) {YY[k1]=0.;}
          c1->Range(0, 0, 25, 18);
          c1->SetFillColor(0);
          c1->Clear();
          TPad *pad1 = new TPad("pad1", "This is pad1", 0.02, 0.02, 0.98, 0.98, 0);
          pad1->Draw();
          pad1->cd();
          pad1->Range(-0.255174, -19.25, 2.29657, -6.75);
          //              x1   y1     x2     y2
          //      pad1->DrawFrame(16.,0.5,30.,1.0);  // 1-A,
          //          pad1->DrawFrame(16.,0.45,30.,1.05);  // 1-A,
          pad1->DrawFrame(16., 0.70, 30., 1.05);  // 1-A,

          //  pad1->DrawFrame(1,   0.,  370,   2.0);  // 1-A,
          pad1->GetFrame()->SetFillColor(0);
          pad1->Draw();
          gPad->SetGridy();
          gPad->SetGridx();

          //	      cout<<" L1 ***THETA 0 = " << THETA[0] <<"        THETA 12 =" << THETA[12] <<endl;
          //	      cout<<"*******RRM 0  = " << RRM[0] <<"       RRM 12  = " << RRM[12] <<endl;
          //	      cout<<"*******RRP 0  = " << RRP[0] <<"       RRP 12  = " << RRP[12] <<endl;
          gr1 = new TGraph(13, THETA, RRM);
          gr1->SetLineColor(2);
          gr1->SetMarkerColor(2);
          gr1->SetMarkerStyle(25);
          gr1->SetMarkerSize(1.5);
          gr1->SetTitle("HEM");
          gr1->SetFillStyle(0);
          gr1->Draw("PL");
          gr2 = new TGraph(13, THETA, RRP);
          gr2->SetLineColor(4);
          gr2->SetMarkerColor(4);
          gr2->SetMarkerStyle(25);
          gr2->SetMarkerSize(1.5);
          gr2->SetTitle("HEP");
          gr2->SetFillStyle(0);
          gr2->Draw("PL");

          cout << "*******THETA7 0 = " << THETA7[0] << " 1 = " << THETA7[1] << " 2= " << THETA7[2] << endl;
          cout << "*******RRM7 0 = " << RRM7[0] << " 1 = " << RRM7[1] << " 2= " << RRM7[2] << endl;

          cout << "**************************************************************************************** " << endl;

          cout << "******THETA7 9 = " << THETA7[9] << " 10 = " << THETA7[10] << " 11= " << THETA7[11] << endl;
          cout << "*******RRM7 9 = " << RRM7[9] << " 10 = " << RRM7[10] << " 11= " << RRM7[11] << endl;

          gr3 = new TGraph(11, THETA7, RRM7);
          gr3->SetLineColor(2);
          gr3->SetMarkerColor(2);
          gr3->SetMarkerStyle(26);
          gr3->SetMarkerSize(1.5);
          gr3->SetTitle("HEM");
          gr3->SetFillStyle(0);
          gr3->Draw("PL");
          gr4 = new TGraph(11, THETA7, RRP7);
          gr4->SetLineColor(4);
          gr4->SetMarkerColor(4);
          gr4->SetMarkerStyle(26);
          gr4->SetMarkerSize(1.5);
          gr4->SetTitle("HEP");
          gr4->SetFillStyle(0);
          gr4->Draw("PL");

          //	    TLegend leg(xx1,yy1,xx2,yy2,"");
          TLegend leg(xx1, yy1 + 0.1, xx2, yy2 + 0.1, " L1 & L7 ");
          leg.AddEntry(gr1);
          leg.AddEntry(gr2);
          leg.AddEntry(gr3);
          leg.AddEntry(gr4);
          leg.SetMargin(0.3);
          leg.SetBorderSize(1);
          leg.DrawClone("Same");

          /*
      cout<<"****Draw 25 R(Theta) Dependencies for last LASER runs for M&P  *** " <<endl;
      gPad->SetGridy();
      gPad->SetGridx();
      gPad->SetLogy();
      gStyle->SetOptStat(1110000); 
      gainkoeff->SetMarkerStyle(20);
      gainkoeff->SetMarkerSize(0.4);
      gainkoeff->GetYaxis()->SetLabelSize(0.04);
      gainkoeff->SetTitle("intLumi=41.3 fb-1 ");
      gainkoeff->SetXTitle("Theta  ");
      gainkoeff->SetYTitle("R for HEM & HEP");
      gainkoeff->SetMarkerColor(4);
      gainkoeff->SetLineColor(4);
      //    gainkoeff->Draw("Error");
          gainkoeff->Draw("PL");
*/

        }  //Method = 25

        //======================================================================================================= PLOT26: M: draw <RRijk>_ev.run for all runs
        if (Method == 26) {
          cout << "****Draw 26 Dependencies: M: draw <RRijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          rrwithphiM->SetMarkerStyle(20);
          rrwithphiM->SetMarkerSize(0.4);
          rrwithphiM->GetYaxis()->SetLabelSize(0.04);
          rrwithphiM->SetTitle("all runs & channels");
          rrwithphiM->SetXTitle("HEM <RRijk>");
          rrwithphiM->SetYTitle("N");
          rrwithphiM->SetMarkerColor(4);
          rrwithphiM->SetLineColor(4);
          //    rrwithphiM->Draw("Error");
          rrwithphiM->Draw("PL");
        }  //Method = 26

        //======================================================================================================= PLOT27:P: draw <RRijk>_ev.run for all runs
        if (Method == 27) {
          cout << "****Draw 27 Dependencies: P: draw <RRijk>_ev.run for all runs   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          rrwithphiP->SetMarkerStyle(20);
          rrwithphiP->SetMarkerSize(0.4);
          rrwithphiP->GetYaxis()->SetLabelSize(0.04);
          rrwithphiP->SetTitle("all runs & channels");
          rrwithphiP->SetXTitle("HEP <RRijk>");
          rrwithphiP->SetYTitle("N");
          rrwithphiP->SetMarkerColor(4);
          rrwithphiP->SetLineColor(4);
          //    rrwithphiP->Draw("Error");
          rrwithphiP->Draw("PL");
        }  //Method = 27

        //======================================================================================================= PLOT28: M:  Mean <Aijk>_ev.run for all runs
        if (Method == 28) {
          cout << "****Draw 28 Dependencies: M: Mean   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          c1->SetFillColor(0);
          //    Ceff1M->SetTitle("any Error, HE Depth1 \n");
          Ceff1M->SetMarkerStyle(20);
          Ceff1M->SetMarkerSize(0.4);
          Ceff1M->GetYaxis()->SetLabelSize(0.04);
          Ceff1M->SetTitle("M: all runs & channels");
          Ceff1M->SetXTitle("M: Mean <Aijk>");
          Ceff1M->SetYTitle("N");
          Ceff1M->SetMarkerColor(4);
          Ceff1M->SetLineColor(4);
          Ceff1M->SetMinimum(0.7);
          //    Ceff1M->Draw("Error");
          Ceff1M->Draw("PL");
        }  //Method = 28

        //======================================================================================================= PLOT29: P:  Mean  <Aijk>_ev.run for all runs
        if (Method == 29) {
          cout << "****Draw 29 Dependencies: P:Mean   *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          c1->SetFillColor(0);
          //    Ceff1M->SetTitle("any Error, HE Depth1 \n");
          Ceff1M->SetMarkerStyle(20);
          Ceff1M->SetMarkerSize(0.4);
          Ceff1M->GetYaxis()->SetLabelSize(0.04);
          Ceff1M->SetTitle("P: all runs & channels");
          Ceff1M->SetXTitle("P: Mean <Aijk>");
          Ceff1M->SetYTitle("N");
          Ceff1M->SetMarkerColor(4);
          Ceff1M->SetLineColor(4);
          Ceff1M->SetMinimum(0.7);
          //    Ceff1M->Draw("Error");
          Ceff1M->Draw("PL");
        }  //Method = 29

        //======================================================================================================= PLOT30: M  PHI dependence
        if (Method == 30) {
          cout << "****Draw 30 Dependencies:M   PHI   *** " << endl;
          phidepdrawing30->Divide(phidependenceM, phidependenceM0, 1, 1, "B");
          phidepdrawing30->Sumw2();
          gPad->SetGridy();
          gPad->SetGridx();  //gStyle->SetOptStat(0000000);
          gPad->SetLogy(0);
          phidepdrawing30->SetMarkerStyle(20);
          phidepdrawing30->SetMarkerSize(1.4);
          phidepdrawing30->GetYaxis()->SetLabelSize(0.04);
          phidepdrawing30->SetXTitle("Phi");
          phidepdrawing30->SetYTitle("RR");
          phidepdrawing30->SetMarkerColor(2);
          phidepdrawing30->SetLineColor(2);
          phidepdrawing30->Draw("Error");

        }  //Method = 30

        //======================================================================================================= PLOT31: P  PHI dependence
        if (Method == 31) {
          cout << "****Draw 31 Dependencies:P   PHI   *** " << endl;
          phidepdrawing31->Divide(phidependenceP, phidependenceP0, 1, 1, "B");
          phidepdrawing31->Sumw2();
          gPad->SetGridy();
          gPad->SetGridx();  //gStyle->SetOptStat(0000000);
          gPad->SetLogy(0);
          phidepdrawing31->SetMarkerStyle(20);
          phidepdrawing31->SetMarkerSize(1.4);
          phidepdrawing31->GetYaxis()->SetLabelSize(0.04);
          phidepdrawing31->SetXTitle("Phi");
          phidepdrawing31->SetYTitle("RR");
          phidepdrawing31->SetMarkerColor(4);
          phidepdrawing31->SetLineColor(4);
          phidepdrawing31->Draw("Error");

        }  //Method = 31

        //======================================================================================================= PLOT32: M:  RMS <Aijk>_ev.run for all runs
        if (Method == 32) {
          cout << "****Draw 32 Dependencies: M:RMS    *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          c1->SetFillColor(0);
          Ceff1R->SetMarkerStyle(20);
          Ceff1R->SetMarkerSize(0.4);
          Ceff1R->GetYaxis()->SetLabelSize(0.04);
          Ceff1R->SetTitle("M: all runs & channels");
          Ceff1R->SetXTitle("M: RMS <Aijk>");
          Ceff1R->SetYTitle("N");
          Ceff1R->SetMarkerColor(4);
          Ceff1R->SetLineColor(4);
          Ceff1R->SetMinimum(0.7);
          Ceff1R->Draw("PL");
        }  //Method = 32

        //======================================================================================================= PLOT33: P:  RMS <Aijk>_ev.run for all runs
        if (Method == 33) {
          cout << "****Draw 33 Dependencies: P:RMS    *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy();
          gStyle->SetOptStat(1110000);
          c1->SetFillColor(0);
          Ceff1R->SetMarkerStyle(20);
          Ceff1R->SetMarkerSize(0.4);
          Ceff1R->GetYaxis()->SetLabelSize(0.04);
          Ceff1R->SetTitle("P: all runs & channels");
          Ceff1R->SetXTitle("P: RMS <Aijk>");
          Ceff1R->SetYTitle("N");
          Ceff1R->SetMarkerColor(4);
          Ceff1R->SetLineColor(4);
          Ceff1R->SetMinimum(0.7);
          Ceff1R->Draw("PL");
        }  //Method = 33

        //================================================================================
        //======================================================================================================= PLOT34:P:IntLumi fb-1 vs. Days
        if (Method == 34) {
          cout << "****Draw 34 P:IntLumi fb-1 vs. Days  *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy(0);
          gStyle->SetOptStat(000000000);
          lumiplot->GetOption();
          lumiplot->SetMarkerStyle(20);
          lumiplot->SetMarkerSize(0.4);
          lumiplot->GetYaxis()->SetLabelSize(0.04);
          lumiplot->SetXTitle("days");
          lumiplot->SetYTitle("IntLumi fb-1");
          lumiplot->SetMarkerColor(4);
          lumiplot->SetLineColor(4);
          lumiplot->SetMinimum(0.);
          lumiplot->SetMaximum(170.);
          //      gStyle->SetErrorX(0);
          lumiplot->Draw("hist PL");
        }  //Method = 34
        //================================================================================
        //======================================================================================================= PLOT35:P:IntLumi fb-1 vs. Days (up to 171)
        if (Method == 35) {
          cout << "****Draw 35 P:IntLumi fb-1 vs. Days (up to 171) *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy(0);
          gStyle->SetOptStat(000000000);
          lumiplot1->GetOption();
          lumiplot1->SetMarkerStyle(20);
          lumiplot1->SetMarkerSize(0.4);
          lumiplot1->GetYaxis()->SetLabelSize(0.04);
          lumiplot1->SetXTitle("days");
          lumiplot1->SetYTitle("IntLumi fb-1");
          lumiplot1->SetMarkerColor(4);
          lumiplot1->SetLineColor(4);
          lumiplot1->SetMinimum(0.);
          lumiplot1->SetMaximum(45.);
          //      gStyle->SetErrorX(0);
          lumiplot1->Draw("hist PL");
        }  //Method = 35
        //================================================================================
        //======================================================================================================= PLOT36:P:IntLumi fb-1 vs. Days (2017 only)
        if (Method == 36) {
          cout << "****Draw 36 P:IntLumi fb-1 vs. Days (2017 only) *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy(0);
          gStyle->SetOptStat(000000000);
          lumiplot2->GetOption();
          lumiplot2->SetMarkerStyle(20);
          lumiplot2->SetMarkerSize(0.4);
          lumiplot2->GetYaxis()->SetLabelSize(0.04);
          lumiplot2->SetXTitle("days");
          lumiplot2->SetYTitle("IntLumi fb-1");
          lumiplot2->SetMarkerColor(4);
          lumiplot2->SetLineColor(4);
          lumiplot2->SetMinimum(0.);
          lumiplot2->SetMaximum(55.);
          //      gStyle->SetErrorX(0);
          lumiplot2->Draw("hist PL");
        }  //Method = 36
        //================================================================================
        //======================================================================================================= PLOT37:P:IntLumi fb-1 vs. Days (2018 only)
        if (Method == 37) {
          cout << "****Draw 37 P:IntLumi fb-1 vs. Days (2018 only) *** " << endl;
          gPad->SetGridy();
          gPad->SetGridx();
          gPad->SetLogy(0);
          gStyle->SetOptStat(000000000);
          lumiplot3->GetOption();
          lumiplot3->SetMarkerStyle(20);
          lumiplot3->SetMarkerSize(0.4);
          lumiplot3->GetYaxis()->SetLabelSize(0.04);
          lumiplot3->SetXTitle("days");
          lumiplot3->SetYTitle("IntLumi fb-1");
          lumiplot3->SetMarkerColor(4);
          lumiplot3->SetLineColor(4);
          lumiplot3->SetMinimum(0.);
          lumiplot3->SetMaximum(75.);
          //      gStyle->SetErrorX(0);
          lumiplot3->Draw("hist PL");
        }  //Method = 37
        //================================================================================
        //====================================================================================================================================================
        //================================================================================

        // L1: (iii=d1 & eta 17-29);
        // M: int LM1 = 0;if((iii==1 && jj<13)) LM1 = 1;
        // P: int LP1 = 0;if((iii==1 && jj> 0)) LP1 = 1;

        // :L7:  (iii=d2 & eta 17-26) && (iii=d3 & eta 27-28)
        // M: int LM7=0;if((iii==2 && jj>3 && jj<13) || (iii==3 && jj> 1 && jj< 4)) LM7=1;
        // P: int LP7=0;if((iii==2 && jj>0 && jj<11) || (iii==3 && jj>10 && jj<13)) LP7=1;

        //=======================================================================================================
        //======================================================================================================= finish loop over Methods
        //=======================================================================================================
        TString fdir = "amt2019raddam/";
        //
        TString plotName = fdir + MethodName[Method] + ".png";
        c1->SaveAs(plotName);
        cout << "****PLOT " << Method << " drawn **** " << endl;

      }  //if( Method != 9
      ++Method;
    }  // loop over Methods
    //=======================================================================================================
  }  // loop over directions
  //=======================================================================================================
  // // // // // // // additional plots:
  // // // // // // // additional plots:
  // // // // // // // additional plots:
  TString fdir = "amt2019raddam/";
  //=============================================  PLOT100
  //  gStyle->SetOptStat(0000000);
  phidepdrawing30->Draw("Error");
  //  gStyle->SetOptStat(0000000);
  phidepdrawing31->Draw("ErrorSame");
  TString plotName = fdir + "PLOT100.png";
  c1->SaveAs(plotName);
  cout << "****PLOT " << 100 << " drawn **** " << endl;
  //=============================================  PLOT101
  gStyle->SetOptStat(1110000);
  phiRRM->SetMarkerStyle(20);
  phiRRM->SetMarkerSize(1.4);
  phiRRM->GetYaxis()->SetLabelSize(0.04);
  phiRRM->SetXTitle("RR");
  phiRRM->SetYTitle("N");
  phiRRM->SetMarkerColor(2);
  phiRRM->SetLineColor(2);
  phiRRM->Draw("Error");
  phiRRP->SetMarkerStyle(20);
  phiRRP->SetMarkerSize(1.4);
  phiRRP->GetYaxis()->SetLabelSize(0.04);
  phiRRP->SetXTitle("RR");
  phiRRP->SetYTitle("N");
  phiRRP->SetMarkerColor(4);
  phiRRP->SetLineColor(4);
  phiRRP->Draw("ErrorSame");
  plotName = fdir + "PLOT101.png";
  c1->SaveAs(plotName);
  cout << "****PLOT " << 101 << " drawn **** " << endl;
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //=======================================================================================================
  //______________________________________________________________________________
  //______________________________________________________________________________
  //
  //______________________________________________________________________________
  //______________________________________________________________________________
  //
  gSystem->Exit(0);
  //______________________________________________________________________________
}
//______________________________________________________________________________
