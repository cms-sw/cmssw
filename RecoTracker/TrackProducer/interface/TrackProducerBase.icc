#include "RecoTracker/TrackProducer/interface/TrackProducerBase.h"

/// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include <FWCore/Utilities/interface/ESInputTag.h>

#include "MagneticField/Engine/interface/MagneticField.h"
#include "Geometry/TrackerGeometryBuilder/interface/TrackerGeometry.h"
#include "Geometry/Records/interface/TrackerDigiGeometryRecord.h"
#include "MagneticField/Records/interface/IdealMagneticFieldRecord.h" 
#include "TrackingTools/Records/interface/TrackingComponentsRecord.h" 
#include "TrackingTools/TrackFitters/interface/TrajectoryFitterRecord.h" 
#include "TrackingTools/Records/interface/TransientRecHitRecord.h" 

#include "TrackingTools/TrackFitters/interface/TrajectoryFitter.h"
#include "TrackingTools/GeomPropagators/interface/Propagator.h"

#include "DataFormats/Common/interface/AssociationMap.h"

#include "TrackingTools/DetLayers/interface/NavigationSchool.h"
#include "RecoTracker/Record/interface/NavigationSchoolRecord.h"
// #include "TrackingTools/DetLayers/interface/NavigationSetter.h"

#include <TrackingTools/KalmanUpdators/interface/Chi2MeasurementEstimator.h>
#include <TrackingTools/DetLayers/interface/GeometricSearchDet.h> 
#include <RecoTracker/MeasurementDet/interface/MeasurementTracker.h>
#include <RecoTracker/MeasurementDet/interface/MeasurementTrackerEvent.h>
#include <TrackingTools/MeasurementDet/interface/MeasurementDet.h>
#include "RecoTracker/Record/interface/CkfComponentsRecord.h"

#include "DataFormats/DetId/interface/DetId.h"

//destructor
template <class T>
TrackProducerBase<T>::~TrackProducerBase() noexcept(false) { }

// member functions
// ------------ method called to produce the data  ------------

template <class T> void 
TrackProducerBase<T>::getFromES(const edm::EventSetup& setup,
				  edm::ESHandle<TrackerGeometry>& theG,
				  edm::ESHandle<MagneticField>& theMF,
				  edm::ESHandle<TrajectoryFitter>& theFitter,
				  edm::ESHandle<Propagator>& thePropagator,
				  edm::ESHandle<MeasurementTracker>& theMeasTk,
				  edm::ESHandle<TransientTrackingRecHitBuilder>& theBuilder)
{
  //
  //get geometry
  //
  LogDebug("TrackProducer") << "get geometry" << "\n";
  setup.get<TrackerDigiGeometryRecord>().get(theG);
  //
  //get magnetic field
  //
  LogDebug("TrackProducer") << "get magnetic field" << "\n";
  // 2014/02/11 mia:
  // we should get rid of the boolean parameter useSimpleMF,
  // and use only a string magneticField [instead of SimpleMagneticField]
  // or better an edm::ESInputTag (at the moment HLT does not handle ESInputTag)
  bool useSimpleMF = false;
  if (conf_.exists("useSimpleMF")) useSimpleMF = conf_.getParameter<bool>("useSimpleMF");
  std::string mfName = "";			
  if (useSimpleMF){
     mfName = conf_.getParameter<std::string>("SimpleMagneticField"); 
  }
  setup.get<IdealMagneticFieldRecord>().get(mfName, theMF);  
  //  edm::ESInputTag mfESInputTag(mfName);
  //  setup.get<IdealMagneticFieldRecord>().get(mfESInputTag, theMF);  

  //
  // get the fitter from the ES
  //
  LogDebug("TrackProducer") << "get the fitter from the ES" << "\n";
  std::string fitterName = conf_.getParameter<std::string>("Fitter");   
  setup.get<TrajectoryFitter::Record>().get(fitterName,theFitter);
  //
  // get also the propagator
  //
  LogDebug("TrackProducer") << "get also the propagator" << "\n";
  std::string propagatorName = conf_.getParameter<std::string>("Propagator");   
  setup.get<TrackingComponentsRecord>().get(propagatorName,thePropagator);

  //
  // get the builder
  //
  LogDebug("TrackProducer") << "get also the TransientTrackingRecHitBuilder" << "\n";
  std::string builderName = conf_.getParameter<std::string>("TTRHBuilder");   
  setup.get<TransientRecHitRecord>().get(builderName,theBuilder);

  //
  // get also the measurementTracker and the NavigationSchool 
  // (they are necessary to fill in the secondary hit patterns)
  //

  LogDebug("TrackProducer") << "get a navigation school";
  std::string theNavigationSchool ="";
  if (conf_.exists("NavigationSchool")) theNavigationSchool= conf_.getParameter<std::string>("NavigationSchool");
  else edm::LogWarning("TrackProducerBase")<<" NavigationSchool parameter not set. secondary hit pattern will not be filled.";
  if (theNavigationSchool!=""){
    setup.get<NavigationSchoolRecord>().get(theNavigationSchool, theSchool);
    LogDebug("TrackProducer") << "get also the measTk" << "\n";
    std::string measTkName = conf_.getParameter<std::string>("MeasurementTracker");
    setup.get<CkfComponentsRecord>().get(measTkName,theMeasTk);
  }
  else{
    theSchool = edm::ESHandle<NavigationSchool>(); //put an invalid handle
    theMeasTk = edm::ESHandle<MeasurementTracker>(); //put an invalid handle
  }
}

template <class T> void
TrackProducerBase<T>::getFromEvt(edm::Event& theEvent,edm::Handle<TrackCandidateCollection>& theTCCollection, reco::BeamSpot& bs)
{
  //		
  //get the TrackCandidateCollection from the event
  //
  LogDebug("TrackProducer") << 
  	"get the TrackCandidateCollection from the event, source is " << conf_.getParameter<edm::InputTag>( "src" ) <<"\n";
  theEvent.getByToken(src_,theTCCollection );  

  //get the BeamSpot
  edm::Handle<reco::BeamSpot> recoBeamSpotHandle;
  theEvent.getByToken(bsSrc_,recoBeamSpotHandle);
  if ( recoBeamSpotHandle.isValid() )
    bs = *recoBeamSpotHandle;
  else 
    edm::LogWarning("TrackProducerBase") << " BeamSpot is not valid";
}

template <class T> void
TrackProducerBase<T>::getFromEvt(edm::Event& theEvent,edm::Handle<TrackView>& theTCollection, reco::BeamSpot& bs)
{
  //
  //get the TrackCollection from the event
  //
  LogDebug("TrackProducer") << 
  	"get the TrackCollection from the event, source is " << conf_.getParameter<edm::InputTag>( "src" ) <<"\n";
  theEvent.getByToken(src_,theTCollection );  

  //get the BeamSpot
  edm::Handle<reco::BeamSpot> recoBeamSpotHandle;
  theEvent.getByToken(bsSrc_,recoBeamSpotHandle);
  if ( recoBeamSpotHandle.isValid() )
    bs = *recoBeamSpotHandle;
  else 
    edm::LogWarning("TrackProducerBase") << " BeamSpot is not valid";
}

#include <TrackingTools/DetLayers/interface/DetLayer.h>
#include <DataFormats/TrackingRecHit/interface/InvalidTrackingRecHit.h>

template <class T> void
TrackProducerBase<T>::setSecondHitPattern(Trajectory* traj, T& track, 
					  const Propagator* prop, const MeasurementTrackerEvent* measTk,
                                          const TrackerTopology* ttopo){
  using namespace std;
  /// have to clone the propagator in order to change its propagation direction.
  std::unique_ptr<Propagator> localProp(prop->clone());

  //use negative sigma=-3.0 in order to use a more conservative definition of isInside() for Bounds classes.
  Chi2MeasurementEstimator estimator(30.,-3.0,0.5,2.0,0.5,1.e12);  // same as defauts....

  // WARNING: At the moment the trajectories has the measurements with reversed sorting after the track smoothing. 
  // Therefore the lastMeasurement is the inner one (for LHC-like tracks)
  if(!traj->firstMeasurement().updatedState().isValid() ||
      !traj->lastMeasurement().updatedState().isValid()) return;

    const FreeTrajectoryState*  outerState = traj->firstMeasurement().updatedState().freeState();    
    const FreeTrajectoryState*  innerState = traj->lastMeasurement().updatedState().freeState(); 
    TrajectoryStateOnSurface const & outerTSOS = traj->firstMeasurement().updatedState();
    TrajectoryStateOnSurface const & innerTSOS = traj->lastMeasurement().updatedState();
    const DetLayer* outerLayer = traj->firstMeasurement().layer();
    const DetLayer* innerLayer = traj->lastMeasurement().layer();

    if (!outerLayer || !innerLayer){
      //means  that the trajectory was fit/smoothed in a special case: not setting those pointers
	edm::LogError("TrackProducer") << "the trajectory was fit/smoothed in a special case: not setting those pointers.\n"
			<<" Filling the secondary hit patterns was requested. So I will bail out.";
	throw cms::Exception("TrackProducerBase")<<"the trajectory was fit/smoothed in a special case: not setting those pointers.\n"
			<<" Filling the secondary hit patterns was requested. So I will bail out.";
    }
    
    //WARNING: we are assuming that the hits were originally sorted along momentum (and therefore oppositeToMomentum after smoothing)
    PropagationDirection dirForInnerLayers = oppositeToMomentum;
    PropagationDirection dirForOuterLayers = alongMomentum;
    auto outIn = traj->direction() != oppositeToMomentum;
    if(outIn){
	dirForInnerLayers = alongMomentum;
	dirForOuterLayers = oppositeToMomentum;
        // std::cout << "Iin setSecondHitPattern() logic. Trajectory direction (after smoothing) was not oppositeToMomentum. .. algo= " << track.algo() << std::endl;
    }
    // ----------- this previous block of code is not very safe. It should rely less on the sorting of the trajectory measurements -----

   
    // Now all code looks as InOut in particular names
    // we will take care of OutIn only where it matters (MISSING_INNER vs _OUTER)
    
    LogDebug("TrackProducer") << "calling inner compLayers()...";
    auto const & innerCompLayers = (*theSchool).compatibleLayers(*innerLayer,*innerState,dirForInnerLayers);
    LogDebug("TrackProducer") << "calling outer compLayers()...";
    auto const & outerCompLayers = (*theSchool).compatibleLayers(*outerLayer,*outerState,dirForOuterLayers);

    LogDebug("TrackProducer")
      << "inner DetLayer  sub: " 
      << innerLayer->subDetector() <<"\n"
      << "outer DetLayer  sub: " 
      << outerLayer->subDetector() << "\n"
      << "innerstate position rho: " << innerState->position().perp() << " z: "<< innerState->position().z()<<"\n"
      << "innerstate state pT: " << innerState->momentum().perp() << " pz: "<< innerState->momentum().z()<<"\n"
      << "outerstate position rho: " << outerState->position().perp() << " z: "<< outerState->position().z()<<"\n"
      << "outerstate state pT: " << outerState->momentum().perp() << " pz: "<< outerState->momentum().z()<<"\n"

      << "innerLayers: " << innerCompLayers.size() << "\n"
      << "outerLayers: " << outerCompLayers.size() << "\n";


    auto loopOverLayer = [&](decltype(innerCompLayers) compLayers, TrajectoryStateOnSurface const & tsos) {
      for(auto it : compLayers){
        if (it->basicComponents().empty()) {
	        //this should never happen. but better protect for it
	        edm::LogWarning("TrackProducer")<<"a detlayer with no components: I cannot figure out a DetId from this layer. please investigate.";
	        continue;
        }
        auto const & detWithState = it->compatibleDets(tsos,*localProp,estimator);
        if(!detWithState.size()) continue;
        DetId id = detWithState.front().first->geographicalId();
        MeasurementDetWithData measDet = measTk->idToDet(id);
        //if(measDet->isActive() && !measDet->hasBadComponents(detWithState.front().second)){
        if(measDet.isActive()){ 
	        InvalidTrackingRecHit tmpHit(*detWithState.front().first, outIn ? TrackingRecHit::missing_outer : TrackingRecHit::missing_inner);
	        track.appendHitPattern(tmpHit, *ttopo);
	        //cout << "WARNING: this hit is marked as lost because the detector was marked as active" << endl;
        }else{
	        //cout << "WARNING: this hit is NOT marked as lost because the detector was marked as inactive" << endl;
        }
      } //end loop over layers
    }; // end lambda

   localProp->setPropagationDirection(oppositeToMomentum);
   loopOverLayer(innerCompLayers,innerTSOS);

   localProp->setPropagationDirection(alongMomentum);
   outIn = !outIn;  // if inOut should mark missing_outer
   loopOverLayer(outerCompLayers,outerTSOS);

}


