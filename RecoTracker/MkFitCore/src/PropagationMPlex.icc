///////////////////////////////////////////////////////////////////////////////
/// helixAtRFromIterativeCCS_impl
///////////////////////////////////////////////////////////////////////////////

//#define DEBUG
//#include "Debug.h"

template <typename Tf, typename TfLL1, typename Tf1>
static inline void parsFromPathL_impl(const Tf& __restrict__ inPar,
                                      TfLL1& __restrict__ outPar,
                                      const float* kinv,
                                      const Tf1& __restrict__ s,
                                      const int nmin,
                                      const int nmax) {
  float alpha[nmax - nmin];
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = s[n - nmin] * std::sin(inPar(n, 5, 0)) * inPar(n, 3, 0) * kinv[n - nmin];
  }

  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
    }
  } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
    for (int n = nmin; n < nmax; ++n) {
      cosah[n - nmin] = std::cos(alpha[n - nmin] * 0.5f);
      sinah[n - nmin] = std::sin(alpha[n - nmin] * 0.5f);
    }
  }

  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 0, 0) =
        inPar(n, 0, 0) + 2.f * sinah[n - nmin] *
                             (std::cos(inPar(n, 4, 0)) * cosah[n - nmin] - std::sin(inPar(n, 4, 0)) * sinah[n - nmin]) /
                             (inPar(n, 3, 0) * kinv[n - nmin]);
    outPar(n, 1, 0) =
        inPar(n, 1, 0) + 2.f * sinah[n - nmin] *
                             (std::sin(inPar(n, 4, 0)) * cosah[n - nmin] + std::cos(inPar(n, 4, 0)) * sinah[n - nmin]) /
                             (inPar(n, 3, 0) * kinv[n - nmin]);
    outPar(n, 2, 0) = inPar(n, 2, 0) + alpha[n - nmin] / kinv[n - nmin] * std::cos(inPar(n, 5, 0)) /
                                           (inPar(n, 3, 0) * std::sin(inPar(n, 5, 0)));
    outPar(n, 3, 0) = inPar(n, 3, 0);
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    outPar(n, 5, 0) = inPar(n, 5, 0);
  }
}

//should kinv and D be templated???
template <typename Tf, typename Ti, typename TfLL1, typename TfLLL, typename Tf1>
inline void parsAndErrPropFromPathL_impl(const Tf& __restrict__ inPar,
                                         const Ti& __restrict__ inChg,
                                         TfLL1& __restrict__ outPar,
                                         const float* kinv,
                                         const Tf1& __restrict__ s,
                                         TfLLL& __restrict__ errorProp,
                                         const int nmin,
                                         const int nmax,
                                         const int N_proc,
                                         const PropagationFlags& pf) {
  //iteration should return the path length s, then update parameters and compute errors

  parsFromPathL_impl(inPar, outPar, kinv, s, nmin, nmax);

  float cosPin[nmax - nmin];
  float sinPin[nmax - nmin];
  float cosPout[nmax - nmin];
  float sinPout[nmax - nmin];
  float cosT[nmax - nmin];
  float sinT[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPin[n - nmin] = std::cos(inPar(n, 4, 0));
    sinPin[n - nmin] = std::sin(inPar(n, 4, 0));
    cosPout[n - nmin] = std::cos(outPar(n, 4, 0));
    sinPout[n - nmin] = std::sin(outPar(n, 4, 0));
    cosT[n - nmin] = std::cos(inPar(n, 5, 0));
    sinT[n - nmin] = std::sin(inPar(n, 5, 0));
  }

  // use code from AnalyticalCurvilinearJacobian::computeFullJacobian for error propagation in curvilinear coordinates, then convert to CCS
  // main difference from the above function is that we assume that the magnetic field is purely along z (which also implies that there is no change in pz)
  // this simplifies significantly the code

  MPlex55 errorPropCurv;
  for (int n = nmin; n < nmax; ++n) {
    const float qbp = inChg(n, 0, 0) * sinT[n - nmin] * inPar(n, 3, 0);
    // calculate transport matrix
    // Origin: TRPRFN
    const float t11 = cosPin[n - nmin] * sinT[n - nmin];
    const float t12 = sinPin[n - nmin] * sinT[n - nmin];
    const float t21 = cosPout[n - nmin] * sinT[n - nmin];
    const float t22 = sinPout[n - nmin] * sinT[n - nmin];
    const float cosl1 = 1.f / sinT[n - nmin];
    // define average magnetic field and gradient
    // at initial point - inlike TRPRFN
    const float bF =
        (pf.use_param_b_field
             ? 0.01f * Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), hipo(inPar(n, 0, 0), inPar(n, 1, 0)))
             : 0.01f * Const::sol * Config::Bfield);
    const float q = -bF * qbp;
    const float theta = q * s[n - nmin];
    //float sint, cost;
    //vdt::fast_sincos(theta, sint, cost);
    const float sint = std::sin(theta);
    const float cost = std::cos(theta);
    const float dx1 = inPar(n, 0, 0) - outPar(n, 0, 0);
    const float dx2 = inPar(n, 1, 0) - outPar(n, 1, 0);
    const float dx3 = inPar(n, 2, 0) - outPar(n, 2, 0);
    float au = 1.f / sqrt(t11 * t11 + t12 * t12);
    const float u11 = -au * t12;
    const float u12 = au * t11;
    const float v11 = -cosT[n - nmin] * u12;
    const float v12 = cosT[n - nmin] * u11;
    const float v13 = t11 * u12 - t12 * u11;
    au = 1.f / sqrt(t21 * t21 + t22 * t22);
    const float u21 = -au * t22;
    const float u22 = au * t21;
    const float v21 = -cosT[n - nmin] * u22;
    const float v22 = cosT[n - nmin] * u21;
    const float v23 = t21 * u22 - t22 * u21;
    // now prepare the transport matrix
    const float omcost = 1.f - cost;
    const float tmsint = theta - sint;
    //   1/p - doesn't change since |p1| = |p2|
    errorPropCurv(n, 0, 0) = 1.f;
    for (auto i = 1; i < 5; ++i)
      errorPropCurv(n, 0, i) = 0.f;
    //   lambda
    errorPropCurv(n, 1, 0) = 0.f;
    errorPropCurv(n, 1, 1) =
        cost * (v11 * v21 + v12 * v22 + v13 * v23) + sint * (-v12 * v21 + v11 * v22) + omcost * v13 * v23;
    errorPropCurv(n, 1, 2) = (cost * (u11 * v21 + u12 * v22) + sint * (-u12 * v21 + u11 * v22)) * sinT[n - nmin];
    errorPropCurv(n, 1, 3) = 0.f;
    errorPropCurv(n, 1, 4) = 0.f;
    //   phi
    errorPropCurv(n, 2, 0) = bF * v23 * (t21 * dx1 + t22 * dx2 + cosT[n - nmin] * dx3) * cosl1;
    errorPropCurv(n, 2, 1) = (cost * (v11 * u21 + v12 * u22) + sint * (-v12 * u21 + v11 * u22) +
                              v23 * (-sint * (v11 * t21 + v12 * t22 + v13 * cosT[n - nmin]) +
                                     omcost * (-v11 * t22 + v12 * t21) - tmsint * cosT[n - nmin] * v13)) *
                             cosl1;
    errorPropCurv(n, 2, 2) = (cost * (u11 * u21 + u12 * u22) + sint * (-u12 * u21 + u11 * u22) +
                              v23 * (-sint * (u11 * t21 + u12 * t22) + omcost * (-u11 * t22 + u12 * t21))) *
                             cosl1 * sinT[n - nmin];
    errorPropCurv(n, 2, 3) = -q * v23 * (u11 * t21 + u12 * t22) * cosl1;
    errorPropCurv(n, 2, 4) = -q * v23 * (v11 * t21 + v12 * t22 + v13 * cosT[n - nmin]) * cosl1;
    //   yt
    float cutCriterion = fabs(s[n - nmin] * sinT[n - nmin] * inPar(n, 3, 0));
    const float limit = 5.f;  // valid for propagations with effectively float precision
    if (cutCriterion > limit) {
      const float pp = 1.f / qbp;
      errorPropCurv(n, 3, 0) = pp * (u21 * dx1 + u22 * dx2);
      errorPropCurv(n, 4, 0) = pp * (v21 * dx1 + v22 * dx2 + v23 * dx3);
    } else {
      const float temp1 = -t12 * u21 + t11 * u22;
      const float s2 = s[n - nmin] * s[n - nmin];
      const float secondOrder41 = -0.5f * bF * temp1 * s2;
      const float temp2 = -t11 * u21 - t12 * u22;
      const float s3 = s2 * s[n - nmin];
      const float s4 = s3 * s[n - nmin];
      const float h2 = bF * bF;
      const float h3 = h2 * bF;
      const float qbp2 = qbp * qbp;
      const float thirdOrder41 = 1.f / 3 * h2 * s3 * qbp * temp2;
      const float fourthOrder41 = 1.f / 8 * h3 * s4 * qbp2 * temp1;
      errorPropCurv(n, 3, 0) = secondOrder41 + (thirdOrder41 + fourthOrder41);
      const float temp3 = -t12 * v21 + t11 * v22;
      const float secondOrder51 = -0.5f * bF * temp3 * s2;
      const float temp4 = -t11 * v21 - t12 * v22 - cosT[n - nmin] * v23;
      const float thirdOrder51 = 1.f / 3 * h2 * s3 * qbp * temp4;
      const float fourthOrder51 = 1.f / 8 * h3 * s4 * qbp2 * temp3;
      errorPropCurv(n, 4, 0) = secondOrder51 + (thirdOrder51 + fourthOrder51);
    }
    errorPropCurv(n, 3, 1) = (sint * (v11 * u21 + v12 * u22) + omcost * (-v12 * u21 + v11 * u22)) / q;
    errorPropCurv(n, 3, 2) = (sint * (u11 * u21 + u12 * u22) + omcost * (-u12 * u21 + u11 * u22)) * sinT[n - nmin] / q;
    errorPropCurv(n, 3, 3) = (u11 * u21 + u12 * u22);
    errorPropCurv(n, 3, 4) = (v11 * u21 + v12 * u22);
    //   zt
    errorPropCurv(n, 4, 1) =
        (sint * (v11 * v21 + v12 * v22 + v13 * v23) + omcost * (-v12 * v21 + v11 * v22) + tmsint * v23 * v13) / q;
    errorPropCurv(n, 4, 2) = (sint * (u11 * v21 + u12 * v22) + omcost * (-u12 * v21 + u11 * v22)) * sinT[n - nmin] / q;
    errorPropCurv(n, 4, 3) = (u11 * v21 + u12 * v22);
    errorPropCurv(n, 4, 4) = (v11 * v21 + v12 * v22 + v13 * v23);

  }  //end loop over n

//debug = true;
#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": errorPropCurv" << std::endl;
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 0, 0),
             errorPropCurv(n, 0, 1),
             errorPropCurv(n, 0, 2),
             errorPropCurv(n, 0, 3),
             errorPropCurv(n, 0, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 1, 0),
             errorPropCurv(n, 1, 1),
             errorPropCurv(n, 1, 2),
             errorPropCurv(n, 1, 3),
             errorPropCurv(n, 1, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 2, 0),
             errorPropCurv(n, 2, 1),
             errorPropCurv(n, 2, 2),
             errorPropCurv(n, 2, 3),
             errorPropCurv(n, 2, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 3, 0),
             errorPropCurv(n, 3, 1),
             errorPropCurv(n, 3, 2),
             errorPropCurv(n, 3, 3),
             errorPropCurv(n, 3, 4));
      printf("%5f %5f %5f %5f %5f\n",
             errorPropCurv(n, 4, 0),
             errorPropCurv(n, 4, 1),
             errorPropCurv(n, 4, 2),
             errorPropCurv(n, 4, 3),
             errorPropCurv(n, 4, 4));
      printf("\n");
    }
  }
#endif

  //now we need jacobians to convert to/from curvilinear and CCS
  // code from TrackState::jacobianCCSToCurvilinear
  MPlex56 jacCCS2Curv;
  for (int n = nmin; n < nmax; ++n) {
    for (int ii = 0; ii < 5; ii++) {
      for (int jj = 0; jj < 6; jj++) {
        jacCCS2Curv(n, ii, jj) = 0.f;
      }
    }
    jacCCS2Curv(n, 0, 3) = inChg(n, 0, 0) * sinT[n - nmin];
    jacCCS2Curv(n, 0, 5) = inChg(n, 0, 0) * cosT[n - nmin] * inPar(n, 3, 0);
    jacCCS2Curv(n, 1, 5) = -1.f;
    jacCCS2Curv(n, 2, 4) = 1.f;
    jacCCS2Curv(n, 3, 0) = -sinPin[n - nmin];
    jacCCS2Curv(n, 3, 1) = cosPin[n - nmin];
    jacCCS2Curv(n, 4, 0) = -cosPin[n - nmin] * cosT[n - nmin];
    jacCCS2Curv(n, 4, 1) = -sinPin[n - nmin] * cosT[n - nmin];
    jacCCS2Curv(n, 4, 2) = sinT[n - nmin];
  }

  // code from TrackState::jacobianCurvilinearToCCS
  MPlex65 jacCurv2CCS;
  for (int n = nmin; n < nmax; ++n) {
    for (int ii = 0; ii < 6; ii++) {
      for (int jj = 0; jj < 5; jj++) {
        jacCurv2CCS(n, ii, jj) = 0.f;
      }
    }

    jacCurv2CCS(n, 0, 3) = -sinPout[n - nmin];
    jacCurv2CCS(n, 0, 4) = -cosT[n - nmin] * cosPout[n - nmin];
    jacCurv2CCS(n, 1, 3) = cosPout[n - nmin];
    jacCurv2CCS(n, 1, 4) = -cosT[n - nmin] * sinPout[n - nmin];
    jacCurv2CCS(n, 2, 4) = sinT[n - nmin];
    jacCurv2CCS(n, 3, 0) = inChg(n, 0, 0) / sinT[n - nmin];
    jacCurv2CCS(n, 3, 1) = outPar(n, 3, 0) * cosT[n - nmin] / sinT[n - nmin];
    jacCurv2CCS(n, 4, 2) = 1.f;
    jacCurv2CCS(n, 5, 1) = -1.f;
  }

  //need to compute errorProp = jacCurv2CCS*errorPropCurv*jacCCS2Curv
  Matriplex::MPlex<float, 6, 5, NN> tmp;
  Matriplex::multiplyGeneral(jacCurv2CCS, errorPropCurv, tmp);
  Matriplex::multiplyGeneral(tmp, jacCCS2Curv, errorProp);
}

// from P.Avery's notes (http://www.phys.ufl.edu/~avery/fitting/transport.pdf eq. 5)
inline float getS(float delta0,
                  float delta1,
                  float delta2,
                  float eta0,
                  float eta1,
                  float eta2,
                  float sinP,
                  float cosP,
                  float sinT,
                  float cosT,
                  float pt,
                  int q,
                  float kinv) {
  float A = delta0 * eta0 + delta1 * eta1 + delta2 * eta2;
  float ip = sinT / pt;
  float p0[3] = {pt * cosP, pt * sinP, cosT / ip};
  float B = (p0[0] * eta0 + p0[1] * eta1 + p0[2] * eta2) * ip;
  float rho = kinv * ip;
  float C = (eta0 * p0[1] - eta1 * p0[0]) * rho * 0.5f * ip;
  float sqb2m4ac = std::sqrt(B * B - 4.f * A * C);
  float s1 = (-B + sqb2m4ac) * 0.5f / C;
  float s2 = (-B - sqb2m4ac) * 0.5f / C;
#ifdef DEBUG
  if (debug)
    std::cout << "A=" << A << " B=" << B << " C=" << C << " s1=" << s1 << " s2=" << s2 << std::endl;
#endif
  //take the closest
  return (std::abs(s1) > std::abs(s2) ? s2 : s1);
}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL, typename Tf1>
static inline void helixAtPlane_impl(const Tf& __restrict__ inPar,
                                     const Ti& __restrict__ inChg,
                                     const Tf11& __restrict__ plPnt,
                                     const Tf11& __restrict__ plNrm,
                                     Tf1& __restrict__ s,
                                     TfLL1& __restrict__ outPar,
                                     TfLLL& __restrict__ errorProp,
                                     Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                     const int nmin,
                                     const int nmax,
                                     const int N_proc,
                                     const PropagationFlags& pf) {
  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      kinv[n - nmin] = inChg(n, 0, 0) * 0.01f *
                       (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), hipo(inPar(n, 0, 0), inPar(n, 1, 0))));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      kinv[n - nmin] = inChg(n, 0, 0) * 0.01f * (-Const::sol * Config::Bfield);
    }
  }

  float delta0[nmax - nmin];
  float delta1[nmax - nmin];
  float delta2[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    delta0[n - nmin] = inPar(n, 0, 0) - plPnt(n, 0, 0);
    delta1[n - nmin] = inPar(n, 1, 0) - plPnt(n, 1, 0);
    delta2[n - nmin] = inPar(n, 2, 0) - plPnt(n, 2, 0);
  }

  float sinP[nmax - nmin];
  float cosP[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinP[n - nmin] = std::sin(inPar(n, 4, 0));
    cosP[n - nmin] = std::cos(inPar(n, 4, 0));
  }

  // determine solution for straight line
  float sl[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //sl[n - nmin] = - ( plNrm(n, 0, 0)*delta0[n - nmin] + plNrm(n, 1, 0)*delta1[n - nmin] + plNrm(n, 2, 0)*delta2[n - nmin] ) / ( plNrm(n, 0, 0)*cosP[n - nmin]/inPar(n,3,0) + plNrm(n, 1, 0)*sinP[n - nmin]/inPar(n,3,0) + plNrm(n, 2, 0)*std::cos(inPar(n,5,0))/std::sin(inPar(n,5,0))/inPar(n,3,0) );
    sl[n - nmin] =
        -(plNrm(n, 0, 0) * delta0[n - nmin] + plNrm(n, 1, 0) * delta1[n - nmin] + plNrm(n, 2, 0) * delta2[n - nmin]) /
        (plNrm(n, 0, 0) * cosP[n - nmin] * std::sin(inPar(n, 5, 0)) +
         plNrm(n, 1, 0) * sinP[n - nmin] * std::sin(inPar(n, 5, 0)) + plNrm(n, 2, 0) * std::cos(inPar(n, 5, 0)));
  }

  //float s[nmax - nmin];
  //first iteration outside the loop
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    s[n - nmin] = (std::abs(plNrm(n, 2, 0)) < 1.f
                       ? getS(delta0[n - nmin],
                              delta1[n - nmin],
                              delta2[n - nmin],
                              plNrm(n, 0, 0),
                              plNrm(n, 1, 0),
                              plNrm(n, 2, 0),
                              sinP[n - nmin],
                              cosP[n - nmin],
                              std::sin(inPar(n, 5, 0)),
                              std::cos(inPar(n, 5, 0)),
                              inPar(n, 3, 0),
                              inChg(n, 0, 0),
                              kinv[n - nmin])
                       : (plPnt.constAt(n, 2, 0) - inPar.constAt(n, 2, 0)) / std::cos(inPar.constAt(n, 5, 0)));
  }

  MPlexLV outParTmp;

  CMS_UNROLL_LOOP_COUNT(Config::Niter - 1)
  for (int i = 0; i < Config::Niter - 1; ++i) {
    parsFromPathL_impl(inPar, outParTmp, kinv, s, nmin, nmax);

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      delta0[n - nmin] = outParTmp(n, 0, 0) - plPnt(n, 0, 0);
      delta1[n - nmin] = outParTmp(n, 1, 0) - plPnt(n, 1, 0);
      delta2[n - nmin] = outParTmp(n, 2, 0) - plPnt(n, 2, 0);
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sinP[n - nmin] = std::sin(outParTmp(n, 4, 0));
      cosP[n - nmin] = std::cos(outParTmp(n, 4, 0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      s[n - nmin] += (std::abs(plNrm(n, 2, 0)) < 1.f ? getS(delta0[n - nmin],
                                                            delta1[n - nmin],
                                                            delta2[n - nmin],
                                                            plNrm(n, 0, 0),
                                                            plNrm(n, 1, 0),
                                                            plNrm(n, 2, 0),
                                                            sinP[n - nmin],
                                                            cosP[n - nmin],
                                                            std::sin(inPar(n, 5, 0)),
                                                            std::cos(inPar(n, 5, 0)),
                                                            inPar(n, 3, 0),
                                                            inChg(n, 0, 0),
                                                            kinv[n - nmin])
                                                     : (plPnt.constAt(n, 2, 0) - outParTmp.constAt(n, 2, 0)) /
                                                           std::cos(outParTmp.constAt(n, 5, 0)));
    }
  }  //end Niter-1

  // use linear approximation if s did not converge (for very high pT tracks)
  for (int n = nmin; n < nmax; ++n) {
#ifdef DEBUG
    if (debug)
      std::cout << "s[n - nmin]=" << s[n - nmin] << " sl[n - nmin]=" << sl[n - nmin]
                << " std::isnan(s[n - nmin])=" << std::isnan(s[n - nmin])
                << " std::isfinite(s[n - nmin])=" << std::isfinite(s[n - nmin])
                << " std::isnormal(s[n - nmin])=" << std::isnormal(s[n - nmin]) << std::endl;
#endif
    if ((std::abs(sl[n - nmin]) > std::abs(s[n - nmin])) || std::isnormal(s[n - nmin]) == false)
      s[n - nmin] = sl[n - nmin];
  }

#ifdef DEBUG
  if (debug)
    std::cout << "s=" << s[0] << std::endl;
#endif
  parsAndErrPropFromPathL_impl(inPar, inChg, outPar, kinv, s, errorProp, nmin, nmax, N_proc, pf);
}

template <typename Tf, typename Ti, typename TfLL1, typename Tf11, typename TfLLL>
static inline void helixAtRFromIterativeCCS_impl(const Tf& __restrict__ inPar,
                                                 const Ti& __restrict__ inChg,
                                                 const Tf11& __restrict__ msRad,
                                                 TfLL1& __restrict__ outPar,
                                                 TfLLL& __restrict__ errorProp,
                                                 Ti& __restrict__ outFailFlag,  // expected to be initialized to 0
                                                 const int nmin,
                                                 const int nmax,
                                                 const int N_proc,
                                                 const PropagationFlags& pf) {
  // bool debug = true;

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    errorProp(n, 0, 0) = 1.f;
    errorProp(n, 1, 1) = 1.f;
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 4, 4) = 1.f;
    errorProp(n, 5, 5) = 1.f;
  }
  float r0[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //initialize erroProp to identity matrix
    r0[n - nmin] = hipo(inPar(n, 0, 0), inPar(n, 1, 0));
  }
  float k[nmax - nmin];
  if (pf.use_param_b_field) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::bFieldFromZR(inPar(n, 2, 0), r0[n - nmin]));
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      k[n - nmin] = inChg(n, 0, 0) * 100.f / (-Const::sol * Config::Bfield);
    }
  }
  float r[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    r[n - nmin] = msRad(n, 0, 0);
  }
  float xin[nmax - nmin];
  float yin[nmax - nmin];
  float ipt[nmax - nmin];
  float phiin[nmax - nmin];
  float theta[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    // if (std::abs(r-r0)<0.0001f) {
    // 	dprint("distance less than 1mum, skip");
    // 	continue;
    // }

    xin[n - nmin] = inPar(n, 0, 0);
    yin[n - nmin] = inPar(n, 1, 0);
    ipt[n - nmin] = inPar(n, 3, 0);
    phiin[n - nmin] = inPar(n, 4, 0);
    theta[n - nmin] = inPar(n, 5, 0);

    //dprint(std::endl);
  }

  //debug = true;
  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "input parameters"
                  << " inPar(n, 0, 0)=" << std::setprecision(9) << inPar(n, 0, 0) << " inPar(n, 1, 0)="
                  << std::setprecision(9) << inPar(n, 1, 0) << " inPar(n, 2, 0)=" << std::setprecision(9)
                  << inPar(n, 2, 0) << " inPar(n, 3, 0)=" << std::setprecision(9) << inPar(n, 3, 0)
                  << " inPar(n, 4, 0)=" << std::setprecision(9) << inPar(n, 4, 0)
                  << " inPar(n, 5, 0)=" << std::setprecision(9) << inPar(n, 5, 0));
  }

  float kinv[nmax - nmin];
  float pt[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    kinv[n - nmin] = 1.f / k[n - nmin];
    pt[n - nmin] = 1.f / ipt[n - nmin];
  }
  float D[nmax - nmin];
  float cosa[nmax - nmin];
  float sina[nmax - nmin];
  float cosah[nmax - nmin];
  float sinah[nmax - nmin];
  float id[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    D[n - nmin] = 0.;
  }

  //no trig approx here, phi can be large
  float cosPorT[nmax - nmin];
  float sinPorT[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    cosPorT[n - nmin] = std::cos(phiin[n - nmin]);
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(phiin[n - nmin]);
  }

  float pxin[nmax - nmin];
  float pyin[nmax - nmin];
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    pxin[n - nmin] = cosPorT[n - nmin] * pt[n - nmin];
    pyin[n - nmin] = sinPorT[n - nmin] * pt[n - nmin];
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "k=" << std::setprecision(9) << k[n - nmin] << " pxin=" << std::setprecision(9) << pxin[n - nmin]
                   << " pyin=" << std::setprecision(9) << pyin[n - nmin] << " cosPorT=" << std::setprecision(9)
                   << cosPorT[n - nmin] << " sinPorT=" << std::setprecision(9) << sinPorT[n - nmin]
                   << " pt=" << std::setprecision(9) << pt[n - nmin]);
  }

  float dDdx[nmax - nmin];
  float dDdy[nmax - nmin];
  float dDdipt[nmax - nmin];
  float dDdphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdipt[n - nmin] = 0.;
    dDdphi[n - nmin] = 0.;
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //derivatives initialized to value for first iteration, i.e. distance = r-r0in
    dDdx[n - nmin] = r0[n - nmin] > 0.f ? -xin[n - nmin] / r0[n - nmin] : 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    dDdy[n - nmin] = r0[n - nmin] > 0.f ? -yin[n - nmin] / r0[n - nmin] : 0.f;
  }

  float oodotp[nmax - nmin];
  float x[nmax - nmin];
  float y[nmax - nmin];
  float oor0[nmax - nmin];
  float dadipt[nmax - nmin];
  float dadx[nmax - nmin];
  float dady[nmax - nmin];
  float pxca[nmax - nmin];
  float pxsa[nmax - nmin];
  float pyca[nmax - nmin];
  float pysa[nmax - nmin];
  float tmp[nmax - nmin];
  float tmpx[nmax - nmin];
  float tmpy[nmax - nmin];
  float pxinold[nmax - nmin];

  CMS_UNROLL_LOOP_COUNT(Config::Niter)
  for (int i = 0; i < Config::Niter; ++i) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //compute distance and path for the current iteration
      r0[n - nmin] = hipo(outPar(n, 0, 0), outPar(n, 1, 0));
    }

    // Use one over dot product of transverse momentum and radial
    // direction to scale the step. Propagation is prevented from reaching
    // too close to the apex (dotp > 0.2).
    // - Can / should we come up with a better approximation?
    // - Can / should take +/- curvature into account?

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      oodotp[n - nmin] =
          r0[n - nmin] * pt[n - nmin] / (pxin[n - nmin] * outPar(n, 0, 0) + pyin[n - nmin] * outPar(n, 1, 0));
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      if (oodotp[n - nmin] > 5.0f || oodotp[n - nmin] < 0)  // 0.2 is 78.5 deg
      {
        outFailFlag(n, 0, 0) = 1;
        oodotp[n - nmin] = 0.0f;
      } else if (r[n - nmin] - r0[n - nmin] < 0.0f && pt[n - nmin] < 1.0f) {
        // Scale down the correction for low-pT ingoing tracks.
        oodotp[n - nmin] = 1.0f + (oodotp[n - nmin] - 1.0f) * pt[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      // Can we come up with a better approximation?
      // Should take +/- curvature into account.
      id[n - nmin] = (r[n - nmin] - r0[n - nmin]) * oodotp[n - nmin];
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      D[n - nmin] += id[n - nmin];
    }

    if constexpr (Config::useTrigApprox) {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        sincos4(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f, sinah[n - nmin], cosah[n - nmin]);
      }
    } else {
#if !defined(__INTEL_COMPILER)
#pragma omp simd
#endif
      for (int n = nmin; n < nmax; ++n) {
        cosah[n - nmin] = std::cos(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
        sinah[n - nmin] = std::sin(id[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * 0.5f);
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = 1.f - 2.f * sinah[n - nmin] * sinah[n - nmin];
      sina[n - nmin] = 2.f * sinah[n - nmin] * cosah[n - nmin];
    }

    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "Attempt propagation from r="
                    << r0[n - nmin] << " to r=" << r[n - nmin] << std::endl
                    << "   x=" << xin[n - nmin] << " y=" << yin[n - nmin] << " z=" << inPar(n, 2, 0)
                    << " px=" << pxin[n - nmin] << " py=" << pyin[n - nmin]
                    << " pz=" << pt[n - nmin] * std::tan(theta[n - nmin]) << " q=" << inChg(n, 0, 0) << std::endl
                    << "   r=" << std::setprecision(9) << r[n - nmin] << " r0=" << std::setprecision(9) << r0[n - nmin]
                    << " id=" << std::setprecision(9) << id[n - nmin] << " dr=" << std::setprecision(9)
                    << r[n - nmin] - r0[n - nmin] << " cosa=" << cosa[n - nmin] << " sina=" << sina[n - nmin]
                    << " dir_cos(rad,pT)=" << 1.0f / oodotp[n - nmin]);
    }

    //update derivatives on total distance
    if (i + 1 != Config::Niter) {
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        x[n - nmin] = outPar(n, 0, 0);
        y[n - nmin] = outPar(n, 1, 0);
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        oor0[n - nmin] =
            (r0[n - nmin] > 0.f && std::abs(r[n - nmin] - r0[n - nmin]) > 0.0001f) ? 1.f / r0[n - nmin] : 0.f;
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dadipt[n - nmin] = id[n - nmin] * kinv[n - nmin];
        dadx[n - nmin] = -x[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        dady[n - nmin] = -y[n - nmin] * ipt[n - nmin] * kinv[n - nmin] * oor0[n - nmin];
        pxca[n - nmin] = pxin[n - nmin] * cosa[n - nmin];
        pxsa[n - nmin] = pxin[n - nmin] * sina[n - nmin];
        pyca[n - nmin] = pyin[n - nmin] * cosa[n - nmin];
        pysa[n - nmin] = pyin[n - nmin] * sina[n - nmin];
        tmpx[n - nmin] = k[n - nmin] * dadx[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdx[n - nmin] -= (x[n - nmin] * (1.f + tmpx[n - nmin] * (pxca[n - nmin] - pysa[n - nmin])) +
                           y[n - nmin] * tmpx[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin])) *
                          oor0[n - nmin];
      }

#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        tmpy[n - nmin] = k[n - nmin] * dady[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdy[n - nmin] -= (x[n - nmin] * tmpy[n - nmin] * (pxca[n - nmin] - pysa[n - nmin]) +
                           y[n - nmin] * (1.f + tmpy[n - nmin] * (pyca[n - nmin] + pxsa[n - nmin]))) *
                          oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        //now r0 depends on ipt and phi as well
        tmp[n - nmin] = dadipt[n - nmin] * ipt[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdipt[n - nmin] -= k[n - nmin] *
                            (x[n - nmin] * (pxca[n - nmin] * tmp[n - nmin] - pysa[n - nmin] * tmp[n - nmin] -
                                            pyca[n - nmin] - pxsa[n - nmin] + pyin[n - nmin]) +
                             y[n - nmin] * (pyca[n - nmin] * tmp[n - nmin] + pxsa[n - nmin] * tmp[n - nmin] -
                                            pysa[n - nmin] + pxca[n - nmin] - pxin[n - nmin])) *
                            pt[n - nmin] * oor0[n - nmin];
      }
#pragma omp simd
      for (int n = nmin; n < nmax; ++n) {
        dDdphi[n - nmin] += k[n - nmin] *
                            (x[n - nmin] * (pysa[n - nmin] - pxin[n - nmin] + pxca[n - nmin]) -
                             y[n - nmin] * (pxsa[n - nmin] - pyin[n - nmin] + pyca[n - nmin])) *
                            oor0[n - nmin];
      }
    }

#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      //update parameters
      outPar(n, 0, 0) = outPar(n, 0, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pxin[n - nmin] * cosah[n - nmin] - pyin[n - nmin] * sinah[n - nmin]);
      outPar(n, 1, 0) = outPar(n, 1, 0) + 2.f * k[n - nmin] * sinah[n - nmin] *
                                              (pyin[n - nmin] * cosah[n - nmin] + pxin[n - nmin] * sinah[n - nmin]);
      pxinold[n - nmin] = pxin[n - nmin];  //copy before overwriting
      pxin[n - nmin] = pxin[n - nmin] * cosa[n - nmin] - pyin[n - nmin] * sina[n - nmin];
      pyin[n - nmin] = pyin[n - nmin] * cosa[n - nmin] + pxinold[n - nmin] * sina[n - nmin];
    }
    for (int n = nmin; n < nmax; ++n) {
      dprint_np(n,
                "outPar(n, 0, 0)=" << outPar(n, 0, 0) << " outPar(n, 1, 0)=" << outPar(n, 1, 0)
                                   << " pxin=" << pxin[n - nmin] << " pyin=" << pyin[n - nmin]);
    }
  }  // iteration loop

  float alpha[nmax - nmin];
  float dadphi[nmax - nmin];

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    alpha[n - nmin] = D[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadx[n - nmin] = dDdx[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dady[n - nmin] = dDdy[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
    dadipt[n - nmin] = (ipt[n - nmin] * dDdipt[n - nmin] + D[n - nmin]) * kinv[n - nmin];
    dadphi[n - nmin] = dDdphi[n - nmin] * ipt[n - nmin] * kinv[n - nmin];
  }

  if constexpr (Config::useTrigApprox) {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      sincos4(alpha[n - nmin], sina[n - nmin], cosa[n - nmin]);
    }
  } else {
#pragma omp simd
    for (int n = nmin; n < nmax; ++n) {
      cosa[n - nmin] = std::cos(alpha[n - nmin]);
      sina[n - nmin] = std::sin(alpha[n - nmin]);
    }
  }
#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 0, 0) = 1.f + k[n - nmin] * dadx[n - nmin] *
                                   (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 0, 1) = k[n - nmin] * dady[n - nmin] *
                         (cosPorT[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 0, 2) = 0.f;
    errorProp(n, 0, 3) =
        k[n - nmin] *
        (cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         sinPorT[n - nmin] * ((1.f - cosa[n - nmin]) - ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin])) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 0, 4) =
        k[n - nmin] *
        (cosPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] - sinPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] -
         sinPorT[n - nmin] * sina[n - nmin] + cosPorT[n - nmin] * cosa[n - nmin] - cosPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 0, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    errorProp(n, 1, 0) = k[n - nmin] * dadx[n - nmin] *
                         (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) * pt[n - nmin];
    errorProp(n, 1, 1) = 1.f + k[n - nmin] * dady[n - nmin] *
                                   (sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin]) *
                                   pt[n - nmin];
    errorProp(n, 1, 2) = 0.f;
    errorProp(n, 1, 3) =
        k[n - nmin] *
        (sinPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * cosa[n - nmin] - sina[n - nmin]) +
         cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] * sina[n - nmin] - (1.f - cosa[n - nmin]))) *
        pt[n - nmin] * pt[n - nmin];
    errorProp(n, 1, 4) =
        k[n - nmin] *
        (sinPorT[n - nmin] * dadphi[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * dadphi[n - nmin] * sina[n - nmin] +
         sinPorT[n - nmin] * cosa[n - nmin] + cosPorT[n - nmin] * sina[n - nmin] - sinPorT[n - nmin]) *
        pt[n - nmin];
    errorProp(n, 1, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //no trig approx here, theta can be large
    cosPorT[n - nmin] = std::cos(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    sinPorT[n - nmin] = std::sin(theta[n - nmin]);
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    //redefine sinPorT as 1./sinPorT to reduce the number of temporaries
    sinPorT[n - nmin] = 1.f / sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 2, 0) =
        inPar(n, 2, 0) + k[n - nmin] * alpha[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 0) = k[n - nmin] * cosPorT[n - nmin] * dadx[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 1) = k[n - nmin] * cosPorT[n - nmin] * dady[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 2) = 1.f;
    errorProp(n, 2, 3) = k[n - nmin] * cosPorT[n - nmin] * (ipt[n - nmin] * dadipt[n - nmin] - alpha[n - nmin]) *
                         pt[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 4) = k[n - nmin] * dadphi[n - nmin] * cosPorT[n - nmin] * pt[n - nmin] * sinPorT[n - nmin];
    errorProp(n, 2, 5) = -k[n - nmin] * alpha[n - nmin] * pt[n - nmin] * sinPorT[n - nmin] * sinPorT[n - nmin];
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 3, 0) = ipt[n - nmin];
    errorProp(n, 3, 0) = 0.f;
    errorProp(n, 3, 1) = 0.f;
    errorProp(n, 3, 2) = 0.f;
    errorProp(n, 3, 3) = 1.f;
    errorProp(n, 3, 4) = 0.f;
    errorProp(n, 3, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 4, 0) = inPar(n, 4, 0) + alpha[n - nmin];
    errorProp(n, 4, 0) = dadx[n - nmin];
    errorProp(n, 4, 1) = dady[n - nmin];
    errorProp(n, 4, 2) = 0.f;
    errorProp(n, 4, 3) = dadipt[n - nmin];
    errorProp(n, 4, 4) = 1.f + dadphi[n - nmin];
    errorProp(n, 4, 5) = 0.f;
  }

#pragma omp simd
  for (int n = nmin; n < nmax; ++n) {
    outPar(n, 5, 0) = theta[n - nmin];
    errorProp(n, 5, 0) = 0.f;
    errorProp(n, 5, 1) = 0.f;
    errorProp(n, 5, 2) = 0.f;
    errorProp(n, 5, 3) = 0.f;
    errorProp(n, 5, 4) = 0.f;
    errorProp(n, 5, 5) = 1.f;
  }

  for (int n = nmin; n < nmax; ++n) {
    dprint_np(n,
              "propagation end, dump parameters\n"
                  << "   D = " << D[n - nmin] << " alpha = " << alpha[n - nmin] << " kinv = " << kinv[n - nmin]
                  << std::endl
                  << "   pos = " << outPar(n, 0, 0) << " " << outPar(n, 1, 0) << " " << outPar(n, 2, 0) << "\t\t r="
                  << std::sqrt(outPar(n, 0, 0) * outPar(n, 0, 0) + outPar(n, 1, 0) * outPar(n, 1, 0)) << std::endl
                  << "   mom = " << outPar(n, 3, 0) << " " << outPar(n, 4, 0) << " " << outPar(n, 5, 0) << std::endl
                  << "   cart= " << std::cos(outPar(n, 4, 0)) / outPar(n, 3, 0) << " "
                  << std::sin(outPar(n, 4, 0)) / outPar(n, 3, 0) << " " << 1. / (outPar(n, 3, 0) * tan(outPar(n, 5, 0)))
                  << "\t\tpT=" << 1. / std::abs(outPar(n, 3, 0)) << std::endl);
  }

#ifdef DEBUG
  for (int n = nmin; n < nmax; ++n) {
    if (debug && g_debug && n < N_proc) {
      dmutex_guard;
      std::cout << n << ": jacobian" << std::endl;
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 0, 0),
             errorProp(n, 0, 1),
             errorProp(n, 0, 2),
             errorProp(n, 0, 3),
             errorProp(n, 0, 4),
             errorProp(n, 0, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 1, 0),
             errorProp(n, 1, 1),
             errorProp(n, 1, 2),
             errorProp(n, 1, 3),
             errorProp(n, 1, 4),
             errorProp(n, 1, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 2, 0),
             errorProp(n, 2, 1),
             errorProp(n, 2, 2),
             errorProp(n, 2, 3),
             errorProp(n, 2, 4),
             errorProp(n, 2, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 3, 0),
             errorProp(n, 3, 1),
             errorProp(n, 3, 2),
             errorProp(n, 3, 3),
             errorProp(n, 3, 4),
             errorProp(n, 3, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 4, 0),
             errorProp(n, 4, 1),
             errorProp(n, 4, 2),
             errorProp(n, 4, 3),
             errorProp(n, 4, 4),
             errorProp(n, 4, 5));
      printf("%5f %5f %5f %5f %5f %5f\n",
             errorProp(n, 5, 0),
             errorProp(n, 5, 1),
             errorProp(n, 5, 2),
             errorProp(n, 5, 3),
             errorProp(n, 5, 4),
             errorProp(n, 5, 5));
      printf("\n");
    }
  }
#endif
}
