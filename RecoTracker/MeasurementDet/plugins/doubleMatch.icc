

namespace {  

  template<typename Collector>
  struct CollectorHelper {

    Collector & m_collector;
    GlobalVector const & glbDir;

    CollectorHelper(Collector & i_collector,  GlobalVector const & i_glbDir) : 
      m_collector(i_collector), glbDir(i_glbDir) {}
    
    inline static SiStripRecHit2D const & monoHit(TkGluedMeasurementDet::RecHitContainer::const_iterator monoHit) {
      return *reinterpret_cast<const SiStripRecHit2D*>((**monoHit).hit());
    }
    
    inline static SiStripRecHit2D const & stereoHit(std::vector<SiStripRecHit2D>::const_iterator iter) {
      return *iter;
    }

    inline static SiStripRecHit2D const & stereoHit(TkGluedMeasurementDet::RecHitContainer::const_iterator hit) {
      return *reinterpret_cast<const SiStripRecHit2D*>((**hit).hit());
    }

    typename Collector::Collector & collector() { return m_collector.collector();}
    
    inline void closure( TkGluedMeasurementDet::RecHitContainer::const_iterator monoHit) {
      if (m_collector.hasNewMatchedHits()) {
	m_collector.clearNewMatchedHitsFlag();
      } else {
	m_collector.addProjected( **monoHit, glbDir );
      }
    }
    
  };

}

#include "TrackingTools/GeomPropagators/interface/AnalyticalPropagator.h"
#include "RecHitPropagator.h"

namespace {
  void print(const char* where, const TrajectoryStateOnSurface& t1,const TrajectoryStateOnSurface& t2) {
    std::cout << where<< std::endl;
    std::cout <<  t1.localParameters().vector() << std::endl;
    std::cout <<  t1.localError().positionError() << std::endl;
    std::cout <<  t2.localParameters().vector() << std::endl;
    std::cout <<  t2.localError().positionError() << std::endl;

  }


}


template<typename Collector>
void TkGluedMeasurementDet::doubleMatch(const TrajectoryStateOnSurface& ts, Collector & collector) const {


  GlobalVector glbDir = (ts.isValid() ? ts.globalParameters().momentum() : position()-GlobalPoint(0,0,0));
 
 //  static SiStripRecHitMatcher::SimpleHitCollection vsStereoHits;
  // vsStereoHits.resize(simpleSteroHitsByValue.size());
  //std::transform(simpleSteroHitsByValue.begin(), simpleSteroHitsByValue.end(), vsStereoHits.begin(), take_address());

  RecHitContainer monoHits;
  RecHitContainer stereoHits;
  std::vector<float>  diffs;

  auto mf = monoHits.size();
  auto sf = stereoHits.size();

  const MagneticField& field = ts.globalParameters().magneticField();
  AnalyticalPropagator prop( &field, anyDirection);


  
  if (collector.filter()) {
    TrajectoryStateOnSurface mts = prop.propagate(ts,theMonoDet->surface());
    if (mts.isValid()) {
      theMonoDet->recHits(mts,collector.estimator(),monoHits,diffs); 
      TrajectoryStateOnSurface mts2 = fastProp(ts,geomDet().surface(),theMonoDet->geomDet().surface());
      print("mono", mts,mts2);
    }
    mf = monoHits.size();
  }
#ifndef MATCH_COUNT
  else
#endif
    monoHits = theMonoDet->recHits( ts);

  diffs.clear();
  if (collector.filter()) {
    TrajectoryStateOnSurface mts = prop.propagate( ts, theStereoDet->surface());
    if (mts.isValid()) {
      theStereoDet->recHits(mts,collector.estimator(),stereoHits,diffs);
      TrajectoryStateOnSurface mts2 = fastProp(ts,geomDet().surface(),theStereoDet->geomDet().surface());
      print("stereo", mts,mts2);
    }
    sf = stereoHits.size();
  }
#ifndef MATCH_COUNT
  else
#endif
    stereoHits= theStereoDet->recHits( ts);

  if unlikely(stereoHits.empty()) {
      // make mono TTRHs and project them
      projectOnGluedDet( collector, theMonoDet->recHits(ts), glbDir);
      return;
  }

  if unlikely(monoHits.empty()) {
      // make stereo TTRHs and project them
      projectOnGluedDet( collector, theStereoDet->recHits(ts), glbDir);
      return;
  }


  /*
  // collect simple stereo hits
  static std::vector<SiStripRecHit2D> simpleSteroHitsByValue;
  simpleSteroHitsByValue.clear();
  theStereoDet->simpleRecHits(ts, simpleSteroHitsByValue);
  if (simpleSteroHitsByValue.empty()) {
    projectOnGluedDet( collector, monoHits, glbDir);
    return;
  }

  */

  const GluedGeomDet* gluedDet = &specificGeomDet();
  LocalVector trdir = (ts.isValid() ? ts.localDirection() : surface().toLocal( position()-GlobalPoint(0,0,0)));

  CollectorHelper<Collector> chelper(collector, glbDir);
  theMatcher->doubleMatch(monoHits.begin(), monoHits.end(),
			  stereoHits.begin(), stereoHits.end(),
			  // simpleSteroHitsByValue.begin(),  simpleSteroHitsByValue.end(), 
			  gluedDet, trdir, chelper);
 

  if (collector.filter()) {
    auto mh = monoHits.size();
    auto sh = stereoHits.size();
    stat(mh,sh,collector.size(),mf,sf);
  }

  //  simpleSteroHitsByValue.clear();
   
}
   
