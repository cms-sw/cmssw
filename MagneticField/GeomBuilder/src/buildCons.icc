/*
 *  Compute parameters for a cone section 
 *
 *  \author N. Amapane - INFN Torino
 */

#include "DataFormats/GeometrySurface/interface/SimpleConeBounds.h"

void volumeHandle::buildCons() {
  LogTrace("magneticfield::volumeHandle") << "Building cons surfaces...: ";

  DDCons cons(solid);

  // Old DD needs mm to cm conversion, but DD4hep needs no conversion.
  // convertUnits should be defined appropriately.
  double zhalf = convertUnits(cons.zhalf());
  double rInMinusZ = convertUnits(cons.rInMinusZ());
  double rOutMinusZ = convertUnits(cons.rOutMinusZ());
  double rInPlusZ = convertUnits(cons.rInPlusZ());
  double rOutPlusZ = convertUnits(cons.rOutPlusZ());
  double startPhi = cons.phiFrom();
  double deltaPhi = cons.deltaPhi();

  LogTrace("magneticfield::volumeHandle")
      << "zhalf      " << zhalf << newln << "rInMinusZ  " << rInMinusZ << newln << "rOutMinusZ " << rOutMinusZ << newln
      << "rInPlusZ   " << rInPlusZ << newln << "rOutPlusZ  " << rOutPlusZ << newln << "phiFrom    " << startPhi << newln
      << "deltaPhi   " << deltaPhi;

  // recalculate center: (for a DDCons, DDD gives 0,0,Z)
  double rZmin = (rInMinusZ + rOutMinusZ) / 2.;
  double rZmax = (rInPlusZ + rOutPlusZ) / 2.;
  double rCentr = (rZmin + rZmax) / 2.;
  Geom::Phi<double> phiCenter(startPhi + deltaPhi / 2.);
  center_ = refPlane->toGlobal(LocalPoint(rCentr * cos(phiCenter), rCentr * sin(phiCenter), 0.));
  // For cons and tubs RN = R.
  theRN = rCentr;

  const double epsilon = 1e-5;

  if (std::abs(rInPlusZ - rInMinusZ) < epsilon) {  // Cylinder
    // FIXME: use builder
    surfaces[inner] = new Cylinder(rInMinusZ, Surface::PositionType(), Surface::RotationType());

  } else {  // Cone
    // FIXME: trick to compute vertex and angle...
    SimpleConeBounds cb(center_.z() - zhalf, rInMinusZ, rInMinusZ, center_.z() + zhalf, rInPlusZ, rInPlusZ);

    surfaces[inner] =
        new Cone(Surface::PositionType(0, 0, center_.z()), Surface::RotationType(), cb.vertex(), cb.openingAngle());
  }
  if (std::abs(rOutPlusZ - rOutMinusZ) < epsilon) {  // Cylinder
    surfaces[outer] = new Cylinder(rOutMinusZ, Surface::PositionType(0, 0, center_.z()), Surface::RotationType());
  } else {  // Cone
    // FIXME: trick to compute vertex and angle...
    SimpleConeBounds cb(center_.z() - zhalf, rOutMinusZ, rOutMinusZ, center_.z() + zhalf, rOutPlusZ, rOutPlusZ);

    surfaces[outer] =
        new Cone(Surface::PositionType(0, 0, center_.z()), Surface::RotationType(), cb.vertex(), cb.openingAngle());

    LogTrace("magneticfield::volumeHandle")
        << "Outer surface: cone, vtx: " << cb.vertex() << " angle " << cb.openingAngle();
  }
  // All other surfaces
  buildPhiZSurf(startPhi, deltaPhi, zhalf, rCentr);

  // Save volume boundaries
  theRMin = min(rInMinusZ, rInPlusZ);
  theRMax = max(rOutMinusZ, rOutPlusZ);
  thePhiMin = surfaces[phiminus]->position().phi();
}
