void volumeHandle::buildTubs() {
  LogTrace("magneticfield::volumeHandle") << "Building tubs surfaces...: ";

  DDTubs tubs(solid);

  // Old DD needs mm to cm conversion, but DD4hep needs no conversion.
  // convertUnits should be defined appropriately.
  double zhalf = convertUnits(tubs.zhalf());
  double rIn = convertUnits(tubs.rIn());
  double rOut = convertUnits(tubs.rOut());
  double startPhi = tubs.startPhi();
  double deltaPhi = tubs.deltaPhi();

  LogTrace("magneticfield::volumeHandle")
      << "zhalf    " << zhalf << newln << "rIn      " << rIn << newln << "rOut     " << rOut << newln << "startPhi "
      << startPhi << newln << "deltaPhi " << deltaPhi;

  // recalculate center: (for a DDTubs, DDD gives 0,0,Z)
  double rCentr = (rIn + rOut) / 2.;
  Geom::Phi<double> phiCenter(startPhi + deltaPhi / 2.);
  center_ = refPlane->toGlobal(LocalPoint(rCentr * cos(phiCenter), rCentr * sin(phiCenter), 0.));
  // For cons and tubs RN = R.
  theRN = rCentr;

  // FIXME: use builder
  surfaces[outer] = new Cylinder(rOut, Surface::PositionType(0, 0, center_.z()), Surface::RotationType());

  // The inner cylider may be degenreate. Not easy to have a null surface
  // in the current implementation (surfaces[inner] is a RCP!)

  surfaces[inner] = new Cylinder(rIn, Surface::PositionType(0, 0, center_.z()), Surface::RotationType());

  // All other surfaces
  buildPhiZSurf(startPhi, deltaPhi, zhalf, rCentr);

  // Check ordering.
  if (debug) {
    if (dynamic_cast<const Cylinder*>(&(*surfaces[outer]))->radius() <
        dynamic_cast<const Cylinder*>(&(*surfaces[inner]))->radius()) {
      LogTrace("magneticfield::volumeHandle") << "*** WARNING: pos_outer < pos_inner ";
    }
  }
  // Save volume boundaries
  theRMin = rIn;
  theRMax = rOut;
  thePhiMin = surfaces[phiminus]->position().phi();
}
