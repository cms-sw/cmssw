#!/usr/bin/env python
"""module to read profiling information generated by the SimpleProfiling Service
"""
import os
class FunctionInfo(object):
    """Holds the profiling information about one function
    """
    def __init__(self,attrList):
        self.address =attrList[0] 
        self.name =os.popen("c++filt  "+attrList[-1]).read().strip()
        self.leafCount = int(attrList[1])
        self.countOfFunctPlusChildWithRecursion = int(attrList[2])
        self.countOfFunctPlusChild = int(attrList[3])
        self.fractionInFunctionOnly = float(attrList[4])
        self.fractionInPath = float(attrList[5])
        self.__callerTemp = dict()
        self.__calleeTemp = dict()
    def addCaller(self,caller,weight):
        #print caller.name, weight
        self.__callerTemp.setdefault(caller.address,[0,caller])[0]+=weight
    def addCallee(self,callee,weight):
        self.__calleeTemp.setdefault(callee.address,[0,callee])[0]+=weight
    def normalize(self):
        self.callerList = list()
        self.calleeList = list()
        for caller in self.__callerTemp.keys():
            (count,_caller) = self.__callerTemp[caller]
            self.callerList.append((float(count)/self.countOfFunctPlusChildWithRecursion,_caller))
        for callee in self.__calleeTemp.keys():
            (count,_callee) = self.__calleeTemp[callee]
            self.calleeList.append((float(count)/self.countOfFunctPlusChildWithRecursion,_callee))
        self.callerList.sort()
        self.callerList.reverse()
        self.calleeList.sort()
        self.calleeList.reverse()

class Path(object):
    def __init__(self,attrList):
        self.count = int(attrList[0])
        self.functionIds = [int(x) for x in attrList[1:] if x != '\n']

class ProfileData(object):
    def __init__(self,filesToUseInfo,feedBackStream=None):
        #try to determine the filePrefix from the value given
        # since caller may have given us just one of the files
        # instead of the prefix to the files
        (dir,base) = os.path.split(filesToUseInfo)
        uniqueID = base.split('_')[1]
        filePrefix = os.path.join(dir,"profdata_"+uniqueID+"_")
        if feedBackStream:
            feedBackStream.write('reading file: '+filePrefix+'names')
        nameFile = file(filePrefix+'names','r')
        self.idToFunctionInfo = dict()
        self.functionNameToId = dict()
        feedbackIndex = 0
        for line in nameFile:
            if feedBackStream and (0 == feedbackIndex % 100):
                feedBackStream.write('.')
            feedbackIndex +=1
            infoList = line.split('\t')
            self.idToFunctionInfo.setdefault( int(infoList[0]), FunctionInfo(infoList[1:]))
            self.functionNameToId.setdefault(self.idToFunctionInfo[int(infoList[0])].name, int(infoList[0]))
        if feedBackStream:
            feedBackStream.write('\nreading file: '+filePrefix+'paths')
        pathFile = file(filePrefix+'paths','r')
        self.paths = list()
        feedbackIndex = 0
        for line in pathFile:
            if feedBackStream and (0 == feedbackIndex % 100):
                feedBackStream.write('.')
            feedbackIndex +=1
            line.strip()
            path = Path( line.split(' ')[1:])
            self.paths.append(path)
            caller = None
            for funcId in path.functionIds:
                func = self.idToFunctionInfo[funcId]
                if caller:
                    func.addCaller(caller,path.count)
                    caller.addCallee(func,path.count)
                caller = func
        feedbackIndex = 0
        if feedBackStream:
            feedBackStream.write('\nprocessing data:')
        for x in self.idToFunctionInfo.items():
            if feedBackStream and (0 == feedbackIndex % 100):
                feedBackStream.write('.')
            feedbackIndex +=1
            x[1].normalize()

if __name__ == '__main__':
    import sys
    profile = ProfileData(sys.argv[1])
    print profile.idToFunctionInfo

