#!  /usr/bin/env python
import string
import re
from optparse import OptionParser

class XmlParser(object):
    """Parses a classes_def.xml file looking for class declarations that contain
    ClassVersion attributes. Once found looks for sub-elements named 'version'
    which contain the ClassVersion to checksum mappings.
    """
    
    #The following are constants used to describe what data is kept
    # in which index in the 'classes' member data
    originalNameIndex=0
    classVersionIndex=1
    versionsToChecksumIndex = 2
    
    def __init__(self,filename):
        self._file = filename
        self.classes = dict()
        self.anames =[]
        self._presentClass = None
        self.readClassesDefXML()
    def readClassesDefXML(self):
        import xml.parsers.expat
        p = xml.parsers.expat.ParserCreate()
        p.StartElementHandler = self.start_element
        p.EndElementHandler = self.end_element
        f = open(self._file)
        # Replace any occurence of <>& in the attribute values by the xml parameter
        rxml, nxml = f.read(), ''
        q1,q2 = 0,0
        for c in rxml :
            if   (q1 or q2) and c == '<' : nxml += '&lt;'
            elif (q1 or q2) and c == '>' : nxml += '&gt;'
            # elif (q1 or q2) and c == '&' : nxml += '&amp;'
            else                         : nxml += c
            if c == '"' : q1 = not q1
            if c == "'" : q2 = not q2
        try : p.Parse(nxml)
        except xml.parsers.expat.ExpatError, e :
            print '--->> edmCheckClassVersion: ERROR: parsing selection file ',self._file
            print '--->> edmCheckClassVersion: ERROR: Error is:', e
            raise
        f.close()
    def start_element(self,name,attrs):
        if name in ('class','struct'):
            if 'name' in attrs:
                if re.search('^edm::AssociationMap<',attrs['name']):
                   self.anames.append(attrs['name'])
        pass
    def end_element(self,name):
        if name in ('class','struct'):
            self._presentClass = None
    def genNName(self, name ):
        n_name = string.join(name.split())
        for e in [ ['long long unsigned int', 'unsigned long long'],
                   ['long long int',          'long long'],
                   ['unsigned short int',     'unsigned short'],
                   ['short unsigned int',     'unsigned short'],
                   ['short int',              'short'],
                   ['long unsigned int',      'unsigned long'],
                   ['unsigned long int',      'unsigned long'],
                   ['long int',               'long'],
                   ['std::string',            'std::basic_string<char>']] :
            n_name = n_name.replace(e[0],e[1])
        n_name = n_name.replace(' ','')
        return n_name


def checkTrans(name):
    c = ROOT.TClass.GetClass(name)
    if not c:
        raise RuntimeError("failed to load dictionary for class '"+name+"'")
    print "Checking "+name
    tdm = c.GetDataMember("transientMap_")
    retval = False
    if tdm :
      retval = tdm.IsPersistent()
    if retval == True : print "Error: field transientMap_ must be labeled transient=\"true\" in classes_def.xml for '"+name+"'"

#Setup the options
from optparse import OptionParser
oparser = OptionParser()
oparser.add_option("-l","--lib", dest="library",
                   help="specify the library to load. If not set classes are found using the PluginManager")
oparser.add_option("-x","--xml_file", dest="xmlfile",default="./classes_def.xml",
                   help="the classes_def.xml file to read")

(options,args)=oparser.parse_args()

import ROOT
#Keep ROOT from trying to use X11
ROOT.gROOT.SetBatch(True)
ROOT.gROOT.ProcessLine(".autodict")

if options.library is None:
    print "Transient member check requires a specific library"
else:
    if 0 != ROOT.gSystem.Load(options.library):
        raise RuntimeError("failed to load library '"+options.library+"'")

p = XmlParser(options.xmlfile)

transError=0

for name in p.anames:
   checkTrans(name)
