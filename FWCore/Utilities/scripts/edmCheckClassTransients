#!  /usr/bin/env python
import string
import re
from optparse import OptionParser
import collections 

classtransients = collections.defaultdict(list)

classtransients['edm::AssociationMap'].append('transientMap_')
classtransients['edm::AssociationVector'].append('transientVector_')



class XmlParser(object):
    """Parses a classes_def.xml file looking for class declarations of edm template classes
    which contain member which must be labeled transient="true" in classes_def.xml
    """
    
    def __init__(self,filename):
        self._file = filename
        self.cnames = collections.defaultdict(list)
        self._presentClass = None
        self.readClassesDefXML()
    def readClassesDefXML(self):
        import xml.parsers.expat
        p = xml.parsers.expat.ParserCreate()
        p.StartElementHandler = self.start_element
        f = open(self._file)
        # Replace any occurence of <>& in the attribute values by the xml parameter
        rxml, nxml = f.read(), ''
        q1,q2 = 0,0
        for c in rxml :
            if   (q1 or q2) and c == '<' : nxml += '&lt;'
            elif (q1 or q2) and c == '>' : nxml += '&gt;'
            # elif (q1 or q2) and c == '&' : nxml += '&amp;'
            else                         : nxml += c
            if c == '"' : q1 = not q1
            if c == "'" : q2 = not q2
        try : p.Parse(nxml)
        except xml.parsers.expat.ExpatError, e :
            print '--->> edmCheckClassTransients: ERROR: parsing selection file ',self._file
            print '--->> edmCheckClassTransients: ERROR: Error is:', e
            raise
        f.close()
    def start_element(self,name,attrs):
        if name in ('class','struct'):
            if 'name' in attrs:
                cname=attrs['name']
                for key in classtransients.keys():
                    if re.search(r'^%s<' % key, cname):
			self.cnames[key].append(cname)
                            
        pass

def checkTrans(tempname,name):
    c = ROOT.TClass.GetClass(name)
    if not c:
        raise RuntimeError("failed to load dictionary for class '"+name+"'")
    print "Checking "+name
    for trans in classtransients[tempname]:
      tdm = c.GetDataMember(trans)
      retval = False
      if tdm : retval = tdm.IsPersistent()
      if retval == True : print "Error: field '"+trans+"' must be labeled transient=\"true\" in classes_def.xml for '"+name+"'"


#Setup the options
from optparse import OptionParser
oparser = OptionParser()
oparser.add_option("-l","--lib", dest="library",
                   help="specify the library to load. If not set classes are found using the PluginManager")
oparser.add_option("-x","--xml_file", dest="xmlfile",default="./classes_def.xml",
                   help="the classes_def.xml file to read")

(options,args)=oparser.parse_args()

import ROOT
#Keep ROOT from trying to use X11
ROOT.gROOT.SetBatch(True)
ROOT.gROOT.ProcessLine(".autodict")

if options.library is None:
    print "Transient member check requires a specific library"
else:
    if 0 != ROOT.gSystem.Load(options.library):
        raise RuntimeError("failed to load library '"+options.library+"'")

p = XmlParser(options.xmlfile)

transError=0

for key in p.cnames.keys():
    for value in p.cnames[key]:
        checkTrans(key,value)
