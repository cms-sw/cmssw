// -*- C++ -*-
#include "Rivet/Analysis.hh"
#include "Rivet/RivetAIDA.hh"
#include "Rivet/Tools/Logging.hh"
#include "Rivet/Projections/FinalState.hh"
#include "Rivet/Projections/FastJets.hh"
#include "fastjet/tools/Filter.hh"
#include "fastjet/tools/Pruner.hh"
#include "Rivet/Projections/WFinder.hh"
#include "Rivet/Projections/ZFinder.hh"
#include "Rivet/Particle.hh"
#include "Rivet/Tools/ParticleIdUtils.hh"

namespace Rivet {
    
    
    class CMS_2013_I1224539 : public Analysis {
    public:
        
        /// @name Constructors etc.
        //@{
        
        /// Constructor
        CMS_2013_I1224539()
        : Analysis("CMS_2013_I1224539")
        {    }
        
        //@}
        
        
    public:
        
        /// @name Analysis methods
        //@{
        
        /// Book histograms and initialise projections before the run
        void init() {
            
            FinalState fs(-2.4, 2.4, 0.0*GeV);
            addProjection(fs, "FS");
            
            // find Z's, z pT > 125
            ZFinder zfinder(fs, -2.4, 2.4, 30.0*GeV, ELECTRON, 80.0*GeV, 100.0*GeV, 0.2, true, true);
            addProjection(zfinder, "ZFinder");  
            
            // Z+jet jet collections
            addProjection(FastJets(zfinder.remainingFinalState(), FastJets::ANTIKT, 0.7), "JetsAK7_zj");
            addProjection(FastJets(zfinder.remainingFinalState(), FastJets::CAM, 0.8), "JetsCA8_zj");
            addProjection(FastJets(zfinder.remainingFinalState(), FastJets::CAM, 1.2), "JetsCA12_zj");
            
            
            // GG Rivet. No 2-d histograms. Boooo. 
            // zjets offset
            int zjetsOffset = 28;
            for( unsigned i = 0; i < N_PT_BINS_vj; ++i ) {
                _h_ungroomedJetMass_AK7_zj[i] = bookHistogram1D(zjetsOffset+i+1+0*N_PT_BINS_vj,1,1);
            }
            for( unsigned i = 0; i < N_PT_BINS_vj; ++i ) {
                _h_filteredJetMass_AK7_zj[i] = bookHistogram1D(zjetsOffset+i+1+1*N_PT_BINS_vj,1,1);
            }
            for( unsigned i = 0; i < N_PT_BINS_vj; ++i ) {
                _h_trimmedJetMass_AK7_zj[i] = bookHistogram1D(zjetsOffset+i+1+2*N_PT_BINS_vj,1,1);
            }
            for( unsigned i = 0; i < N_PT_BINS_vj; ++i ) {
                _h_prunedJetMass_AK7_zj[i] = bookHistogram1D(zjetsOffset+i+1+3*N_PT_BINS_vj,1,1);
            }
            for( unsigned i = 0; i < N_PT_BINS_vj; ++i ) {
                _h_prunedJetMass_CA8_zj[i] = bookHistogram1D(zjetsOffset+i+1+4*N_PT_BINS_vj,1,1);
            }
            for( unsigned i = 1; i < N_PT_BINS_vj; ++i ) {
                _h_filteredJetMass_CA12_zj[i] = bookHistogram1D(zjetsOffset+i+5*N_PT_BINS_vj,1,1);
            }            
        }
        
        bool isBackToBack_zj(const ZFinder* zf, const fastjet::PseudoJet* psjet) {

            FourMomentum z = zf->bosons()[0].momentum();
            FourMomentum l1 = zf->constituents()[0].momentum();
            FourMomentum l2 = zf->constituents()[1].momentum();
            //FourMomentum jmom = psjet->momentum();
            FourMomentum jmom( psjet->px(), psjet->py(), psjet->pz(), psjet->e() );
            bool passes = false;
            if (deltaPhi(z,jmom) > 2.0 && deltaR(l1, jmom) > 1.0  && deltaR(l2, jmom) > 1.0) {
                passes = true;
            }
        
            return passes;
        }
        
        /// Perform the per-event analysis
        void analyze(const Event& event) {
            
            bool zjEvent = false;
                        
            // Hacking 2-d histograms. 
            double ptBins_vj[N_PT_BINS_vj+1] = {
                125.0,
                150.0,
                220.0,
                300.0,
                450.0};
            
            const double weight = event.weight() > 0 ? event.weight() : 1;
                                    
            // Get the Z "projection"
            Particle l1;
            Particle l2;
            const ZFinder& zfinder = applyProjection<ZFinder>(event, "ZFinder");
            if (zfinder.bosons().size() == 1) {
                zjEvent = true;
                l1=zfinder.constituents()[0];
                l2=zfinder.constituents()[1];                
            }
            
            // Get the pseudojets. 
            const PseudoJets& psjetsAK7_zj = applyProjection<FastJets>(event, "JetsAK7_zj").pseudoJetsByPt( 50.0*GeV );
            const PseudoJets& psjetsCA8_zj = applyProjection<FastJets>(event, "JetsCA8_zj").pseudoJetsByPt( 50.0*GeV );
            const PseudoJets& psjetsCA12_zj = applyProjection<FastJets>(event, "JetsCA12_zj").pseudoJetsByPt( 50.0*GeV );             
                        
            // Define the FJ3 grooming algorithms
            double rFilt = 0.3;
            int nFilt = 3;
            double rTrim = 0.2;
            double trimPtFracMin = 0.03;
            double zCut = 0.1;
            double RcutFactor = 0.5;
            
            fastjet::Filter filter( fastjet::Filter(fastjet::JetDefinition(fastjet::cambridge_algorithm, rFilt), fastjet::SelectorNHardest(nFilt)));
            fastjet::Filter trimmer( fastjet::Filter(fastjet::JetDefinition(fastjet::kt_algorithm, rTrim), fastjet::SelectorPtFractionMin(trimPtFracMin)));
            fastjet::Pruner pruner(fastjet::cambridge_algorithm, zCut, RcutFactor);      

            //std::cout << "wjEvent: " << wjEvent << ", zjEvent: " << zjEvent << std::endl;
						            
            // -----------------------
            // is Z+jet event
            if (zjEvent && (l1.momentum().pT() > 30) && (l2.momentum().pT() > 30)  && zfinder.bosons()[0].momentum().pT() > 120){
                
                // Look at events with >= 1 AK7 jets
                if (!psjetsAK7_zj.empty() && psjetsAK7_zj.size() > 0) {
                    
                    // Get the leading jet
                    const fastjet::PseudoJet& j0 = psjetsAK7_zj[0];
                    // make sure the jet is back-to-back with the Z
                    if (!isBackToBack_zj( &zfinder, &j0 )){
                        // Find the pt
                        double ptJ = j0.pt();
                        // Find the histogram bin that this belongs to. 
                        unsigned int njetBin = N_PT_BINS_vj;
                        for ( unsigned int ibin = 0; ibin < N_PT_BINS_vj; ++ibin ) {
                            if ( ptJ >= ptBins_vj[ibin] && ptJ < ptBins_vj[ibin+1] ) {
                                njetBin = ibin;
                                break;
                            }
                        }
                        
                        if ( njetBin < N_PT_BINS_vj ){
                            
                            // Now run the substructure algs...
                            fastjet::PseudoJet filtered0 = filter(j0);                     
                            fastjet::PseudoJet trimmed0 = trimmer(j0); 
                            fastjet::PseudoJet pruned0 = pruner(j0); 
                            
                            // ... and fill the hists
                            _h_ungroomedJetMass_AK7_zj[njetBin]->fill( j0.m() / GeV, weight);
                            _h_filteredJetMass_AK7_zj[njetBin]->fill( filtered0.m() / GeV, weight);
                            _h_trimmedJetMass_AK7_zj[njetBin]->fill( trimmed0.m() / GeV, weight);
                            _h_prunedJetMass_AK7_zj[njetBin]->fill( pruned0.m() / GeV, weight);
                        }
                    }
                }
                // Look at events with >= 1 CA8 jets
                if (!psjetsCA8_zj.empty() && psjetsCA8_zj.size() > 0) {
                    
                    // Get the leading jet
                    const fastjet::PseudoJet& j0 = psjetsCA8_zj[0];
                    // make sure the jet is back-to-back with the Z
                    if (!isBackToBack_zj( &zfinder, &j0 )){
                        // Find the pt
                        double ptJ = j0.pt();
                        // Find the histogram bin that this belongs to. 
                        unsigned int njetBin = N_PT_BINS_vj;
                        for ( unsigned int ibin = 0; ibin < N_PT_BINS_vj; ++ibin ) {
                            if ( ptJ >= ptBins_vj[ibin] && ptJ < ptBins_vj[ibin+1] ) {
                                njetBin = ibin;
                                break;
                            }
                        }
                        
                        if ( njetBin < N_PT_BINS_vj ){
                    
                            // Now run the substructure algs...
                            fastjet::PseudoJet pruned0 = pruner(j0); 
                            
                            // ... and fill the hists
                            _h_prunedJetMass_CA8_zj[njetBin]->fill( pruned0.m() / GeV, weight);
                        }
                    }
                }
                // Look at events with >= 1 CA12 jets
                if (!psjetsCA12_zj.empty() && psjetsCA12_zj.size() > 0) {
                    
                    // Get the leading jet
                    const fastjet::PseudoJet& j0 = psjetsCA12_zj[0];
                    // make sure the jet is back-to-back with the Z
                    if (!isBackToBack_zj( &zfinder, &j0 )){
                        // Find the pt
                        double ptJ = j0.pt();
                        // Find the histogram bin that this belongs to. 
                        unsigned int njetBin = N_PT_BINS_vj;
                        for ( unsigned int ibin = 1; ibin < N_PT_BINS_vj; ++ibin ) {
                            if ( ptJ >= ptBins_vj[ibin] && ptJ < ptBins_vj[ibin+1] ) {
                                njetBin = ibin;
                                break;
                            }
                        }
                        
                        if ( njetBin < N_PT_BINS_vj ){
                    
                            // Now run the substructure algs...
                            fastjet::PseudoJet filtered0 = filter(j0); 
                            
                            // ... and fill the hists
                            _h_filteredJetMass_CA12_zj[njetBin]->fill( filtered0.m() / GeV, weight);
                        }
                    }
                }
                
            }
            
        }
        /// Normalise histograms etc., after the run
        void finalize() {
            
            double normalizationVal = 1000.;
            
            for ( unsigned int i = 0; i < N_PT_BINS_vj; ++i ) {
                normalize( _h_ungroomedJetMass_AK7_zj[i], normalizationVal );
                normalize( _h_filteredJetMass_AK7_zj[i], normalizationVal );
                normalize( _h_trimmedJetMass_AK7_zj[i], normalizationVal );
                normalize( _h_prunedJetMass_AK7_zj[i], normalizationVal );
                normalize( _h_prunedJetMass_CA8_zj[i], normalizationVal );                  
            }
            for ( unsigned int i = 1; i < N_PT_BINS_vj; ++i ) {
                normalize( _h_filteredJetMass_CA12_zj[i], normalizationVal );                
            }
            
        }
        
        //@}
        
        
    private:
        
        /// @name Histograms
        //@{

        enum {
            PT_125_150_vj=0,
            PT_150_220_vj,            
            PT_220_300_vj,
            PT_300_450_vj,
            N_PT_BINS_vj
        } BINS_vj;
                
        AIDA::IHistogram1D * _h_ungroomedJetMass_AK7_zj[N_PT_BINS_vj];
        AIDA::IHistogram1D * _h_filteredJetMass_AK7_zj[N_PT_BINS_vj];
        AIDA::IHistogram1D * _h_trimmedJetMass_AK7_zj[N_PT_BINS_vj];
        AIDA::IHistogram1D * _h_prunedJetMass_AK7_zj[N_PT_BINS_vj];
        AIDA::IHistogram1D * _h_prunedJetMass_CA8_zj[N_PT_BINS_vj];        
        AIDA::IHistogram1D * _h_filteredJetMass_CA12_zj[N_PT_BINS_vj-1];         
        
        //@}
        
        
    };
    
    
    
    // The hook for the plugin system
    DECLARE_RIVET_PLUGIN(CMS_2013_I1224539);
    
}
